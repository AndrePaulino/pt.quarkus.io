<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE tmx SYSTEM "tmx14.dtd">
<tmx version="1.4">
  <header creationtool="Translate Toolkit" creationtoolversion="3.6.1" segtype="sentence" o-tmf="UTF-8" adminlang="en" srclang="en" datatype="PlainText"/>
  <body>
    <tu>
      <tuv xml:lang="en">
        <seg>What is Quarkus?</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>¿Qué es Quarkus?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What is your license?</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>¿Qué licencia tiene?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Where can I get it?</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>¿Dónde puedo conseguirlo?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus is published in Maven Central, check out [which extensions](/extensions) you need and just import them in your `pom.xml` to get Quarkus. We recommend you start your Quarkus experience via our [Getting Started guides](/get-started).
</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Quarkus está publicado en Maven Central, comprueba [qué extensiones(/extensions) necesitas y simplemente impórtalas en tu `pom.xml` para obtener Quarkus. Te recomendamos que comiences tu experiencia con Quarkus a través de nuestras [Guías de inicio](/get-started).
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus is stable?</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>¿Quarkus es estable?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can go to [code.quarkus.io](https://code.quarkus.io/) to see if a particular extension is _stable_ (default) or _preview_.
</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Puedes ir a https://code.quarkus.io/[code.quarkus.io] para ver si una extensión en particular es _stable_ (default) o _preview_.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What is a Quarkus extension?</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>¿Qué es una extensión de Quarkus?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Think of Quarkus extensions as your project dependencies. Extensions configure, boot and integrate a framework or technology into your Quarkus application. They also do all of the heavy lifting of providing the right information to GraalVM for your application to compile natively. This will allow 3rd party projects to easily take advantage of the work we have done to make it easier to target GraalVM.
</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Piense en las extensiones de Quarkus como dependencias de su proyecto. Las extensiones configuran, arrancan e integran marcos o tecnologías en su aplicación de Quarkus, y ademas hacen todo el trabajo pesado de proporcionar la información correcta a GraalVM para que su aplicación se compile de forma nativa. Esto permite que los proyectos de terceros aprovechen fácilmente el trabajo que hemos realizado para que sea más fácil apuntar a GraalVM.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What are the extension statuses?</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>¿Cuáles son los estados de las extensiones?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>**Preview**: backward compatibility and presence in the ecosystem is not guaranteed. Specific improvements might require to change configuration or APIs and plans to become _stable_ are under way. Such extensions are in the middle of their maturation process.
</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>**Preview**: la compatibilidad con versiones anteriores y la presencia en el ecosistema no están garantizadas. Ciertas mejoras pueden requerir cambios de configuración o API, y hay planes en marcha para volverse _stable_. Estas extensiones están en medio del proceso de maduración.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can find the extension status on [code.quarkus.io](https://code.quarkus.io) or in the extension [guides](/guides/).
</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Puede encontrar el estado de la extensión en https://code.quarkus.io[code.quarkus.io] o en el enlace de la extensión link:/guides/[guides].
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Will the Quarkus team accept my extension?</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>¿El equipo de Quarkus aceptará mi extensión?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Oh yeah! We had quite a few extensions written outside the Quarkus "initial" team.
</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>¡Por supuesto! Se ha creado un número significativo de extensiones fuera del equipo "inicial" de Quarkus.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The one current restriction is that extensions should work in both OpenJDK and GraalVM native executables. That is the guarantee we give Quarkus users (a cross compilation for their app). We have a maturity model to improve an extension to be fully "Quarked" and benefit from Quarkus, all done in incremental steps. Just hop on our [mailing list](https://quarkus.io/community/#discussions) to discuss your ideas and get help. And you can start reading our [Writing extensions guide](https://quarkus.io/guides/writing-extensions) as well or more simply get inspiration from the [existing ones](https://github.com/quarkusio/quarkus/tree/master/extensions).
</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>La limitacion actual es que las extensiones deben funcionar con los ejecutables nativos de OpenJDK y GraalVM. Esta es una garantía que brindamos a los usuarios de Quarkus (compilación cruzada de aplicaciones). Tenemos un modelo de madurez para mejorar una extensión para que sea completamente "Quarked" y beneficiarse de Quarkus, todo hecho en pasos incrementales. Visite https://quarkus.io/community/#discussions[mailing list] para discutir ideas y obtener apoyo. También puede comenzar a leer https://quarkus.io/guides/writing-extensions[Writing extensions guide] o puede inspirarse en https://github.com/quarkusio/quarkus/tree/main/extensions[existing ones].
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What is GraalVM?</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>## ¿Qué es GraalVM?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[GraalVM](https://www.graalvm.org) is a universal virtual machine for running applications written in various different languages, as well as providing the ability to compile JVM bytecode to a native executable (this native executable runs a special virtual machine called SubstrateVM). These native executables start much faster and can use a lot less memory than a traditional JVM, however not every JVM feature is supported, and some are more limited than normal.
</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>https://www.graalvm.org[GraalVM] es una máquina virtual universal para ejecutar aplicaciones escritas en varios lenguajes diferentes, además de brindar la capacidad de compilar código de bytes JVM en un ejecutable nativo (este ejecutable nativo ejecuta una maquina virtual especial llamada SubstrateVM). Estos ejecutables nativos se inician mucho más rápido y pueden usar mucha menos memoria que una JVM tradicional, sin embargo, no todas las funciones de JVM son compatibles y algunas son más limitadas de lo normal.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example by default reflection in GraalVM will not work, unless a class/member has been explicitly registered for reflection. This is normally achieved by listing every class, method, field and constructor in a JSON file, and passing this as a parameter into the native image build. This obviously gets quite cumbersome for all but the most trivial projects. Quarkus provides a framework that makes it easy to work around these annotations, and programmatically determine what should be registered.
</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Por ejemplo, de forma predeterminada, la reflexión en GraalVM no funcionará, a menos que una clase/miembro se haya registrado explícitamente para la reflexión. Esto normalmente se logra listando cada clase, método, campo y constructor en un archivo JSON, y pasándolo como un parámetro Obviamente, esto se vuelve bastante engorroso para todos los proyectos, excepto para los más triviales. Quarkus proporciona un marco que facilita el trabajo en torno a estas anotaciones y proporciona un marco que le permite decidir mediante programación qué registrar.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>How do you unify imperative and reactive programming?</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>## ¿Cómo se unifica la programación imperativa y reactiva?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What does Container First mean?</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>## ¿Qué significa Container First?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What is your view on standards?</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>## ¿Cuál es su punto de vista sobre los estándares?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What are you doing to improve developer joy?</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>## ¿Qué estás haciendo para mejorar la alegría de los desarrolladores?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In-Person and online events which feature Quarkus tracks, discussion and topics.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Eventos en persona y en línea que presentan desarrollos, debates y temas de Quarkus</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus is published in Maven Central, check out link:/extensions[which extensions] you need and just import them in your `pom.xml` to get Quarkus. We recommend you start your Quarkus experience via our link:/get-started[Getting Started guides].</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Quarkus es publicado en Maven Central, para obtener Quarkus consulte el link:/extensions[which extensions] y simplemente impórtelos en su `pom.xml`. Le recomendamos que comience su experiencia con Quarkus a través de nuestro link:/get-started[Getting Started guides]. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>One of the main goals of Quarkus is ease of extensibility and to build a vibrant ecosystem.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Uno de los principales objetivos de Quarkus es la facilidad de extensibilidad y la construcción de un ecosistema vibrante</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Think of Quarkus extensions as your project dependencies. Extensions configure, boot and integrate a framework or technology into your Quarkus application. They also do all of the heavy lifting of providing the right information to GraalVM for your application to compile natively. This will allow 3rd party projects to easily take advantage of the work we have done to make it easier to target GraalVM.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Piense en las extensiones de Quarkus como dependencias de su proyecto. Las extensiones configuran, arrancan e integran marcos o tecnologías en su aplicación de Quarkus, y ademas hacen todo el trabajo pesado de proporcionar la información correcta a GraalVM para que su aplicación se compile de forma nativa. Esto permite que los proyectos de terceros aprovechen fácilmente el trabajo que hemos realizado para que sea más fácil apuntar a GraalVM</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extensions have a various degree of maturity when they enter the Quarkus ecosystem. A status offers the expectations you can rely on.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Las extensiones tienen varios grados de madurez a medida que ingresan al ecosistema de Quarkus. El estado ofrece el valor esperado de confianza</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*Preview*: backward compatibility and presence in the ecosystem is not guaranteed. Specific improvements might require to change configuration or APIs and plans to become _stable_ are under way. Such extensions are in the middle of their maturation process.
</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>*Preview*: la compatibilidad con versiones anteriores y la presencia en el ecosistema no están garantizadas. Ciertas mejoras pueden requerir cambios de configuración o API, y hay planes en marcha para volverse _stable_. Estas extensiones están en medio del proceso de maduración.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Can I write an extension?</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>¿Puedo crear una extensión?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Oh yeah! We had quite a few extensions written outside the Quarkus "initial" team.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>¡Por supuesto! Se ha creado un número significativo de extensiones fuera del equipo "inicial" de Quarkus.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>## What is GraalVM?</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>## ¿Qué es GraalVM?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example by default reflection in GraalVM will not work, unless a class/member has been explicitly registered for reflection. This is normally achieved by listing every class, method, field and constructor in a JSON file, and passing this as a parameter into the native image build. This obviously gets quite cumbersome for all but the most trivial projects. Quarkus provides a framework that makes it easy to work around these annotations, and programmatically determine what should be registered.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Por ejemplo, de forma predeterminada, la reflexión en GraalVM no funcionará, a menos que una clase/miembro se haya registrado explícitamente para la reflexión. Esto normalmente se logra listando cada clase, método, campo y constructor en un archivo JSON, y pasándolo como un parámetro Obviamente, esto se vuelve bastante engorroso para todos los proyectos, excepto para los más triviales. Quarkus proporciona un marco que facilita el trabajo en torno a estas anotaciones y proporciona un marco que le permite decidir mediante programación qué registrar</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>## How do you unify imperative and reactive programming?</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>## ¿Cómo se unifica la programación imperativa y reactiva?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>## What does Container First mean?</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>## ¿Qué significa Container First?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>## What is your view on standards?</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>## ¿Cuál es su punto de vista sobre los estándares?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>## What are you doing to improve developer joy?</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>## ¿Qué estás haciendo para mejorar la alegría de los desarrolladores?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`true`</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>`true`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`false`</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>`false`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`localhost`</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>`localhost`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`binary`</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>`binary`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Amazon Lambda</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Amazon Lambda</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Browse through these selections of new Quarkus related books and resources to expand your knowledge and hone your coding skills to step up your Quarkus game.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Explore estas selecciones de nuevos libros y recursos relacionados con Quarkus para expandir su conocimiento y perfeccionar sus habilidades de codificación para mejorar su juego de Quarkus</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive].</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Clone el repositorio Git: `git clone {quickstarts-clone-url}` o descargue un {quickstarts-archive-url}[archivo].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What's next?</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>¿Qué es lo que sigue?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-sam-cli-install.html[AWS SAM CLI]</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-sam-cli-install.html[AWS SAM CLI]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Installing all the AWS bits is probably the most difficult thing about this guide.  Make sure that you follow all the steps for installing AWS SAM CLI.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Instalar todos los bits de AWS es probablemente lo más difícil de esta guía. Asegúrate de seguir todos los pasos para instalar AWS SAM CLI.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>After you run the build, there are a few extra files generated by the `quarkus-amazon-lambda` extension.  These files are in the the build directory: `target/` for maven, `build/` for gradle.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Después de ejecutar la construcción, hay algunos archivos adicionales generados por la extensión `quarkus-amazon-lambda`. Estos archivos están en el directorio de construcción: `target/` para maven, `build/` para gradle.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>http://127.0.0.1:3000/hello</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>http://127.0.0.1:3000/hello</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the console you'll see startup messages from the lambda.  This particular deployment starts a JVM and loads your lambda as pure Java.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>En la consola verás los mensajes de inicio de la lambda. Este despliegue particular inicia una JVM y carga tu lambda como Java puro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Responses for binary types will be automatically encoded with base64.  This is different than the behavior using `quarkus:dev` which will return the raw bytes.  Amazon's API has additional restrictions requiring the base64 encoding.  In general, client code will automatically handle this encoding but in certain custom situations, you should be aware you may need to manually manage that encoding.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Las respuestas para los tipos binarios se codificarán automáticamente con base64. Esto es diferente al comportamiento usando `quarkus:dev` que devolverá los bytes sin procesar. La API de Amazon tiene restricciones adicionales que requieren la codificación base64. En general, el código del cliente manejará automáticamente esta codificación, pero en ciertas situaciones personalizadas, debes tener en cuenta que puedes necesitar manejar manualmente esa codificación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are building native images, and want to use https://aws.amazon.com/xray[AWS X-Ray Tracing] with your lambda you will need to include `quarkus-amazon-lambda-xray` as a dependency in your pom.  The AWS X-Ray library is not fully compatible with GraalVM so we had to do some integration work to make this work.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Si estás construyendo imágenes nativas, y quieres usar https://aws.amazon.com/xray[AWS X-Ray Tracing] con tu lambda necesitarás incluir `quarkus-amazon-lambda-xray` como una dependencia en tu pom. La biblioteca de AWS X-Ray no es totalmente compatible con GraalVM, por lo que hemos tenido que hacer un trabajo de integración para que funcione.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn how to create a Hello World Quarkus app.  This guide covers:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Aprende como crear una aplicación Hello World de Quarkus. Esta guía cubre:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you have multiple JDK's installed it is not certain Maven will pick up the expected java and you could end up with unexpected results.  You can verify which JDK Maven uses by running `mvn --version`.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Si tienes varios JDK's instalados no es seguro que Maven use el java esperado y podrías terminar con resultados inesperados. Puedes verificar qué JDK utiliza Maven ejecutando `mvn --version`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we create a straightforward application serving a `hello` endpoint. To demonstrate dependency injection, this endpoint uses a `greeting` bean.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>En esta guía, creamos una aplicación sencilla que sirve un endpoint de `hello`. Para demostrar la inyección de dependencias, este endpoint utiliza un bean `greeting`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>a landing page that is accessible on `http://localhost:8080` after starting the application</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>una página inicial que es accesible en `&amp;lt;a href="http://localhost:8080" class="bare"&amp;gt;http://localhost:8080&amp;lt;/a&amp;gt;` después de iniciar la aplicación</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With Quarkus, there is no need to create an `Application` class. It's supported, but not required. In addition, only one instance of the resource is created and not one per request. You can configure this using the different `*Scoped` annotations (`ApplicationScoped`, `RequestScoped`, etc).</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Con Quarkus, no es necesario crear una clase `Application`. Se admite, pero no se requiere. Además, solo se crea una instancia del recurso y no una por solicitud. Esto se puede configurar utilizando las diferentes anotaciones de `*Scoped` ( `ApplicationScoped`, `RequestScoped`, etc).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By using the `QuarkusTest` runner, you instruct JUnit to start the application before the tests.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Utilizando el runner `QuarkusTest`, se indica a JUnit que inicie la aplicación antes que las pruebas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The test port can be controlled via the `quarkus.http.test-port` config property. Quarkus also creates a system property called `test.url` that is set to the base test URL for situations where you cannot use injection.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>El puerto de prueba puede ser controlado a través de la propiedad de configuración `quarkus.http.test-port`. Quarkus también crea una propiedad del sistema llamada `test.url` que se establece en la URL de prueba base para situaciones en las que no se puede utilizar la inyección.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus heavily utilizes https://github.com/wildfly/jandex[Jandex] at build time, to discover various classes or annotations. One immediately recognizable application of this, is CDI bean discovery.  As a result, most of the Quarkus extensions will not work properly if this build time discovery isn't properly setup.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Quarkus utiliza en gran medida https://github.com/wildfly/jandex[Jandex] en tiempo de construcción, para descubrir varias clases o anotaciones. Una aplicación inmediatamente reconocible de esto, es el descubrimiento de bean CDI. Como resultado, la mayoría de las extensiones de Quarkus no funcionarán correctamente si este descubrimiento en tiempo de construcción no está configurado correctamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you plan to use external modules (for example, an external library for all your domain objects), you will need to make these modules known to the indexing process either by adding the Jandex plugin (if you can modify them)  or via the `quarkus.index-dependency` property inside your `application.properties` (useful in cases where you can't modify the module).</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Si tiene previsto utilizar módulos externos (por ejemplo, una biblioteca externa para todos sus objetos de dominio), tendrá que dar a conocer estos módulos al proceso de indexación, ya sea añadiendo el plugin de Jandex (si puede modificarlos) o a través de la propiedad `quarkus.index-dependency` dentro de su `application.properties` (útil en los casos en que no pueda modificar el módulo).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default when a Quarkus application starts (in regular or dev mode), it will display an ASCII art banner. The banner can be disabled by setting `quarkus.banner.enabled=false` in `application.properties`, by setting the `-Dquarkus.banner.enabled=false` Java System Property, or by setting the `QUARKUS_BANNER_ENABLED` environment variable to `false`.  Furthermore, users can supply a custom banner by placing the banner file in `src/main/resources` and configuring `quarkus.banner.path=name-of-file` in `application.properties`.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Por defecto, cuando una aplicación Quarkus se inicia (en modo normal o dev), mostrará un banner de arte ASCII. El banner puede deshabilitarse configurando `quarkus.banner.enabled=false` en `application.properties`, configurando la propiedad del sistema Java `-Dquarkus.banner.enabled=false`, o configurando la variable de entorno `QUARKUS_BANNER_ENABLED` en `false`. Además, los usuarios pueden proporcionar un banner personalizado colocando el archivo de banner en `src/main/resources` y configurando `quarkus.banner.path=name-of-file` en `application.properties`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is a collection of preferred term in the documentation and website.  Please stay within these terms for consistency.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Esta es una colección de términos preferidos en la documentación y el sitio web. Por favor, manténgase dentro de estos términos por coherencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>* Substrate VM</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>* Substrate VM</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>* Docker image</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>* Imagen Docker</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>imperative and reactive. 'Nuff said.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>imperativo y reactivo. No hay más que decir.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://azure.microsoft.com[An Azure Account].  Free accounts work.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>https://azure.microsoft.com[Una cuenta de Azure]. Las cuentas gratuitas funcionan.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`groupId` - The maven groupId of this generated project.  Type in `org.acme`.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>`groupId` - El groupId de maven de este proyecto generado. Escriba en `org.acme`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`appName` - Use the default value.  This is the application name in Azure.  It must be a unique subdomain name under `*.azurewebsites.net`. Otherwise deploying to Azure will fail.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>`appName` - Utilice el valor por defecto. Este es el nombre de la aplicación en Azure. Debe ser un nombre de subdominio único bajo `*.azurewebsites.net`. De lo contrario, el despliegue en Azure fallará.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`appRegion` - Defaults to `westus`.  Dependent on your azure region.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>`appRegion` - Por defecto, `westus`. Depende de su región azure.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`function` - Use the default which is `quarkus`.  Name of your azure function. Can be anything you want.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>`function` - Utilice el valor por defecto que es `quarkus`. Nombre de su función azure. Puede ser cualquier cosa que desee.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`resourceGroup` - Use the default value.  Any value is fine though.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>`resourceGroup` - Utilice el valor por defecto. Sin embargo, cualquier valor es válido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `pom.xml` you generated in the previous step pulls in the `azure-functions-maven-plugin`.  Running maven install generates config files and a staging directory required by the `azure-functions-maven-plugin`.  Here's how to execute it.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>El `pom.xml` que generó en el paso anterior usa el `azure-functions-maven-plugin`. Ejecutar maven install genera los archivos de configuración y un directorio de staging requeridos por el `azure-functions-maven-plugin`. Así es como se ejecuta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>i.e.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>i.e.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://{appName}.azurewebsites.net/api/hello https://{appName}.azurewebsites.net/api/servlet/hello https://{appName}.azurewebsites.net/api/vertx/hello https://{appName}.azurewebsites.net/api/funqyHello</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>https://{appName}.azurewebsites.net/api/hello https://{appName}.azurewebsites.net/api/servlet/hello https://{appName}.azurewebsites.net/api/vertx/hello https://{appName}.azurewebsites.net/api/funqyHello</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Templates for Azure Functions deployment descriptors (`host.json`, `function.json`) are within the `azure-config` directory.  Edit them as you need to.  Rerun the build when you are ready.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Las plantillas para los descriptores de despliegue de Azure Functions ( `host.json`, `function.json`) están dentro del directorio `azure-config`. Edítelos según sea necesario. Vuelva a ejecutar la compilación cuando esté listo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*NOTE*: If you change the `function.json` `path` attribute or if you add a `routePrefix`,
your jax-rs endpoints won't route correctly.  See &lt;&lt;config-azure-paths&gt;&gt; for more information.
</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>*NOTA*: Si cambia el atributo `function.json` `path` o si añade un `routePrefix`,
sus endpoints jax-rs no se enrutarán correctamente. Consulte &lt;&lt;config-azure-paths&gt;&gt; para obtener más información.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you modify the `path` or add a `routePrefix` within the `azure-config/function.json` deployment descriptor, your code or configuration must also reflect any prefixes you specify for your path.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Si modifica el `path` o añade un `routePrefix` dentro del descriptor de despliegue `azure-config/function.json`, su código o configuración debe reflejar también cualquier prefijo que especifique para su ruta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>NOTE</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>NOTA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Credential profiles file at the default location (`~/.aws/credentials`) shared by all AWS SDKs and the AWS CLI</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Archivo de perfiles de credenciales en la ubicación por defecto ( `~/.aws/credentials`) compartido por todos los SDKs de AWS y la CLI de AWS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`mp.messaging.[outgoing|incoming].{channel-name}.property=value`</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>`mp.messaging.[outgoing|incoming].{channel-name}.property=value`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`byte[]`</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>`byte[]`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `quarkus-amazon-lambda` extension allows you to use Quarkus to build your AWS Lambdas.  Your lambdas can use injection annotations from CDI or Spring and other Quarkus facilities as you need them.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>La extensión `quarkus-amazon-lambda` le permite utilizar Quarkus para construir sus AWS Lambdas. Tus lambdas pueden utilizar anotaciones de inyección de CDI o Spring y otras facilidades de Quarkus según las necesites.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Installing all the AWS bits is probably the most difficult thing about this guide.  Make sure that you follow all the steps for installing AWS CLI.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Instalar todos los bits de AWS es probablemente lo más difícil de esta guía. Asegúrate de seguir todos los pasos para instalar AWS CLI.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `quarkus-amazon-lambda` extension scans your project for a class that directly implements the Amazon `RequestHandler&lt;?, ?&gt;` or `RequestStreamHandler` interface.  It must find a class in your project that implements this interface or it will throw a build time failure.  If it finds more than one handler class, a build time exception will also be thrown.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>La extensión `quarkus-amazon-lambda` busca en tu proyecto una clase que implemente directamente la interfaz de Amazon `RequestHandler&lt;?, ?&gt;` o `RequestStreamHandler`. Debe encontrar una clase en tu proyecto que implemente esta interfaz o lanzará un fallo de compilación. Si encuentra más de una clase manejadora, también se lanzará una excepción de tiempo de compilación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sometimes, though, you might have a few related lambdas that share code and creating multiple maven modules is just an overhead you don't want to do.  The `quarkus-amazon-lambda` extension allows you to bundle multiple lambdas in one project and use configuration or an environment variable to pick the handler you want to deploy.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>A veces, sin embargo, puedes tener unas cuantas lambdas relacionadas que comparten código y crear múltiples módulos de maven es una sobrecarga que no quieres hacer. La extensión `quarkus-amazon-lambda` te permite agrupar múltiples lambdas en un proyecto y utilizar la configuración o una variable de entorno para elegir el manejador que quieres desplegar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The generated project has three lambdas within it.  Two that implement the `RequestHandler&lt;?, ?&gt;` interface, and one that implements the `RequestStreamHandler` interface. One that is used and two that are unused.  If you open up `src/main/resources/application.properties` you'll see this:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>El proyecto generado tiene tres lambdas dentro de él. Dos que implementan la interfaz `RequestHandler&lt;?, ?&gt;`, y una que implementa la interfaz `RequestStreamHandler`. Una que se usa y dos que no se usan. Si abres `src/main/resources/application.properties` verás esto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The CDI name of the handler class must match the value specified within the `quarkus.lambda.handler` property.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>El nombre CDI de la clase manejadora debe coincidir con el valor especificado en la propiedad `quarkus.lambda.handler`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are a few steps to get your lambda running on AWS.  The generated maven project contains a helpful script to create, update, delete, and invoke your lambdas for pure Java and native deployments.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Hay algunos pasos para conseguir que su lambda se ejecute en AWS. El proyecto maven generado contiene un script útil para crear, actualizar, eliminar e invocar sus lambdas para implementaciones puramente Java y nativas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>View the https://docs.aws.amazon.com/lambda/latest/dg/gettingstarted-awscli.html[Getting Started Guide] for deploying a lambda with AWS CLI.  Specifically, make sure you have created an `Execution Role`.  You will need to define a `LAMBDA_ROLE_ARN` environment variable in your profile or console window, Alternatively, you can edit the `manage.sh` script that is generated by the build and put the role value directly there:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Consulte la https://docs.aws.amazon.com/lambda/latest/dg/gettingstarted-awscli.html[Guía de inicio] para implementar un lambda con AWS CLI. Específicamente, asegúrese de haber creado un `Execution Role`. Tendrá que definir una variable de entorno `LAMBDA_ROLE_ARN` en su perfil o ventana de consola, alternativamente, puede editar el script `manage.sh` que es generado por la construcción y poner el valor del rol directamente allí:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `target/manage.sh` script is for managing your lambda using the AWS Lambda Java runtime.  This script is provided only for your convenience. Examine the output of the `manage.sh` script if you want to learn what aws commands are executed to create, delete, and update your lambdas.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>El script `target/manage.sh` es para administrar su lambda utilizando el tiempo de ejecución de AWS Lambda Java. Este script se proporciona sólo para su comodidad. Examine la salida del script `manage.sh` si desea saber qué comandos de aws se ejecutan para crear, eliminar y actualizar sus lambdas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To verify your setup, that you have the AWS CLI installed, executed aws configure for the AWS access keys, and setup the `LAMBDA_ROLE_ARN` environment variable (as described above), please execute `manage.sh` without any parameters.  A usage statement will be printed to guide you accordingly.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Para verificar su configuración, que tiene la CLI de AWS instalada, ha ejecutado aws configure para las claves de acceso de AWS y ha configurado la variable de entorno `LAMBDA_ROLE_ARN` (como se ha descrito anteriormente), ejecute `manage.sh` sin ningún parámetro. Se imprimirá una declaración de uso para guiarte en consecuencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To see the `usage` statement, and validate AWS configuration:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Para ver la declaración `usage`, y validar la configuración de AWS:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can `create` your function using the following command:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Puede crear su función utilizando el siguiente comando, `create` :</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Do not change the handler switch.  This must be hardcoded to `io.quarkus.amazon.lambda.runtime.QuarkusStreamHandler::handleRequest`.  This handler bootstraps Quarkus and wraps your actual handler so that injection can be performed.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>No cambie el switch del manejador. Esto debe ser codificado en `io.quarkus.amazon.lambda.runtime.QuarkusStreamHandler::handleRequest`. Este manejador arranca Quarkus y envuelve su manejador real para que la inyección pueda ser realizada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If there are any problems creating the function, you must delete it with the `delete` function before re-running the `create` command.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Si hay algún problema en la creación de la función, debe borrarla con la función `delete` antes de volver a ejecutar el comando `create`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can update the Java code as you see fit.  Once you've rebuilt, you can redeploy your lambda by executing the `update` command.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Puedes actualizar el código Java como creas conveniente. Una vez que hayas reconstruido, puedes volver a desplegar tu lambda ejecutando el comando `update`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want a lower memory footprint and faster initialization times for your lambda, you can compile your Java code to a native executable.  Just make sure to rebuild your project with the `-Pnative` switch.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Si quieres una menor huella de memoria y tiempos de inicialización más rápidos para tu lambda, puedes compilar tu código Java a un ejecutable nativo. Sólo asegúrese de reconstruir su proyecto con el interruptor `-Pnative`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Either of these commands will compile and create a native executable image.  It also generates a zip file `target/function.zip`.  This zip file contains your native executable image renamed to `bootstrap`.  This is a requirement of the AWS Lambda Custom (Provided) Runtime.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Cualquiera de estos comandos compilará y creará una imagen ejecutable nativa. También genera un archivo zip `target/function.zip`. Este archivo zip contiene su imagen ejecutable nativa renombrada a `bootstrap`. Este es un requisito del tiempo de ejecución personalizado (proporcionado) de AWS Lambda.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The instructions here are exactly as above with one change: you'll need to add `native` as the first parameter to the `manage.sh` script:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Las instrucciones son exactamente las mismas que las anteriores con un cambio: tendrá que añadir `native` como primer parámetro del script `manage.sh`:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As above, commands can be stacked.  The only requirement is that `native` be the first parameter should you wish to work with native image builds.  The script will take care of the rest of the details necessary to manage your native image function deployments.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Como en el caso anterior, los comandos se pueden apilar. El único requisito es que `native` sea el primer parámetro si desea trabajar con construcciones de imágenes nativas. El script se encargará del resto de los detalles necesarios para gestionar sus despliegues de funciones de imagen nativa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Gradle build</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Construcción de Gradle</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-sam-cli-install.html[AWS SAM CLI] allows you to run your lambdas locally on your laptop in a simulated Lambda environment.  This requires https://www.docker.com/products/docker-desktop[docker] to be installed.  This is an optional approach should you choose to take advantage of it.  Otherwise, the Quarkus JUnit integration should be sufficient for most of your needs.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>La  https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-sam-cli-install.html[AWS SAM CLI]  le permite ejecutar sus lambdas localmente en su portátil en un entorno de Lambda simulado. Esto requiere la instalación de https://www.docker.com/products/docker-desktop[docker]. Este es un enfoque opcional en caso de que decidas aprovecharlo. De lo contrario, la integración de Quarkus JUnit debería ser suficiente para la mayoría de sus necesidades.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Run the following SAM CLI command to locally test your lambda function, passing the appropriate SAM `template`.  The `event` parameter takes any JSON file, in this case the sample `payload.json`.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Ejecute el siguiente comando CLI de SAM para probar localmente su función lambda, pasando el parámetro apropiado de SAM `template`. El parámetro `event` toma cualquier archivo JSON, en este caso el ejemplo `payload.json`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The native image can also be locally tested using the `sam.native.yaml` template:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>La imagen nativa también puede probarse localmente utilizando la plantilla `sam.native.yaml`:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The are times where you may have to add some additions to the `function.zip` lambda deployment that is generated by the build.  To do this create a `zip.jvm` or `zip.native` directory within `src/main`.  Create `zip.jvm/` if you are doing a pure Java lambda.  `zip.native/` if you are doing a native deployment.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Hay veces en las que puedes tener que añadir algunas adiciones al despliegue de lambda `function.zip` que es generado por la construcción. Para ello crea un directorio `zip.jvm` o `zip.native` dentro de `src/main`. Crea `zip.jvm/` si estás haciendo una lambda puramente Java. `zip.native/` si estás haciendo un despliegue nativo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are times you may want to set a specific system properties or other arguments when lambda invokes your native quarkus lambda deployment.  If you include a `bootstrap` script file within `zip.native`, the quarkus extension will automatically rename the executable to `runner` within `function.zip` and set the unix mode of the `bootstrap` script to executable.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Hay veces que puedes querer establecer unas propiedades específicas del sistema u otros argumentos cuando lambda invoca tu despliegue lambda nativo de quarkus. Si incluyes un archivo de script `bootstrap` dentro de `zip.native`, la extensión quarkus renombrará automáticamente el ejecutable a `runner` dentro de `function.zip` y establecerá el modo unix del script `bootstrap` a ejecutable.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The native executable must be referenced as `runner` if you include a custom `bootstrap` script.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>El ejecutable nativo debe ser referenciado como `runner` si incluye un script personalizado de `bootstrap`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In addition, remember to enable the AWS X-Ray tracing parameter in `manage.sh`, in the `cmd_create()` function.  This can also be set in the AWS Management Console.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Además, recuerde habilitar el parámetro de rastreo de AWS X-Ray en `manage.sh`, en la función `cmd_create()`. Esto también se puede configurar en la consola de administración de AWS.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>AWS X-Ray does add many classes to your distribution, do ensure you are using at least the 256MB AWS Lambda memory size.  This is explicitly set in `manage.sh` `cmd_create()`. Whilst the native image potentially can always use a lower memory setting, it would be recommended to keep the setting the same, especially to help compare performance.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>AWS X-Ray añade muchas clases a su distribución, asegúrese de que está utilizando al menos el tamaño de memoria de 256 MB de AWS Lambda. Esto se establece explícitamente en `manage.sh` `cmd_create()` . Aunque la imagen nativa siempre puede utilizar una configuración de memoria más baja, se recomienda mantener la misma configuración, especialmente para ayudar a comparar el rendimiento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Add `quarkus-jaxb` as a dependency in your Maven `pom.xml`, or Gradle `build.gradle` file.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Añade `quarkus-jaxb` como dependencia en tu archivo Maven `pom.xml`, o Gradle `build.gradle`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To do this, first create a directory `src/main/zip.native/` with your build.  Next create a shell script file called `bootstrap` within `src/main/zip.native/`, like below. An example is create automatically in your build folder (target or build), called `bootstrap-example.sh`</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Para ello, primero cree un directorio `src/main/zip.native/` con su construcción. A continuación, cree un archivo de secuencia de comandos llamado `bootstrap` dentro de `src/main/zip.native/`, como se indica a continuación. Un ejemplo es crear automáticamente en su carpeta de construcción (target o build), llamado `bootstrap-example.sh`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Second, cacerts, the certificate store.  You may need to periodically obtain an updated copy, also.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>En segundo lugar, cacerts, el almacén de certificados. Es posible que tenga que obtener periódicamente una copia actualizada, también.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are 2 `@Blocking` annotations:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Hay 2 anotaciones en `@Blocking`:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.smallrye.reactive.messaging.annotations.Blocking`</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>`io.smallrye.reactive.messaging.annotations.Blocking`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.smallrye.common.annotation.Blocking`</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>`io.smallrye.common.annotation.Blocking`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the `quarkus-apicurio-registry-avro` extension is present, Dev Services for Apicurio Registry automatically starts an Apicurio Registry instance in dev mode and when running tests.  Also, all Kafka channels in SmallRye Reactive Messaging are automatically configured to use this registry.  (This automatic configuration of course only applies to serializers and deserializers from the Apicurio Registry Avro library.)</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Si la extensión `quarkus-apicurio-registry-avro` está presente, Dev Services for Apicurio Registry inicia automáticamente una instancia de Apicurio Registry en modo dev y al ejecutar pruebas. Además, todos los canales Kafka en SmallRye Reactive Messaging se configuran automáticamente para utilizar este registro. (Esta configuración automática, por supuesto, sólo se aplica a los serializadores y deserializadores de la biblioteca Avro de Apicurio Registry).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Enabling / Disabling Dev Services for Apicurio Registry</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Activación/desactivación de los servicios de desarrollo para el registro de Apicurio</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev Services for Apicurio Registry relies on Docker to start the registry.  If your environment does not support Docker, you will need to start the registry manually, or use an already running registry.  You can configure the registry URL for all Kafka channels in SmallRye Reactive Messaging with a single property:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Dev Services for Apicurio Registry se basa en Docker para iniciar el registro. Si su entorno no soporta Docker, tendrá que iniciar el registro manualmente, o utilizar un registro ya en funcionamiento. Puede configurar la URL del registro para todos los canales Kafka en SmallRye Reactive Messaging con una sola propiedad:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Most of the time you need to share the registry between applications.  Dev Services for Apicurio Registry implements a _service discovery_ mechanism for your multiple Quarkus applications running in _dev_ mode to share a single registry.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>La mayoría de las veces se necesita compartir el registro entre aplicaciones. Dev Services for Apicurio Registry implementa un mecanismo de _descubrimiento de servicios_ para que sus múltiples aplicaciones Quarkus que se ejecutan en modo _dev_ compartan un único registro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need multiple (shared) registries, you can configure the `quarkus.apicurio-registry.devservices.service-name` attribute and indicate the registry name.  It looks for a container with the same value, or starts a new one if none can be found.  The default service name is `apicurio-registry`.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Si necesitas varios registros (compartidos), puedes configurar el atributo `quarkus.apicurio-registry.devservices.service-name` e indicar el nombre del registro. Se busca un contenedor con el mismo valor, o se inicia uno nuevo si no se encuentra ninguno. El nombre de servicio por defecto es `apicurio-registry`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sharing is enabled by default in dev mode, but disabled in test mode.  You can disable the sharing with `quarkus.apicurio-registry.devservices.shared=false`.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>El uso compartido está activado por defecto en el modo de desarrollo, pero está desactivada en el modo de prueba. Puede desactivar el uso compartido con `quarkus.apicurio-registry.devservices.shared=false`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, Dev Services for Apicurio Registry picks a random port and configures the application.  You can set the port by configuring the `quarkus.apicurio-registry.devservices.port` property.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Por defecto, Dev Services for Apicurio Registry escoge un puerto al azar y configura la aplicación. Puede establecer el puerto configurando la propiedad `quarkus.apicurio-registry.devservices.port`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev Services for Apicurio Registry uses `apicurio/apicurio-registry-mem` images.  You can select any 2.x version from https://hub.docker.com/r/apicurio/apicurio-registry-mem:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Los servicios de desarrollo para el Registro de Apicurio utilizan imágenes de `apicurio/apicurio-registry-mem`. Puede seleccionar cualquier versión 2.x de https://hub.docker.com/r/apicurio/apicurio-registry-mem:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can deploy your Lambda as a pure Java jar, or you can compile your project to a native image and deploy that for a smaller memory footprint and startup time.  Our integration also generates SAM deployment files that can be consumed by https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/what-is-sam.html[Amazon's SAM framework].</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Puede desplegar su Lambda como una jar de Java, o puede compilar su proyecto en una imagen nativa y desplegarla para obtener una menor huella de memoria y tiempo de inicio. Nuestra integración también genera archivos de despliegue SAM que pueden ser consumidos por https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/what-is-sam.html[el framework SAM de Amazon].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus has a different extension for each Gateway API.  The HTTP Gateway API is implemented within the `quarkus-amazon-lambda-http` extension.  The REST Gateway API is implemented within the `quarkus-amazon-lambda-rest` extension.  If you are confused on which Gateway product to use, Amazon has a https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-vs-rest.html[great guide] to help you navigate this decision.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Quarkus tiene una extensión diferente para cada API de Gateway. La API HTTP Gateway se implementa dentro de la extensión `quarkus-amazon-lambda-http`. La API REST Gateway se implementa dentro de la extensión `quarkus-amazon-lambda-rest`. Si estás confundido sobre qué producto Gateway utilizar, Amazon tiene una https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-vs-rest.html[excelente guía] para ayudarte a tomar esta decisión.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide walks you through generating an example Java project via a Maven archetype.  Later on it walks through the structure of the project so you can adapt any existing projects you have to use Amazon Lambda.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Esta guía le acompaña a través de la generación de un proyecto Java de ejemplo a través de un arquetipo de Maven. Más adelante, le guiará por la estructura del proyecto para que pueda adaptar cualquier proyecto existente que tenga para utilizar Amazon Lambda.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will compile the code and run the unit tests included within the generated project.  Unit testing is the same as any other Java project and does not require running on Amazon.  Quarkus dev mode is also available with this extension.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Esto compilará el código y ejecutará las pruebas unitarias incluidas en el proyecto generado. Las pruebas unitarias son las mismas que en cualquier otro proyecto Java y no requieren ser ejecutadas en Amazon. El modo Quarkus dev también está disponible con esta extensión.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>After you run the build, there are a few extra files generated by the Quarkus lambda extension you are using.  These files are in the the build directory: `target/` for Maven, `build/` for Gradle.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Después de ejecutar la construcción, hay algunos archivos adicionales generados por la extensión lambda de Quarkus que estás utilizando. Estos archivos están en el directorio de construcción: `target/` para Maven, `build/` para Gradle.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The AWS SAM CLI allows you to run your lambda's locally on your laptop in a simulated Lambda environment.  This requires Docker to be installed.  After you have built your Maven project, execute this command:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>La CLI de AWS SAM le permite ejecutar sus lambdas localmente en su portátil en un entorno de lambda simulado. Esto requiere que Docker esté instalado. Después de haber construido su proyecto Maven, ejecute este comando:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Answer all the questions and your lambda will be deployed and the necessary hooks to the API Gateway will be set up. If everything deploys successfully, the root URL of your microservice will be output to the console.  Something like this:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Responde a todas las preguntas y tu lambda se desplegará y se configurarán los hooks necesarios para el API Gateway. Si todo se despliega con éxito, la URL raíz de tu microservicio se mostrará en la consola. Algo así:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is nothing special about the POM other than the inclusion of the `quarkus-amazon-lambda-http` extension (if you are deploying an AWS Gateway HTTP API) or the `quarkus-amazon-lambda-rest` extension (if you are deploy an AWS Gateway REST API).  These extensions automatically generate everything you might need for your lambda deployment.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>No hay nada especial en el POM aparte de la inclusión de la extensión `quarkus-amazon-lambda-http` (si está implementando una API HTTP de AWS Gateway) o la extensión `quarkus-amazon-lambda-rest` (si está implementando una API REST de AWS Gateway). Estas extensiones generan automáticamente todo lo que pueda necesitar para su implementación de Lambda.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `sam.yaml` syntax is beyond the scope of this document.  There's a couple of things that must be highlighted just in case you are going to craft your own custom `sam.yaml` deployment files.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>La sintaxis de `sam.yaml` está fuera del alcance de este documento. Hay un par de cosas que hay que resaltar en caso de que vayas a elaborar tus propios archivos de despliegue personalizados de `sam.yaml`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The first thing to note is that for pure Java lambda deployments require a specific handler class.  Do not change the Lambda handler name.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Lo primero que hay que tener en cuenta es que para las implantaciones de lambda en Java puro se requiere una clase manejadora específica. No cambie el nombre del manejador Lambda.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to go native, there's an environment variable that must be set for native GraalVM deployments.  If you look at `sam.native.yaml` you'll see this:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Si quieres ir de forma nativa, hay una variable de entorno que se debe establecer para los despliegues nativos de GraalVM. Si miras en `sam.native.yaml` verás esto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, there is one specific thing for AWS Gateway REST API deployments.  That API assumes that HTTP response bodies are text unless you explicitly tell it which media types are binary through configuration.  To make things easier, the Quarkus extension forces a binary (base 64) encoding of all HTTP response messages and the `sam.yaml` file must configure the API Gateway to assume all media types are binary:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Por último, hay una cosa específica para las implementaciones de la API REST de AWS Gateway. Esa API asume que los cuerpos de las respuestas HTTP son texto, a menos que se le indique explícitamente qué tipos de medios son binarios mediante la configuración. Para facilitar las cosas, la extensión de Quarkus fuerza una codificación binaria (base 64) de todos los mensajes de respuesta HTTP y el archivo `sam.yaml` debe configurar la API Gateway para asumir que todos los tipos de medios son binarios:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For the AWS HTTP API you can inject the AWS variables `com.amazonaws.services.lambda.runtime.Context` and `com.amazonaws.services.lambda.runtime.events.APIGatewayV2HTTPEvent`.  Here is an example:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Para la API HTTP de AWS puedes inyectar las variables de AWS `com.amazonaws.services.lambda.runtime.Context` y `com.amazonaws.services.lambda.runtime.events.APIGatewayV2HTTPEvent`. Aquí tienes un ejemplo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For the AWS REST API you can inject the AWS variables `com.amazonaws.services.lambda.runtime.Context` and `io.quarkus.amazon.lambda.http.model.AwsProxyRequestContext`.  Here is an example:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Para la API de AWS REST puedes inyectar las variables de AWS `com.amazonaws.services.lambda.runtime.Context` y `io.quarkus.amazon.lambda.http.model.AwsProxyRequestContext`. Aquí tienes un ejemplo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To enable this security feature, add this to your `application.properties` file:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Para activar esta función de seguridad, añada esto a su archivo `application.properties`:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>HTTP `quarkus-amazon-lambda-http`</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>HTTP `quarkus-amazon-lambda-http`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Cognito JWT</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Cognito JWT</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkus.amazon.lambda.http.CognitoPrincipal`</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>`io.quarkus.amazon.lambda.http.CognitoPrincipal`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`requestContext.authorizer.jwt.claims.cognito:username`</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>`requestContext.authorizer.jwt.claims.cognito:username`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkus.amazon.lambda.http.IAMPrincipal`</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>`io.quarkus.amazon.lambda.http.IAMPrincipal`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`requestContext.authorizer.iam.userId`</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>`requestContext.authorizer.iam.userId`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkus.amazon.lambda.http.CustomPrincipal`</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>`io.quarkus.amazon.lambda.http.CustomPrincipal`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`requestContext.authorizer.lambda.principalId`</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>`requestContext.authorizer.lambda.principalId`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>REST `quarkus-amazon-lambda-rest`</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>REST `quarkus-amazon-lambda-rest`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Cognito</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Cognito</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`requestContext.authorizer.claims.cognito:username`</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>`requestContext.authorizer.claims.cognito:username`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`requestContext.identity.user`</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>`requestContext.identity.user`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`requestContext.authorizer.principalId`</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>`requestContext.authorizer.principalId`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The default support for AWS security only maps the principal name to Quarkus security APIs and does nothing to map claims or roles or permissions.  You have can full control how security metadata in the lambda HTTP event is mapped to Quarkus security APIs using implementations of the `io.quarkus.amazon.lambda.http.LambdaIdentityProvider` interface.  By implementing this interface, you can do things like define role mappings for your principal or publish additional attributes provided by IAM or Cognito or your Custom Lambda security integration.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>El soporte por defecto para la seguridad de AWS sólo asigna el nombre principal a las API de seguridad de Quarkus y no hace nada para asignar reclamaciones, funciones o permisos. Usted puede controlar completamente cómo se asignan los metadatos de seguridad en el evento HTTP lambda a las API de seguridad de Quarkus utilizando implementaciones de la interfaz `io.quarkus.amazon.lambda.http.LambdaIdentityProvider`. Al implementar esta interfaz, puede hacer cosas como definir asignaciones de roles para su director o publicar atributos adicionales proporcionados por IAM o Cognito o su integración de seguridad Lambda personalizada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For HTTP, the important method to override is `LambdaIdentityProvider.authenticate(APIGatewayV2HTTPEvent event)`.  From this you will allocate a SecurityIdentity based on how you want to map security data from `APIGatewayV2HTTPEvent`</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>En el caso de HTTP, el método importante a anular es `LambdaIdentityProvider.authenticate(APIGatewayV2HTTPEvent event)`. A partir de él, asignarás una SecurityIdentity basada en cómo quieres asignar los datos de seguridad de `APIGatewayV2HTTPEvent`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For REST, the important method to override is `LambdaIdentityProvider.authenticate(AwsProxyRequest event)`.  From this you will allocate a SecurityIdentity based on how you want to map security data from `AwsProxyRequest`.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Para REST, el método importante que hay que anular es `LambdaIdentityProvider.authenticate(AwsProxyRequest event)`. A partir de esto, asignarás una SecurityIdentity basada en cómo quieres asignar los datos de seguridad de `AwsProxyRequest`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Your implemented provider must be a CDI bean.  Here's an example:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Su proveedor implementado debe ser un bean CDI. He aquí un ejemplo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Simple SAM Local Principal</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Simple SAM Local Principal</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are testing your application with `sam local` you can hardcode a principal name to use when your application runs by setting the `QUARKUS_AWS_LAMBDA_FORCE_USER_NAME` environment variable</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Si está probando su aplicación con `sam local`, puede codificar un nombre principal para utilizarlo cuando se ejecute su aplicación, estableciendo la variable de entorno `QUARKUS_AWS_LAMBDA_FORCE_USER_NAME`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the `quarkus-app` directory which contains the `quarkus-run.jar` jar file - being an executable _jar_. Be aware that it's not an _über-jar_ as the dependencies are copied into subdirectories of `quarkus-app/lib/`.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>el directorio `quarkus-app` que contiene el archivo jar `quarkus-run.jar` - siendo un _jar_ ejecutable. Tenga en cuenta que no es un _über-jar_ ya que las dependencias se copian en subdirectorios de `quarkus-app/lib/`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to deploy your application somewhere (typically in a container), you need to deploy the whole `quarkus-app` directory.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Si quieres desplegar tu aplicación en algún lugar (normalmente en un contenedor), necesitas desplegar todo el directorio `quarkus-app`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide is the companion from the xref:amqp.adoc[Getting Started with AMQP 1.0].  It explains in more details the configuration and usage of the AMQP connector for reactive messaging.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Esta guía es el complemento de la guía xref:amqp.html[Introducción a AMQP 1.0]. En ella se explica con más detalle la configuración y el uso del conector AMQP para la mensajería reactiva.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This documentation does not cover all the details of the connector.  Refer to the https://smallrye.io/smallrye-reactive-messaging[SmallRye Reactive Messaging website] for further details.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Esta documentación no cubre todos los detalles del conector. Consulte el https://smallrye.io/smallrye-reactive-messaging[sitio web de SmallRye Reactive Messaging] para obtener más detalles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The AMQP connector allows Quarkus applications to send and receive messages using the AMQP 1.0 protocol.  More details about the protocol can be found in http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-overview-v1.0-os.html[the AMQP 1.0 specification].  It's important to note that AMQP 1.0 and AMQP 0.9.1 (implemented by RabbitMQ) are incompatible.  Check &lt;&lt;using-rabbitmq,Using RabbitMQ&gt;&gt; to get more details.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>El conector AMQP permite a las aplicaciones de Quarkus enviar y recibir mensajes utilizando el protocolo AMQP 1.0. Se pueden encontrar más detalles sobre el protocolo en http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-overview-v1.0-os.html[la especificación AMQP 1.0]. Es importante tener en cuenta que AMQP 1.0 y AMQP 0.9.1 (implementado por RabbitMQ) son incompatibles. Consulta &lt;&lt;using-rabbitmq,Usando RabbitMQ&gt;&gt; para obtener más detalles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To use the connector, you need to add the `quarkus-smallrye-reactive-messaging-amqp` extension.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Para utilizar el conector, es necesario añadir la extensión `quarkus-smallrye-reactive-messaging-amqp`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once added to your project, you can map _channels_ to AMQP addresses by configuring the `connector` attribute:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Una vez añadido a tu proyecto, puedes asignar _canales_ a direcciones AMQP configurando el atributo `connector`:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The AMQP connector connects to AMQP 1.0 brokers such as Apache ActiveMQ or Artemis.  To configure the location and credentials of the broker, add the following properties in the `application.properties`:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>El conector AMQP se conecta a brokers AMQP 1.0 como Apache ActiveMQ o Artemis. Para configurar la ubicación y las credenciales del broker, añada las siguientes propiedades en la página `application.properties`:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's imagine your application receives `Message&lt;Double&gt;`.  You can consume the payload directly:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Imaginemos que tu aplicación recibe `Message&lt;Double&gt;`. Puede consumir la carga útil directamente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The connector converts incoming AMQP Messages into Reactive Messaging `Message&lt;T&gt;` instances.  `T` depends on the _body_ of the received AMQP Message.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>El conector convierte los mensajes AMQP entrantes en instancias de Reactive Messaging `Message&lt;T&gt;. `T` depende del _cuerpo_ del mensaje AMQP recibido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`List`</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>`List`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://vertx.io/docs/apidocs/io/vertx/core/json/JsonObject.html[`JsonObject`]</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>https://vertx.io/docs/apidocs/io/vertx/core/json/JsonObject.html[`JsonObject`]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you send objects with this AMQP connector (outbound connector), it gets encoded as JSON and sent as binary.  The `content-type` is set to `application/json`.  So, you can rebuild the object as follows:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Si envías objetos con este conector AMQP (conector de salida), se codifica como JSON y se envía como binario. La dirección `content-type` está configurada como `application/json`. Por lo tanto, puede reconstruir el objeto de la siguiente manera:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If a message produced from an AMQP message is _nacked_, a failure strategy is applied.  The AMQP connector supports six strategies:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Si un mensaje producido a partir de un mensaje AMQP es _nacked_, se aplica una estrategia de fallo. El conector AMQP soporta seis estrategias:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`fail` - fail the application; no more AMQP messages will be processed (default).  The AMQP message is marked as rejected.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>`fail` - falla la aplicación; no se procesarán más mensajes AMQP (por defecto). El mensaje AMQP se marca como rechazado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`accept` - this strategy marks the AMQP message as _accepted_. The processing continues ignoring the failure.  Refer to the http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-messaging-v1.0-os.html#type-accepted[accepted delivery state documentation].</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>`accept` - esta estrategia marca el mensaje AMQP como _aceptado_. El procesamiento continúa ignorando el fallo. Consulte la http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-messaging-v1.0-os.html#type-accepted[documentación sobre el estado de entrega] aceptado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`release` - this strategy marks the AMQP message as _released_. The processing continues with the next message. The broker can redeliver the message.  Refer to the http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-messaging-v1.0-os.html#type-released[released delivery state documentation].</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>`release` - esta estrategia marca el mensaje AMQP como _liberado_. El procesamiento continúa con el siguiente mensaje. El broker puede volver a entregar el mensaje. Consulte la http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-messaging-v1.0-os.html#type-released[documentación del estado de entrega liber]ado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`reject` - this strategy marks the AMQP message as rejected. The processing continues with the next message.  Refer to the http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-messaging-v1.0-os.html#type-rejected[rejected delivery state documentation].</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>`reject` - esta estrategia marca el mensaje AMQP como rechazado. El procesamiento continúa con el siguiente mensaje. Consulte la http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-messaging-v1.0-os.html#type-rejected[documentación del estado de entrega rechaz]ado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`modified-failed` - this strategy marks the AMQP message as _modified_ and indicates that it failed (with the `delivery-failed` attribute). The processing continues with the next message, but the broker may attempt to redeliver the message.  Refer to the http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-messaging-v1.0-os.html#type-modified[modified delivery state documentation]</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>`modified-failed` - esta estrategia marca el mensaje AMQP como _modificado_ e indica que ha fallado (con el atributo `delivery-failed` ). El procesamiento continúa con el siguiente mensaje, pero el broker puede intentar volver a entregar el mensaje. Consulte la http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-messaging-v1.0-os.html#type-modified[documentación sobre el estado de entrega modificado]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`modified-failed-undeliverable-here` - this strategy marks the AMQP message as _modified_ and indicates that it failed (with the `delivery-failed` attribute). It also indicates that the application cannot process the message, meaning that the broker will not attempt to redeliver the message to this node. The processing continues with the next message.  Refer to the http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-messaging-v1.0-os.html#type-modified[modified delivery state documentation]</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>`modified-failed-undeliverable-here` - esta estrategia marca el mensaje AMQP como _modificado_ e indica que ha fallado (con el atributo `delivery-failed` ). También indica que la aplicación no puede procesar el mensaje, lo que significa que el broker no intentará volver a entregar el mensaje a este nodo. El procesamiento continúa con el siguiente mensaje. Consulte la http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-messaging-v1.0-os.html#type-modified[documentación sobre el estado de entrega modificado]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When sending a `Message&lt;T&gt;`, the connector converts the message into an AMQP Message.  The payload is converted to the AMQP Message _body_.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Cuando se envía un `Message&lt;T&gt;`, el conector convierte el mensaje en un mensaje AMQP. La carga útil se convierte en el _cuerpo_ del mensaje AMQP.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://vertx.io/docs/apidocs/io/vertx/core/json/JsonObject.html[`JsonObject`] or https://vertx.io/docs/apidocs/io/vertx/core/json/JsonArray.html[`JsonArray`]</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>https://vertx.io/docs/apidocs/io/vertx/core/json/JsonObject.html[`JsonObject`] o  link:https://vertx.io/docs/apidocs/io/vertx/core/json/JsonArray.html[`JsonArray`]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.vertx.mutiny.core.buffer.Buffer`</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>`io.vertx.mutiny.core.buffer.Buffer`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When sending `Messages`, you can add an instance of `OutgoingAmqpMetadata` to influence how the message is going to be sent to AMQP.  For example, you can configure the subjects, properties:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Cuando se envía `Messages`, se puede añadir una instancia de `OutgoingAmqpMetadata` para influir en cómo se va a enviar el mensaje a AMQP. Por ejemplo, puedes configurar los asuntos, las propiedades:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sometimes it is desirable to select the destination of a message dynamically.  In this case, you should not configure the address inside your application configuration file, but instead, use the outbound metadata to set the address.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>A veces es conveniente seleccionar el destino de un mensaje de forma dinámica. En este caso, no debe configurar la dirección dentro del archivo de configuración de su aplicación, sino que debe utilizar los metadatos de salida para establecer la dirección.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, the Reactive Messaging `Message` is acknowledged when the broker acknowledged the message.  When using routers, this acknowledgement may not be enabled.  In this case, configure the `auto-acknowledgement` attribute to acknowledge the message as soon as it has been sent to the router.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Por defecto, la Mensajería Reactiva `Message` es reconocida cuando el broker reconoce el mensaje. Cuando se utilizan routers, este acuse de recibo puede no estar habilitado. En este caso, configure el atributo `auto-acknowledgement` para que acuse el mensaje tan pronto como se haya enviado al router.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The back-pressure is handled by AMQP _credits_.  The outbound connector only requests the amount of allowed credits.  When the amount of credits reaches 0, it waits (in a non-blocking fashion) until the broker grants more credits to the AMQP sender.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>La contrapresión se gestiona mediante _créditos_ AMQP. El conector de salida sólo solicita la cantidad de créditos permitidos. Cuando la cantidad de créditos llega a 0, espera (de forma no bloqueante) hasta que el broker conceda más créditos al emisor AMQP.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can configure the AMQP address using the `address` attribute:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Puedes configurar la dirección AMQP utilizando el atributo `address`:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To use an existing queue, you need to configure the `address`, `container-id` and, optionally, the `link-name` attributes.  For example, if you have an Apache Artemis broker configured with:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Para utilizar una cola existente, debe configurar los atributos `address`, `container-id` y, opcionalmente, `link-name`. Por ejemplo, si tienes un broker Apache Artemis configurado con:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You may need to configure the `link-name` attribute, if the queue name is not the channel name:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Es posible que tenga que configurar el atributo `link-name`, si el nombre de la cola no es el nombre del canal:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To use a `MULTICAST` queue, you need to provide the _FQQN_ (fully-qualified queue name) instead of just the name of the queue:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Para utilizar una cola de `MULTICAST`, es necesario proporcionar el _FQQN_ (nombre de cola totalmente calificado) en lugar de sólo el nombre de la cola:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reactive Messaging invokes your method on an I/O thread.  See the xref:quarkus-reactive-architecture.adoc[Quarkus Reactive Architecture documentation] for further details on this topic.  But, you often need to combine Reactive Messaging with blocking processing such as database interactions.  For this, you need to use the `@Blocking` annotation indicating that the processing is _blocking_ and should not be run on the caller thread.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>La mensajería reactiva invoca su método en un hilo de E/S. Consulta la xref:quarkus-reactive-architecture.html[documentación de la Arquitectura Reactiva de Quarkus] para más detalles sobre este tema. Pero, a menudo necesitas combinar la Mensajería Reactiva con el procesamiento de bloqueo, como las interacciones con la base de datos. Para ello, es necesario utilizar la anotación `@Blocking` indicando que el procesamiento es _de_ bloqueo y no debe ser ejecutado en el hilo de llamada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>They have the same effect.  Thus, you can use both.  The first one provides more fine-grained tuning such as the worker pool to use and whether it preserves the order.  The second one, used also with other reactive features of Quarkus, uses the default worker pool and preserves the order.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Tienen el mismo efecto. Por lo tanto, puede utilizar ambos. El primero proporciona un ajuste más fino, como el grupo de trabajadores a utilizar y si preserva el orden. El segundo, utilizado también con otras características reactivas de Quarkus, utiliza el grupo de trabajadores por defecto y preserva el orden.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The connector uses the Vert.x AMQP client underneath.  More details about this client can be found in the https://vertx.io/docs/vertx-amqp-client/java/[Vert.x website].</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>El conector utiliza el cliente AMQP de Vert.x por debajo. Puedes encontrar más detalles sobre este cliente en el https://vertx.io/docs/vertx-amqp-client/java/[sitio web de Vert.x].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This instance is retrieved and used to configure the client used by the connector.  You need to indicate the name of the client using the `client-options-name` attribute:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Esta instancia se recupera y se utiliza para configurar el cliente utilizado por el conector. Es necesario indicar el nombre del cliente utilizando el atributo `client-options-name`:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you use the AMQP connector with the `quarkus-smallrye-health` extension, it contributes to the readiness and liveness probes.  The AMQP connector reports the readiness and liveness of each channel managed by the connector.  At the moment, the AMQP connector uses the same logic for the readiness and liveness checks.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Si utilizas el conector AMQP con la extensión `quarkus-smallrye-health`, contribuye a las sondas de disponibilidad y vida. El conector AMQP informa de la disponibilidad y la capacidad de respuesta de cada canal gestionado por el conector. Por el momento, el conector AMQP utiliza la misma lógica para las comprobaciones de disponibilidad y vida.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To disable health reporting, set the `health-enabled` attribute for the channel to false.  On the inbound side (receiving messages from AMQP), the check verifies that the receiver is attached to the broker.  On the outbound side (sending records to AMQP), the check verifies that the sender is attached to the broker.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Para desactivar los informes de salud, establezca el atributo `health-enabled` para el canal en falso. En el lado de entrada (recepción de mensajes de AMQP), la comprobación verifica que el receptor está unido al broker. En el lado de salida (envío de registros a AMQP), la comprobación verifica que el remitente está unido al broker.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that a message processing failures nacks the message, which is then handled by the `failure-strategy`.  It the responsibility of the `failure-strategy` to report the failure and influence the outcome of the checks.  The `fail` failure strategy reports the failure, and so the check will report the fault.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Obsérvese que un fallo en el procesamiento de mensajes lo anula, lo cual es tratado por `failure-strategy`. Es responsabilidad de `failure-strategy` informar del fallo e influir en el resultado de las comprobaciones. La estrategia de fallos de `fail` informa del fallo, por lo que la comprobación informará del mismo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This connector is for AMQP 1.0. RabbitMQ implements AMQP 0.9.1.  RabbitMQ does not provide AMQP 1.0 by default, but there is a plugin for it.  To use RabbitMQ with this connector, enable and configure the AMQP 1.0 plugin.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Este conector es para AMQP 1.0. RabbitMQ implementa AMQP 0.9.1. RabbitMQ no proporciona AMQP 1.0 por defecto, pero existe un plugin para ello. Para utilizar RabbitMQ con este conector, active y configure el plugin AMQP 1.0.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Despite the existence of the plugin, a few AMQP 1.0 features won’t work with RabbitMQ.  Thus, we recommend the following configurations.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>A pesar de la existencia del plugin, algunas características de AMQP 1.0 no funcionan con RabbitMQ. Por lo tanto, recomendamos las siguientes configuraciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus specific configuration</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Configuración específica de Quarkus</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`fail`</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>`fail`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We recommend that you follow the instructions in the next sections and create applications step by step.  However, you can go right to the completed example.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Le recomendamos que siga las instrucciones de las siguientes secciones y cree las aplicaciones paso a paso. Sin embargo, puede ir directamente al ejemplo completado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To create the _producer_ project, in a terminal run:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Para crear el proyecto _productor_, en un terminal ejecute:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To create the _processor_ project, from the same directory, run:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Para crear el proyecto del _procesador_, desde el mismo directorio, ejecute:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inject a Reactive Messaging `Emitter` to send messages to the `quote-requests` channel.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Inyectar una Mensajería Reactiva `Emitter` para enviar mensajes al canal `quote-requests`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev Services for AMQP automatically starts an AMQP 1.0 broker in dev mode and when running tests.  So, you don't have to start a broker manually.  The application is configured automatically.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Dev Services for AMQP inicia automáticamente un broker AMQP 1.0 en modo dev y cuando se ejecutan pruebas. Por lo tanto, no tienes que iniciar un broker manualmente. La aplicación se configura automáticamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Enabling / Disabling Dev Services for AMQP</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Activación/desactivación de los servicios de desarrollo para AMQP</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev Services for AMQP relies on Docker to start the broker.  If your environment does not support Docker, you will need to start the broker manually, or connect to an already running broker.  You can configure the broker access using the `amqp-host`, `amqp-port`, `amqp-user` and `amqp-password` properties.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Dev Services for AMQP se basa en Docker para iniciar el broker. Si tu entorno no soporta Docker, tendrás que iniciar el broker manualmente, o conectarte a un broker ya en funcionamiento. Puede configurar el acceso al broker utilizando las propiedades `amqp-host`, `amqp-port`, `amqp-user` y `amqp-password`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Most of the time you need to share the broker between applications.  Dev Services for AMQP implements a _service discovery_ mechanism for your multiple Quarkus applications running in _dev_ mode to share a single broker.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>La mayoría de las veces se necesita compartir el broker entre aplicaciones. Dev Services for AMQP implementa un mecanismo de _descubrimiento de servicios_ para que sus múltiples aplicaciones Quarkus que se ejecutan en modo _dev_ compartan un único broker.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need multiple (shared) brokers, you can configure the `quarkus.amqp.devservices.service-name` attribute and indicate the broker name.  It looks for a container with the same value, or starts a new one if none can be found.  The default service name is `amqp`.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Si necesitas varios brokers (compartidos), puedes configurar el atributo `quarkus.amqp.devservices.service-name` e indicar el nombre del broker. Se busca un contenedor con el mismo valor, o se inicia uno nuevo si no se encuentra ninguno. El nombre de servicio por defecto es `amqp`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sharing is enabled by default in dev mode, but disabled in test mode.  You can disable the sharing with `quarkus.amqp.devservices.shared=false`.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>El uso compartido está activado por defecto en el modo de desarrollo, pero está desactivada en el modo de prueba. Puede desactivar el uso compartido con `quarkus.amqp.devservices.shared=false`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, Dev Services for AMQP picks a random port and configures the application.  You can set the port by configuring the `quarkus.amqp.devservices.port` property.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Por defecto, Dev Services for AMQP elige un puerto aleatorio y configura la aplicación. Puedes establecer el puerto configurando la propiedad `quarkus.amqp.devservices.port`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev Services for AMQP uses https://quay.io/repository/artemiscloud/activemq-artemis-broker[activemq-artemis-broker] images.  You can configure the image and version using the `quarkus.amqp.devservices.image-name` property:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Dev Services for AMQP utiliza imágenes https://quay.io/repository/artemiscloud/activemq-artemis-broker[activemq-artemis-broker]. Puedes configurar la imagen y la versión utilizando la propiedad `quarkus.amqp.devservices.image-name`:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we are going to develop two applications communicating with an AMQP broker.  We will use https://activemq.apache.org/components/artemis/[Artemis], but you can use any AMQP 1.0 broker.  The first application sends a _quote request_ to an AMQP queue and consumes messages from the _quote_ queue.  The second application receives the _quote request_ and sends a _quote_ back.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>En esta guía, vamos a desarrollar dos aplicaciones que se comunican con un broker AMQP. Usaremos https://activemq.apache.org/components/artemis/[Artemis], pero puedes usar cualquier broker AMQP 1.0. La primera aplicación envía una solicitud _de_ cotización a una cola AMQP y consume mensajes de la cola de _cotización_. La segunda aplicación recibe la solicitud de _cotización_ y envía una _cotización_ de vuelta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The first application, the `producer`, will let the user request some quotes over an HTTP endpoint.  For each quote request, a random identifier is generated and returned to the user, to put the quote request on _pending_.  At the same time the generated request id is sent over the `quote-requests` queue.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>La primera aplicación, la `producer`, permitirá al usuario solicitar algunas cotizaciones a través de un endpoint HTTP. Para cada solicitud de cotización, se genera un identificador aleatorio que se devuelve al usuario, para poner la solicitud de cotización en _espera_. Al mismo tiempo, el identificador de solicitud generado se envía a través de la cola de `quote-requests`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Lastly, the `producer` will read the quotes and send them to the browser using server-sent events.  The user will therefore see the quote price updated from _pending_ to the received price in real-time.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Por último, `producer` leerá las cotizaciones y las enviará al navegador mediante eventos enviados por el servidor. Así, el usuario verá cómo se actualiza el precio de la cotización desde el _pendiente_ hasta el recibido en tiempo real.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `Quote` class will be used in both `producer` and `processor` projects.  For the sake of simplicity we will duplicate the class.  In both projects, create the `src/main/java/org/acme/amqp/model/Quote.java` file, with the following content:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>La clase `Quote` se utilizará en los proyectos `producer` y `processor`. Para simplificar, duplicaremos la clase. En ambos proyectos, cree el archivo `src/main/java/org/acme/amqp/model/Quote.java`, con el siguiente contenido:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@RegisterForReflection</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>@RegisterForReflection</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `@RegisterForReflection` annotation instructs Quarkus to include the class (including fields and methods) when building the native executable.  This will be useful later when we run the applications as native executables inside containers.  Without, the native compilation would remove the fields and methods during the dead-code elimination phase.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>La anotación `@RegisterForReflection` indica a Quarkus que incluya la clase (incluyendo los campos y métodos) cuando construya el ejecutable nativo. Esto será útil más adelante cuando ejecutemos las aplicaciones como ejecutables nativos dentro de contenedores. Sin ella, la compilación nativa eliminaría los campos y métodos durante la fase de eliminación del código muerto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inside the `producer` project locate the generated `src/main/java/org/acme/amqp/producer/QuotesResource.java` file, and update the content to be:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Dentro del proyecto `producer` localice el archivo generado `src/main/java/org/acme/amqp/producer/QuotesResource.java`, y actualice el contenido para que sea:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now let's consume the quote request and give out a price.  Inside the `processor` project, locate the `src/main/java/org/acme/amqp/processor/QuoteProcessor.java` file and add the following:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Ahora vamos a consumir la solicitud de quota y dar un precio. Dentro del proyecto `processor`, localice el archivo `src/main/java/org/acme/amqp/processor/QuoteProcessor.java` y añada lo siguiente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `process` method is called for every AMQP message from the `quote-requests` queue, and will send a `Quote` object to the `quotes` queue.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>El método `process` es llamado por cada mensaje AMQP de la cola `quote-requests`, y enviará un objeto `Quote` a la cola `quotes`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Back to our `producer` project.  Let's modify the `QuotesResource` to consume quotes, bind it to an HTTP endpoint to send events to clients:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Volvamos a nuestro proyecto `producer`. Vamos a modificar el `QuotesResource` para consumir citas, enlazarlo a un endpoint HTTP para enviar eventos a los clientes:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create inside the `producer` project `src/main/resources/META-INF/resources/quotes.html` file, with the following content:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Cree dentro del proyecto `producer` el archivo `src/main/resources/META-INF/resources/quotes.html`, con el siguiente contenido:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Nothing spectacular here.  On each received quote, it updates the page.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>No hay nada espectacular aquí. En cada cotización recibida, actualiza la página.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus starts a AMQP broker automatically, configures the application and shares the broker instance between different applications.  See xref:amqp-dev-services.adoc[Dev Services for AMQP] for more details.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Quarkus inicia un broker AMQP automáticamente, configura la aplicación y comparte la instancia del broker entre diferentes aplicaciones. Ver xref:amqp-dev-services.html[Dev Services for AMQP] para más detalles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When not running in dev or test mode, you will need to start your AMQP broker.  You can follow the instructions from the https://activemq.apache.org/components/artemis/documentation/latest/using-server.html[Apache ActiveMQ Artemis website] or create a `docker-compose.yaml` file with the following content:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Cuando no se esté ejecutando en modo dev o test, tendrá que iniciar su broker AMQP. Puede seguir las instrucciones del https://activemq.apache.org/components/artemis/documentation/latest/using-server.html[sitio web de Apache ActiveMQ Artemis] o crear un archivo `docker-compose.yaml` con el siguiente contenido:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note how the AMQP broker location is configured.  The `amqp.host` and `amqp.port` (`AMQP_HOST` and `AMQP_PORT` environment variables) properties configure location.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Observe cómo se configura la ubicación del broker AMQP. Las propiedades `amqp.host` y `amqp.port` ( `AMQP_HOST` y `AMQP_PORT` variables de entorno) configuran la ubicación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once packaged, run `docker compose up --build`.  The UI is exposed on http://localhost:8080/quotes.html</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Una vez empaquetado, ejecute `docker compose up --build`. La interfaz de usuario se expone en http://localhost:8080/quotes.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `-Dquarkus.native.container-build=true` instructs Quarkus to build Linux 64bits native executables, who can run inside containers.  Then, run the system using:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>El `-Dquarkus.native.container-build=true` instruye a Quarkus para construir ejecutables nativos de Linux 64bits, que pueden ejecutarse dentro de contenedores. Luego, ejecuta el sistema usando:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As before, the UI is exposed on http://localhost:8080/quotes.html</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Como antes, la interfaz de usuario está expuesta en http://localhost:8080/quotes.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide has shown how you can interact with AMQP 1.0 using Quarkus.  It utilizes https://smallrye.io/smallrye-reactive-messaging[SmallRye Reactive Messaging] to build data streaming applications.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Esta guía ha mostrado cómo puedes interactuar con AMQP 1.0 usando Quarkus. Utiliza https://smallrye.io/smallrye-reactive-messaging[SmallRye Reactive Messaging] para construir aplicaciones de streaming de datos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you did the Kafka quickstart, you have realized that it's the same code.  The only difference is the connector configuration and the JSON mapping.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Si has hecho el quickstart de Kafka, te habrás dado cuenta de que es el mismo código. La única diferencia es la configuración del conector y el mapeo JSON.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Enables (default) or disables the Cloud Event support. If enabled on an _incoming_ channel, the connector analyzes the incoming records and try to create Cloud Event metadata. If enabled on an _outgoing_, the connector sends the outgoing messages as Cloud Event if the message includes Cloud Event Metadata.

Type: _boolean_</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Activa (por defecto) o desactiva el soporte de Cloud Event. Si se habilita en un canal de _entrada_, el conector analiza los registros entrantes e intenta crear metadatos de Cloud Event. Si se habilita en un canal _saliente_, el conector envía los mensajes salientes como Cloud Event si el mensaje incluye metadatos Cloud Event.

Type: _boolean_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Cloud Event mode (`structured` or `binary` (default)). Indicates how are written the cloud events in the outgoing record

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>El modo de eventos en la nube ( `structured` o `binary` (por defecto)). Indica cómo se escriben los eventos de la nube en el registro de salida

Type: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>pom.xml</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>pom.xml</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>build.gradle</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>build.gradle</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With Quarkus you can deploy your favorite Java HTTP frameworks as Amazon Lambda's using either the https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api.html[AWS Gateway HTTP API] or https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-rest-api.html[AWS Gateway REST API].  This means that you can deploy your microservices written with RESTEasy Reactive (JAX-RS), Undertow (servlet), Reactive Routes, xref:funqy-http.adoc[Funqy HTTP] or any other Quarkus HTTP framework as an AWS Lambda.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Con Quarkus puede implementar sus marcos Java HTTP favoritos como Amazon Lambda utilizando la https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api.html[API HTTP de AWS Gateway] o https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-rest-api.html[la API REST de AWS Gateway]. Esto significa que puede implementar sus microservicios escritos con RESTEasy Reactive (JAX-RS), Undertow (servlet), Reactive Routes, xref:funqy-http.adoc[Funqy HTTP] o cualquier otro marco HTTP de Quarkus como un AWS Lambda.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are building on a non-Linux system, you will need to also pass in a property instructing quarkus to use a Docker build as Amazon Lambda requires Linux binaries.  You can do this by passing `-Dquarkus.native.container-build=true` to your build command.  This requires you to have Docker installed locally, however.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Si estás construyendo en un sistema que no es Linux, tendrás que pasar también una propiedad que indique a quarkus que utilice una construcción Docker, ya que Amazon Lambda requiere binarios Linux. Puedes hacer esto pasando `-Dquarkus.native.container-build=true` a tu comando de construcción. Sin embargo, esto requiere que tengas Docker instalado localmente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In dev and test mode, Quarkus will start a mock AWS Lambda event server that will convert HTTP requests to the corresponding API Gateway event types and post them to the underlying Quarkus HTTP lambda environment for processing.  This simulates the AWS Lambda environment as much as possible locally without requiring tools like Docker and SAM CLI.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>En el modo de desarrollo y prueba, Quarkus iniciará un servidor de eventos AWS Lambda falso que convertirá las solicitudes HTTP en los tipos de eventos de API Gateway correspondientes y los enviará al entorno HTTP Lambda subyacente de Quarkus para su procesamiento. Esto simula el entorno de AWS Lambda tanto como sea posible localmente sin requerir herramientas como Docker y SAM CLI.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using Quarkus Dev Mode just invoke HTTP requests on `http://localhost:8080` as you normally would when testing your REST endpoints.  This request will hit the Mock Event Server and will be converted to the API Gateway json message that is consumed by the Quarkus Lambda Poll loop.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Cuando se utiliza el Modo Dev de Quarkus sólo hay que invocar peticiones HTTP en `http://localhost:8080` como lo harías normalmente al probar tus endpoints REST. Esta solicitud llegará al Servidor de Eventos Mock y se convertirá en el mensaje json de API Gateway que es consumido por el bucle Quarkus Lambda.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For testing, Quarkus starts up a separate Mock Event server under port 8081.  The default port for Rest Assured is automatically set to 8081 by Quarkus, so you don't have to worry about setting this up.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Para las pruebas, Quarkus inicia un servidor de Eventos Mock separado bajo el puerto 8081. El puerto por defecto para Rest Assured se establece automáticamente en 8081 por Quarkus, por lo que no tiene que preocuparse de configurar esto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to simulate more complex API Gateway events in your tests, then manually do an HTTP POST to `http://localhost:8080/\_lambda_` (port 8081 in test mode) with the raw API Gateway json events.  These events will be placed directly on the Quarkus Lambda poll loop for processing.  Here's an example of that:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Si quieres simular eventos más complejos de la API Gateway en tus pruebas, entonces haz manualmente un HTTP POST a `http://localhost:8080/_lambda_` (puerto 8081 en modo de prueba) con los eventos json de API Gateway sin procesar. Estos eventos se colocarán directamente en el bucle de Quarkus Lambda para su procesamiento. Aquí hay un ejemplo de eso:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to hand code raw events for the AWS HTTP API, the AWS Lambda library has the request event type which is `com.amazonaws.services.lambda.runtime.events.APIGatewayV2HTTPEvent` and the response event type of `com.amazonaws.services.lambda.runtime.events.APIGatewayV2HTTPResponse`.  This corresponds to the `quarkus-amazon-lambda-http` extension and the AWS HTTP API.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Si desea codificar a mano eventos sin procesar para la API de AWS HTTP, la biblioteca de AWS Lambda tiene el tipo de evento de solicitud que es `com.amazonaws.services.lambda.runtime.events.APIGatewayV2HTTPEvent` y el tipo de evento de respuesta de `com.amazonaws.services.lambda.runtime.events.APIGatewayV2HTTPResponse`. Esto corresponde a la extensión `quarkus-amazon-lambda-http` y a la API de AWS HTTP.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to hand code raw events for the AWS REST API, Quarkus has its own implementation: `io.quarkus.amazon.lambda.http.model.AwsProxyRequest` and `io.quarkus.amazon.lambda.http.model.AwsProxyResponse`.  This corresponds to `quarkus-amazon-lambda-rest` extension and the AWS REST API.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Si quieres codificar a mano los eventos en bruto para la API de AWS REST, Quarkus tiene su propia implementación: `io.quarkus.amazon.lambda.http.model.AwsProxyRequest` y `io.quarkus.amazon.lambda.http.model.AwsProxyResponse`. Esto corresponde a la extensión `quarkus-amazon-lambda-rest` y a la API REST de AWS.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The mock event server is also started for `@NativeImageTest` and `@QuarkusIntegrationTest` tests so will work with native binaries too.  All this provides similar functionality to the SAM CLI local testing, without the overhead of Docker.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>El servidor de eventos simulados también se inicia para las pruebas de `@NativeImageTest` y `@QuarkusIntegrationTest`, por lo que también funcionará con binarios nativos. Todo esto proporciona una funcionalidad similar a las pruebas locales de SAM CLI, sin la sobrecarga de Docker.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Also, at least in the generated Maven archetype `pom.xml`, the `quarkus-resteasy-reactive`, `quarkus-reactive-routes`, and `quarkus-undertow` dependencies are all optional.  Pick which HTTP framework(s) you want to use (JAX-RS, Reactive Routes, and/or Servlet) and remove the other dependencies to shrink your deployment.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Además, al menos en el arquetipo de Maven generado `pom.xml`, las dependencias `quarkus-resteasy-reactive`, `quarkus-reactive-routes`, y `quarkus-undertow` son todas opcionales. Escoge qué marco(s) HTTP quieres usar (JAX-RS, Reactive Routes, y/o Servlet) y elimina las otras dependencias para reducir tu despliegue.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using RESTEasy Reactive and JAX-RS, you can inject various AWS Context variables into your JAX-RS resource classes using the JAX-RS `@Context` annotation or anywhere else with the CDI `@Inject` annotation.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Si utiliza RESTEasy Reactive y JAX-RS, puede inyectar varias variables de contexto de AWS en sus clases de recursos JAX-RS utilizando la anotación JAX-RS `@Context` o en cualquier otro lugar con la anotación CDI `@Inject`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you invoke an HTTP request on the API Gateway, the Gateway turns that HTTP request into a JSON event document that is forwarded to a Quarkus Lambda.  The Quarkus Lambda parses this json and converts in into an internal representation of an HTTP request that can be consumed by any HTTP framework Quarkus supports (JAX-RS, servlet, Reactive Routes).</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Cuando se invoca una solicitud HTTP en la pasarela de la API, la pasarela convierte esa solicitud HTTP en un documento de evento JSON que se reenvía a un Quarkus Lambda. La Lambda de Quarkus analiza este json y lo convierte en una representación interna de una solicitud HTTP que puede ser consumida por cualquier marco HTTP que Quarkus admita (JAX-RS, servlet, Rutas Reactivas).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>API Gateway supports many different ways to securely invoke on your HTTP endpoints that are backed by Lambda and Quarkus.  If you enable it, Quarkus will automatically parse relevant parts of the https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-lambda.html[event json document] and look for security based metadata and register a `java.security.Principal` internally that can be looked up in JAX-RS by injecting a `javax.ws.rs.core.SecurityContext`, via `HttpServletRequest.getUserPrincipal()` in servlet, and `RouteContext.user()` in Reactive Routes.  If you want more security information, the `Principal` object can be typecast to a class that will give you more information.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>API Gateway admite muchas formas diferentes de invocar de forma segura en sus puntos finales HTTP que están respaldados por Lambda y Quarkus. Si lo habilitas, Quarkus analizará automáticamente las partes relevantes del https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-lambda.html[documento json] del evento y buscará metadatos basados en la seguridad y registrará un `java.security.Principal` internamente que puede ser buscado en JAX-RS inyectando un `javax.ws.rs.core.SecurityContext`, a través de `HttpServletRequest.getUserPrincipal()` en servlet, y `RouteContext.user()` en Reactive Routes. Si quieres más información de seguridad, el objeto `Principal` puede ser typecast a una clase que te dará más información.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If using Powershell , wrap `-D` parameters in double quotes e.g. `"-DprojectArtifactId=getting-started"`</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Si utiliza Powershell, envuelva los parámetros de `-D` entre comillas dobles, por ejemplo `"-DprojectArtifactId=getting-started"`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once generated, look at the `pom.xml`.  You will find the import of the Quarkus BOM, allowing you to omit the version of the different Quarkus dependencies.  In addition, you can see the `quarkus-maven-plugin` responsible of the packaging of the application and also providing the development mode.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Una vez generado, mira el `pom.xml`. Encontrarás la importación Quarkus BOM, permitiendo omitir la versión de las diferentes dependencias de Quarkus. Además, se puede ver el `quarkus-maven-plugin` responsable del empaquetado de la aplicación y también proporcionar el modo de desarrollo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dependency injection in Quarkus is based on ArC which is a CDI-based dependency injection solution tailored for Quarkus' architecture.  If you're new to CDI then we recommend you to read the xref:cdi.adoc[Introduction to CDI] guide.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>La inyección de dependencias en Quarkus se basa en ArC, que es una solución de inyección de dependencias basada en CDI y adaptada a la arquitectura de Quarkus. Si eres nuevo en CDI, te recomendamos que leas la guía de xref:cdi.adoc[Introduction to CDI].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's modify the application and add a companion bean.  Create the `src/main/java/org/acme/GreetingService.java` file with the following content:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Vamos a modificar la aplicación y a añadir un bean de acompañamiento. Crea el archivo `src/main/java/org/acme/GreetingService.java` con el siguiente contenido:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus:dev` runs Quarkus in development mode. This enables live reload with background compilation, which means that when you modify your Java files and/or your resource files and refresh your browser, these changes will automatically take effect.  This works too for resource files like the configuration property file.  Refreshing the browser triggers a scan of the workspace, and if any changes are detected, the Java files are recompiled and the application is redeployed; your request is then serviced by the redeployed application. If there are any issues with compilation or deployment an error page will let you know.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>`quarkus:dev` ejecuta Quarkus en modo de desarrollo. Esto permite la recarga en vivo con compilación en segundo plano, lo que significa que cuando se modifican los archivos Java y/o los archivos de recursos y se actualiza el navegador, estos cambios tendrán efecto automáticamente. Esto funciona también para los archivos de recursos como el archivo de propiedades de configuración. Al actualizar el navegador, se realiza un análisis del área de trabajo y, si se detecta algún cambio, se recopilaran los archivos Java y se vuelve a desplegar la aplicación; la solicitud se atiende entonces con la aplicación re-desplegada. Si hay algún problema con la compilación o el despliegue, una página de error le informará.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus supports https://junit.org/junit5/[JUnit 5] tests.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Quarkus es compatible con las pruebas de https://junit.org/junit5/[JUnit 5].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Because of this, in the case of Maven, the version of the https://maven.apache.org/surefire/maven-surefire-plugin/[Surefire Maven Plugin] must be set, as the default version does not support JUnit 5:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Debido a esto, en el caso de Maven, se debe establecer la versión del https://maven.apache.org/surefire/maven-surefire-plugin/[Surefire Maven Plugin], ya que la versión por defecto no soporta JUnit 5:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The generated project contains a simple test.  Edit the `src/test/java/org/acme/GreetingResourceTest.java` to match the following content:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>El proyecto generado contiene una prueba sencilla. Edite el `src/test/java/org/acme/GreetingResourceTest.java` para que coincida con el siguiente contenido:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>However, when working with a multi-module project, be sure to read the `Working with multi-module projects` section of the xref:maven-tooling.adoc#multi-module-maven[Maven] or xref:gradle-tooling.adoc#multi-module-maven[Gradle] guides.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Sin embargo, cuando trabajes con un proyecto multimódulo, asegúrate de leer la sección `Working with multi-module projects` de las guías de xref:maven-tooling.adoc#multi-module-maven[Maven] o xref:gradle-tooling.adoc#multi-module-maven[Gradle] </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covered the creation of an application using Quarkus.  However, there is much more.  We recommend continuing the journey with the xref:building-native-image.adoc[building a native executable guide], where you learn about creating a native executable and packaging it in a container.  If you are interested in reactive, we recommend the xref:getting-started-reactive.adoc[Getting Started with Reactive guide], where you can see how to implement reactive applications with Quarkus.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Esta guía cubre la creación de una aplicación utilizando Quarkus. Sin embargo, hay mucho más. Recomendamos continuar el viaje con la guía de xref:building-native-image.adoc[building a native executable guide], donde se aprende a crear un ejecutable nativo y empaquetarlo en un contenedor. Si te interesa lo reactivo, te recomendamos la guía xref:getting-started-reactive.adoc[Getting Started with Reactive guide], donde podrás ver cómo implementar aplicaciones reactivas con Quarkus.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In addition, the xref:tooling.adoc[tooling guide] document explains how to:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Además, el documento xref:tooling.adoc[Guía de herramientas] explica cómo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>One azure function deployment can represent any number of JAX-RS, servlet, Reactive Routes, or xref:funqy-http.adoc[Funqy HTTP] endpoints.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Un despliegue de funciones azure puede representar cualquier número de endpoints JAX-RS, servlet, Reactive Routes o xref:funqy-http.html[Funqy HTTP].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide walks you through running a Maven Archetype to generate a sample project that contains three http endpoints written with JAX-RS APIs, Servlet APIs, Reactive Routes, or xref:funqy-http.adoc[Funqy HTTP] APIs.  After building, you will then be able to deploy to Azure.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Esta guía utiliza un arquetipo de Maven para generar un proyecto de ejemplo que contiene tres endpoints http escritos con APIs JAX-RS, APIs Servlet, Rutas Reactivas o APIs xref:funqy-http.html[Funqy HTTP]. Después de la construcción, usted será capaz de desplegar a Azure.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The sample project includes the RESTEasy Reactive, Undertow, Reactive Routes, xref:funqy-http.adoc[Funqy HTTP] extensions.  If you are only using one of those APIs (i.e. jax-rs only), respectively remove the maven dependency `quarkus-resteasy-reactive`, `quarkus-undertow`, `quarkus-funqy-http`, and/or `quarkus-reactive-routes`.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>El proyecto de ejemplo incluye las extensiones RESTEasy Reactive, Undertow, Reactive Routes y xref:funqy-http.html[Funqy HTTP]. Si sólo utiliza una de esas APIs (es decir, sólo jax-rs), elimine respectivamente la dependencia de maven `quarkus-resteasy-reactive`, `quarkus-undertow`, `quarkus-funqy-http`, y/o `quarkus-reactive-routes`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The default route prefix for an Azure Function is `/api`.  All of your JAX-RS, Servlet, Reactive Routes, and xref:funqy-http.adoc[Funqy HTTP] endpoints must explicitly take this into account.  In the generated project this is handled by the `quarkus.http.root-path` switch in `application.properties`</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>El prefijo de ruta por defecto para una Azure Function es `/api`. Todos tus puntos finales JAX-RS, Servlet, Rutas Reactivas y xref:funqy-http.html[Funqy HTTP] deben tenerlo en cuenta explícitamente. En el proyecto generado esto es manejado por el interruptor `quarkus.http.root-path` en `application.properties`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you have a single connector on your classpath, you can omit the `connector` attribute configuration.  Quarkus automatically associates _orphan_ channels to the (unique) connector found on the classpath.  _Orphans_ channels are outgoing channels without a downstream consumer or incoming channels without an upstream producer.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Si tiene un solo conector en su classpath, puede omitir la configuración del atributo `connector`. Quarkus asocia automáticamente los canales _huérfanos_ al conector (único) que se encuentra en el classpath. Los canales _huérfanos_ son canales salientes sin un consumidor descendente o canales entrantes sin un productor ascendente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@Transactional</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>@Transactional</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If your method is annotated with `@Transactional`, it will be considered _blocking_ automatically, even if the method is not annotated with `@Blocking`.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Si su método está anotado con `@Transactional`, se considerará automáticamente _bloqueante_, incluso si el método no está anotado con `@Blocking`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The AMQP connector supports https://cloudevents.io/[Cloud Events].  When the connector detects a _structured_ or _binary_ Cloud Events, it adds a `IncomingCloudEventMetadata&lt;T&gt;` into the metadata of the `Message`.  `IncomingCloudEventMetadata` contains accessors to the mandatory and optional Cloud Event attributes.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>El conector AMQP soporta  https://cloudevents.io/[Cloud Events]. Cuando el conector detecta un Cloud Events _estructurado_ o _binario_, añade un `IncomingCloudEventMetadata&lt;T&gt;` en los metadatos del `Message`. `IncomingCloudEventMetadata` contiene accesos a los atributos obligatorios y opcionales del Cloud Event.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The AMQP connector supports https://cloudevents.io/[Cloud Events].  The connector sends the outbound record as Cloud Events if:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>El conector AMQP es compatible con https://cloudevents.io/[Cloud Events]. El conector envía el registro de salida como Cloud Events si:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the message metadata contains an `io.smallrye.reactive.messaging.ce.OutgoingCloudEventMetadata` instance,</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>los metadatos del mensaje contienen una instancia de `io.smallrye.reactive.messaging.ce.OutgoingCloudEventMetadata`,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the channel configuration defines the `cloud-events-type` and `cloud-events-source` attributes.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>la configuración del canal define los atributos `cloud-events-type` y `cloud-events-source`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[.no-hyphens]#*address*#</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>[.no-hyphens]#*address*#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[.no-hyphens]#*auto-acknowledgement*#</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>[.no-hyphens]#*auto-acknowledgement*#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[.no-hyphens]#*broadcast*#</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>[.no-hyphens]#*broadcast*#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[.no-hyphens]#*client-options-name*#

[.no-hyphens]#_(amqp-client-options-name)_#</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>[.no-hyphens]#*client-options-name*#

[.no-hyphens]#_(amqp-client-options-name)_#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[.no-hyphens]#*cloud-events*#</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>[.no-hyphens]#*cloud-events*#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[.no-hyphens]#*connect-timeout*#

[.no-hyphens]#_(amqp-connect-timeout)_#</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>[.no-hyphens]#*connect-timeout*#

[.no-hyphens]#_(amqp-connect-timeout)_#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[.no-hyphens]#*container-id*#</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>[.no-hyphens]#*container-id*#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[.no-hyphens]#*durable*#</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>[.no-hyphens]#*durable*#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[.no-hyphens]#*failure-strategy*#</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>[.no-hyphens]#*failure-strategy*#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[.no-hyphens]#*health-timeout*#</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>[.no-hyphens]#*health-timeout*#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[.no-hyphens]#*host*#

[.no-hyphens]#_(amqp-host)_#</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>[.no-hyphens]#*host*#

[.no-hyphens]#_(amqp-host)_#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[.no-hyphens]#*link-name*#</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>[.no-hyphens]#*link-name*#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[.no-hyphens]#*password*#

[.no-hyphens]#_(amqp-password)_#</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>[.no-hyphens]#*password*#

[.no-hyphens]#_(amqp-password)_#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[.no-hyphens]#*port*#

[.no-hyphens]#_(amqp-port)_#</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>[.no-hyphens]#*port*#

[.no-hyphens]#_(amqp-port)_#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[.no-hyphens]#*reconnect-attempts*#

[.no-hyphens]#_(amqp-reconnect-attempts)_#</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>[.no-hyphens]#*reconnect-attempts*#

[.no-hyphens]#_(amqp-reconnect-attempts)_#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[.no-hyphens]#*reconnect-interval*#

[.no-hyphens]#_(amqp-reconnect-interval)_#</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>[.no-hyphens]#*reconnect-interval*#

[.no-hyphens]#_(amqp-reconnect-interval)_#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[.no-hyphens]#*sni-server-name*#

[.no-hyphens]#_(amqp-sni-server-name)_#</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>[.no-hyphens]#*sni-server-name*#

[.no-hyphens]#_(amqp-sni-server-name)_#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[.no-hyphens]#*tracing-enabled*#</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>[.no-hyphens]#*tracing-enabled*#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[.no-hyphens]#*use-ssl*#

[.no-hyphens]#_(amqp-use-ssl)_#</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>[.no-hyphens]#*use-ssl*#

[.no-hyphens]#_(amqp-use-ssl)_#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[.no-hyphens]#*username*#

[.no-hyphens]#_(amqp-username)_#</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>[.no-hyphens]#*username*#

[.no-hyphens]#_(amqp-username)_#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[.no-hyphens]#*virtual-host*#

[.no-hyphens]#_(amqp-virtual-host)_#</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>[.no-hyphens]#*virtual-host*#

[.no-hyphens]#_(amqp-virtual-host)_#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[.no-hyphens]#*cloud-events-data-content-type*#

[.no-hyphens]#_(cloud-events-default-data-content-type)_#</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>[.no-hyphens]#*cloud-events-data-content-type*#

[.no-hyphens]#_(cloud-events-default-data-content-type)_#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[.no-hyphens]#*cloud-events-data-schema*#

[.no-hyphens]#_(cloud-events-default-data-schema)_#</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>[.no-hyphens]#*cloud-events-data-schema*#

[.no-hyphens]#_(cloud-events-default-data-schema)_#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[.no-hyphens]#*cloud-events-insert-timestamp*#

[.no-hyphens]#_(cloud-events-default-timestamp)_#</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>[.no-hyphens]#*cloud-events-insert-timestamp*#

[.no-hyphens]#_(cloud-events-default-timestamp)_#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[.no-hyphens]#*cloud-events-mode*#</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>[.no-hyphens]#*cloud-events-mode*#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[.no-hyphens]#*cloud-events-source*#

[.no-hyphens]#_(cloud-events-default-source)_#</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>[.no-hyphens]#*cloud-events-source*#

[.no-hyphens]#_(cloud-events-default-source)_#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[.no-hyphens]#*cloud-events-subject*#

[.no-hyphens]#_(cloud-events-default-subject)_#</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>[.no-hyphens]#*cloud-events-subject*#

[.no-hyphens]#_(cloud-events-default-subject)_#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[.no-hyphens]#*cloud-events-type*#

[.no-hyphens]#_(cloud-events-default-type)_#</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>[.no-hyphens]#*cloud-events-type*#

[.no-hyphens]#_(cloud-events-default-type)_#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[.no-hyphens]#*credit-retrieval-period*#</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>[.no-hyphens]#*credit-retrieval-period*#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[.no-hyphens]#*merge*#</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>[.no-hyphens]#*merge*#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[.no-hyphens]#*ttl*#</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>[.no-hyphens]#*ttl*#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[.no-hyphens]#*use-anonymous-sender*#</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>[.no-hyphens]#*use-anonymous-sender*#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to use RabbitMQ, you should use the xref:rabbitmq.adoc[SmallRye Reactive Messaging RabbitMQ extension].  Alternatively, if want to use RabbitMQ with AMQP 1.0 you need to enable the AMQP 1.0 plugin in the RabbitMQ broker; check the https://smallrye.io/smallrye-reactive-messaging/smallrye-reactive-messaging/3.9/amqp/amqp.html#amqp-rabbitmq[connecting to RabbitMQ] documentation.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Si quieres usar RabbitMQ, debes usar la xref:rabbitmq.adoc[extensión SmallRye Reactive Messaging RabbitMQ]. Alternativamente, si quieres usar RabbitMQ con AMQP 1.0 necesitas habilitar el plugin AMQP 1.0 en el broker RabbitMQ; consulta la documentación de https://smallrye.io/smallrye-reactive-messaging/smallrye-reactive-messaging/3.9/amqp/amqp.html#amqp-rabbitmq[conexión a RabbitMQ].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `quote-requests` channel is going to be managed as a AMQP queue, as that's the only connector on the classpath.  If not indicated otherwise, like in this example, Quarkus uses the channel name as AMQP queue name.  So, in this example, the application sends messages to the `quote-requests` queue.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>El canal `quote-requests` va a ser gestionado como una cola AMQP, ya que es el único conector en el classpath. Si no se indica lo contrario, como en este ejemplo, Quarkus utiliza el nombre del canal como nombre de la cola AMQP. Así, en este ejemplo, la aplicación envía mensajes a la cola `quote-requests`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Because we want to consume messages from the `quotes-requests` queue into the `requests` channel, we need to configure this association.  Open the `src/main/resources/application.properties` file and add:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Como queremos consumir mensajes de la cola `quotes-requests` en el canal `requests`, necesitamos configurar esta asociación. Abre el archivo `src/main/resources/application.properties` y añade:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus's integration with lambdas also supports Quarkus's Live Coding development cycle.  You an bring up your Quarkus lambda project in dev or test mode and code on your project live.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>La integración de Quarkus con las lambdas también es compatible con el ciclo de desarrollo Live Coding de Quarkus. Usted puede traer su proyecto Quarkus lambda en el modo de desarrollo o de prueba y el código en su proyecto en vivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are building on a non-Linux system, you will need to also pass in a property instructing Quarkus to use a docker build as Amazon Lambda requires linux binaries.  You can do this by passing this property to your build: `-Dquarkus.native.container-build=true`. This requires you to have Docker installed locally, however.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Si estás construyendo en un sistema que no es Linux, tendrás que pasar también una propiedad que indique a Quarkus que utilice una construcción docker, ya que Amazon Lambda requiere binarios linux. Puedes hacerlo pasando esta propiedad a tu construcción: `-Dquarkus.native.container-build=true`. Sin embargo, esto requiere que tengas Docker instalado localmente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is nothing special about the POM other than the inclusion of the `quarkus-amazon-lambda` extension as a dependency.  The extension automatically generates everything you might need for your lambda deployment.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>No hay nada especial en el POM, aparte de la inclusión de la extensión `quarkus-amazon-lambda` como dependencia. La extensión genera automáticamente todo lo que puedas necesitar para tu despliegue de lambda.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Similarly for Gradle projects, you also just have to add the `quarkus-amazon-lambda` dependency.  The extension automatically generates everything you might need for your lambda deployment.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Del mismo modo, para los proyectos de Gradle, también sólo tienes que añadir la dependencia de `quarkus-amazon-lambda`. La extensión genera automáticamente todo lo que puedas necesitar para el despliegue de tu lambda.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To mirror the AWS Lambda environment as closely as possible in a dev environment, the Quarkus Amazon Lambda extension boots up a mock AWS Lambda event server in Quarkus Dev and Test mode.  This mock event server simulates a true AWS Lambda environment.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Para reflejar el entorno de AWS Lambda con la mayor exactitud posible en un entorno de desarrollo, la extensión de Quarkus Amazon Lambda inicia un servidor de eventos de AWS Lambda falso en el modo de desarrollo y prueba de Quarkus. Este servidor de eventos falso simula un verdadero entorno de AWS Lambda.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While running in Quarkus Dev Mode, you can feed events to it by doing an HTTP POST to `http://localhost:8080`.  The mock event server will receive the events and your lambda will be invoked.  You can perform live coding on your lambda and changes will automatically be recompiled and available the next invocation you make.  Here's an example:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Mientras se ejecuta en el modo de desarrollo de Quarkus, puede alimentar los eventos haciendo un POST HTTP a `http://localhost:8080`. El servidor de eventos falso recibirá los eventos y su lambda será invocado. Puedes realizar codificación en vivo en tu lambda y los cambios se recompilarán automáticamente y estarán disponibles en la siguiente invocación que hagas. Aquí tienes un ejemplo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For your unit tests, you can also invoke on the mock event server using any HTTP client you want.  Here's an example using rest-assured.  Quarkus starts up a separate Mock Event server under port 8081.  The default port for Rest Assured is automatically set to 8081 by Quarkus so you can invoke on this endpoint.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Para tus pruebas unitarias, también puedes invocar en el servidor de eventos falso usando cualquier cliente HTTP que quieras. Aquí hay un ejemplo usando rest-assured. Quarkus inicia un servidor de eventos simulados separado bajo el puerto 8081. El puerto por defecto para Rest Assured se establece automáticamente a 8081 por Quarkus para que pueda invocar en este punto final.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If your code makes HTTPS calls, such as to a micro-service (or AWS service), you will need to add configuration to the native image, as GraalVM will only include the dependencies when explicitly declared.  Quarkus, by default enables this functionality on extensions that implicitly require it.  For further information, please consult the xref:native-and-ssl.adoc[Quarkus SSL guide]</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Si tu código hace llamadas HTTPS, como por ejemplo a un microservicio (o servicio AWS), tendrás que añadir la configuración a la imagen nativa, ya que GraalVM sólo incluirá las dependencias cuando se declaren explícitamente. Quarkus, por defecto habilita esta funcionalidad en las extensiones que implícitamente lo requieren. Para más información, consulta la xref:native-and-ssl.adoc[Guía de Quarkus SSL]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus now has extensions for DynamoDB, S3, SNS and SQS (more coming).  Please check link:{amazon-services-guide}[those guides] on how to use the various AWS Services with Quarkus, as opposed to wiring manually like below.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Quarkus ahora tiene extensiones para DynamoDB, S3, SNS y SQS (más en camino). Por favor, consulte link:{amazon-services-guide}[estas guías] sobre cómo utilizar los diversos servicios de AWS con Quarkus, en lugar de cablear manualmente como se indica a continuación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>if you see `java.security.InvalidAlgorithmParameterException: the trustAnchors parameter must be non-empty` or similar SSL error, due to the current status of GraalVM, there is some additional work to bundle the `function.zip`, as below.  For more information, please see the xref:native-and-ssl.adoc[Quarkus Native SSL Guide].</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>si ves `java.security.InvalidAlgorithmParameterException: the trustAnchors parameter must be non-empty` o un error SSL similar, debido al estado actual de GraalVM, hay algo de trabajo adicional para agrupar el `function.zip`, como se indica a continuación. Para más información, por favor vea la xref:native-and-ssl.html[Guía de SSL nativa de Quarkus].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For a regular JVM distribution you need to base your image off the official AWS Java base images. Below is an example of a Dockerfile that would create a container image from your Quarkus Lambda project. It assumes that `mvn package` has been executed and binaries are available in the `target/` directory:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Para una distribución regular de JVM necesitas basar tu imagen en las imágenes base oficiales de AWS Java. A continuación se muestra un ejemplo de un archivo Docker que crearía una imagen de contenedor de su proyecto Quarkus Lambda. Asume que `mvn package` ha sido ejecutado y los binarios están disponibles en el directorio `target/`:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To create a lambda container image that uses the native executable we'll need to do things a little differently. In this case, we won't need to use the `java:11` base image from AWS but instead we'll use a special image that assumes that the runtime environment for the lambda is provided. The example below creates such a container. It assumes that a Maven build has been executed (such as `mvn package -Dnative=true`) and has generated the native binary into the `target/` directory. The binary needs to be named `bootstrap` and be placed in `/var/runtime/`:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Para crear una imagen de contenedor lambda que utilice el ejecutable nativo tendremos que hacer las cosas de forma un poco diferente. En este caso, no necesitaremos utilizar la imagen base de `java:11` de AWS, sino que utilizaremos una imagen especial que asume que se proporciona el entorno de ejecución para lambda. El siguiente ejemplo crea un contenedor de este tipo. Asume que se ha ejecutado una construcción de Maven (como `mvn package -Dnative=true`) y ha generado el binario nativo en el directorio `target/`. El binario necesita ser llamado `bootstrap` y ser colocado en `/var/runtime/`:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Below, you can see how the container images created above can be built and deployed to AWS using the `docker` and `aws` command line tools. These instructions work for both native and jvm container images and assume that the `aws` command line tool has been logged in.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>A continuación, puede ver cómo las imágenes de contenedor creadas anteriormente pueden construirse e implementarse en AWS utilizando las herramientas de línea de comandos `docker` y `aws`. Estas instrucciones funcionan tanto para imágenes de contenedor nativas como jvm y asumen que la herramienta de línea de comandos `aws` ha sido iniciada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Make sure you reference the image you uploaded previously (assumes that a role exists that can be used to run the lambda). Please note that it is not unlikely that for the JVM lambda function, the default memory limit of `128Mb` will not be enough to run the function. In that case, you can increase the memory limit when creating the function by providing the `--memory-size 256` parameter to your `aws lambda create-function` command. You can also adjust the function in the AWS console after you've created it.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Asegúrate de que haces referencia a la imagen que has subido previamente (se supone que existe un rol que puede ser utilizado para ejecutar la lambda). Ten en cuenta que no es improbable que para la función lambda de JVM, el límite de memoria por defecto de `128Mb` no sea suficiente para ejecutar la función. En ese caso, puede aumentar el límite de memoria al crear la función proporcionando el parámetro `--memory-size 256` a su comando `aws lambda create-function`. También puede ajustar la función en la consola de AWS después de haberla creado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Short informative videos that highlight unique technical points and instructions on how to get the most out of Quarkus.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Vídeos informativos cortos que destacan puntos técnicos únicos e instrucciones sobre cómo sacar el máximo partido a Quarkus</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Why follow this process</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>¿Por qué seguir este proceso?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The community will fix security bugs for the latest major.minor version published at https://quarkus.io/get-started/.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>La comunidad corregirá los errores de seguridad para la última versión major.minor publicada en [https://quarkus.io/get-started/](https://quarkus.io/get-started/).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Support When You Need It.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Soporte cuando lo necesite</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus team and community take all security bugs very seriously. You can find our guidelines here regarding our policy and security disclosure.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>El equipo y la comunidad de Quarkus se toman muy en serio todos los errores de seguridad. Puede encontrar nuestras pautas aquí con respecto a nuestra política y divulgación de seguridad</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus has been honored to receive multiple awards and recognition. We feel these are an affirmation of the great work being done by our dedicated community. We’ve started a trophy case to share the kudos with everyone.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Quarkus ha tenido el honor de recibir múltiples premios y reconocimientos. Creemos que estos son una afirmación del gran trabajo realizado por nuestra comunidad dedicada. Hemos comenzado una vitrina de trofeos para compartir las felicitaciones con todos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Multiple ways to connect with others via forum, stack, chat, or email groups.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Múltiples formas de conectarse con otros a través de foros, stack, chat o grupos de correo electrónico</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus applications are optimised for low memory usage and fast startup times.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Las aplicaciones de Quarkus están optimizadas para un uso de memoria bajo y tiempos de inicio rápidos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus 2.0 continues the mission of making Java the preferred framework for Kubernetes-native development with new developer tools and improved performance.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Quarkus 2.0 continúa la misión de hacer de Java el marco preferido para el desarrollo nativo de Kubernetes con nuevas herramientas para desarrolladores y un rendimiento mejorado</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus applications are designed to run in containers.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Las aplicaciones de Quarkus están diseñadas para ejecutarse en contenedores.</seg>
      </tuv>
    </tu>
  </body>
</tmx>
