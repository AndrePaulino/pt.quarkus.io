<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE tmx SYSTEM "tmx14.dtd">
<tmx version="1.4">
  <header creationtool="Translate Toolkit" creationtoolversion="3.6.2" segtype="sentence" o-tmf="UTF-8" adminlang="en" srclang="en" datatype="PlainText"/>
  <body>
    <tu>
      <tuv xml:lang="en">
        <seg>`false`</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>`false`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`true`</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>`true`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The format for durations uses the standard `java.time.Duration` format.  You can learn more about it in the link:https://docs.oracle.com/javase/8/docs/api/java/time/Duration.html#parse-java.lang.CharSequence-[Duration#parse() javadoc].</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>El formato de las duraciones utiliza el formato estándar `java.time.Duration`. Puede obtener más información al respecto en link:https://docs.oracle.com/javase/8/docs/api/java/time/Duration.html#parse-java.lang.CharSequence-[Duration#parse() javadoc].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also provide duration values starting with a number.  In this case, if the value consists only of a number, the converter treats the value as seconds.  Otherwise, `PT` is implicitly prepended to the value to obtain a standard `java.time.Duration` format.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>También puede proporcionar valores de duración que empiecen por un número. En este caso, si el valor consiste sólo en un número, el conversor trata el valor como segundos. En caso contrario, `PT` se antepone implícitamente al valor para obtener un formato estándar `java.time.Duration`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`localhost`</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>`localhost`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Amazon Lambda</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Amazon Lambda</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`binary`</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>`binary`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Neo4j</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Neo4j</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkus`</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>`io.quarkus`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The community will fix security bugs for the latest major.minor version published at https://quarkus.io/get-started/.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>La comunidad corregirá los errores de seguridad para la última versión major.minor publicada en [https://quarkus.io/get-started/](https://quarkus.io/get-started/).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus applications are designed to run in containers.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Las aplicaciones de Quarkus están diseñadas para ejecutarse en contenedores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus applications are optimised for low memory usage and fast startup times.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Las aplicaciones de Quarkus están optimizadas para un uso de memoria bajo y tiempos de inicio rápidos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[.no-hyphens]#*cloud-events*#</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>[.no-hyphens]#*cloud-events*#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Enables (default) or disables the Cloud Event support. If enabled on an _incoming_ channel, the connector analyzes the incoming records and try to create Cloud Event metadata. If enabled on an _outgoing_, the connector sends the outgoing messages as Cloud Event if the message includes Cloud Event Metadata.

Type: _boolean_</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Activa (por defecto) o desactiva el soporte de Cloud Event. Si se habilita en un canal de _entrada_, el conector analiza los registros entrantes e intenta crear metadatos de Cloud Event. Si se habilita en un canal _saliente_, el conector envía los mensajes salientes como Cloud Event si el mensaje incluye metadatos Cloud Event.

Type: _boolean_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[.no-hyphens]#*cloud-events-data-content-type*#

[.no-hyphens]#_(cloud-events-default-data-content-type)_#</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>[.no-hyphens]#*cloud-events-data-content-type*#

[.no-hyphens]#_(cloud-events-default-data-content-type)_#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[.no-hyphens]#*cloud-events-data-schema*#

[.no-hyphens]#_(cloud-events-default-data-schema)_#</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>[.no-hyphens]#*cloud-events-data-schema*#

[.no-hyphens]#_(cloud-events-default-data-schema)_#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[.no-hyphens]#*cloud-events-insert-timestamp*#

[.no-hyphens]#_(cloud-events-default-timestamp)_#</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>[.no-hyphens]#*cloud-events-insert-timestamp*#

[.no-hyphens]#_(cloud-events-default-timestamp)_#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[.no-hyphens]#*cloud-events-mode*#</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>[.no-hyphens]#*cloud-events-mode*#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Cloud Event mode (`structured` or `binary` (default)). Indicates how are written the cloud events in the outgoing record

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>El modo de eventos en la nube ( `structured` o `binary` (por defecto)). Indica cómo se escriben los eventos de la nube en el registro de salida

Type: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[.no-hyphens]#*cloud-events-source*#

[.no-hyphens]#_(cloud-events-default-source)_#</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>[.no-hyphens]#*cloud-events-source*#

[.no-hyphens]#_(cloud-events-default-source)_#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[.no-hyphens]#*cloud-events-subject*#

[.no-hyphens]#_(cloud-events-default-subject)_#</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>[.no-hyphens]#*cloud-events-subject*#

[.no-hyphens]#_(cloud-events-default-subject)_#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[.no-hyphens]#*cloud-events-type*#

[.no-hyphens]#_(cloud-events-default-type)_#</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>[.no-hyphens]#*cloud-events-type*#

[.no-hyphens]#_(cloud-events-default-type)_#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[.no-hyphens]#*merge*#</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>[.no-hyphens]#*merge*#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[.no-hyphens]#*tracing-enabled*#</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>[.no-hyphens]#*tracing-enabled*#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>pom.xml</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>pom.xml</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>build.gradle</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>build.gradle</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive].</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Clone el repositorio Git: `git clone {quickstarts-clone-url}` o descargue un {quickstarts-archive-url}[archivo].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to allow HTTP clients to invoke your Funqy functions on Google Cloud Functions, Quarkus allows you to expose multiple Funqy functions through HTTP deployed as one Google Cloud Function.  This approach does add overhead over the regular Funqy Google Cloud Function integration.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Si quieres permitir que los clientes HTTP invoquen tus funciones Funqy en Google Cloud Functions, Quarkus te permite exponer múltiples funciones Funqy a través de HTTP desplegadas como una Google Cloud Function. Este enfoque añade una sobrecarga sobre la integración regular de Funqy con Google Cloud Function.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Follow the xref:gcp-functions-http.adoc[Google Cloud Functions Http Guide].  It walks through using a variety of HTTP frameworks on Google Cloud Functions, including Funqy.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Siga la xref:gcp-functions-http.html[Guía Http] de Google Cloud Functions. En ella se explica el uso de diversos marcos de trabajo HTTP en Google Cloud Functions, incluido Funqy.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Funqy HTTP + Google Cloud Functions binding is not a replacement for REST over HTTP.  Because Funqy needs to be portable across a lot of different protocols and function providers its HTTP binding is very minimalistic and you will lose REST features like linking and the ability to leverage HTTP features like cache-control and conditional GETs.  You may want to consider using Quarkus's JAX-RS, Spring MVC, or Vert.x Web Reactive Route xref:gcp-functions-http.adoc[support] instead.  They also work with Quarkus and Google Cloud Functions.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>El enlace Funqy HTTP + Google Cloud Functions no es un sustituto de REST sobre HTTP. Debido a que Funqy necesita ser portátil a través de una gran cantidad de diferentes protocolos y proveedores de funciones, su enlace HTTP es muy minimalista y perderá las características de REST como la vinculación y la capacidad de aprovechar las características de HTTP como el control de caché y GETs condicionales. Es posible que desee considerar el uso de JAX-RS de Quarkus, Spring MVC, o el xref:gcp-functions-http.html[soporte de] Vert.x Web Reactive Route en su lugar. También funcionan con Quarkus y Google Cloud Functions.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is nothing special about the code and more importantly nothing Google Cloud specific.  Funqy functions can be deployed to many different environments and Google Cloud Functions is one of them.  The Java code is actually the same exact code as the {quickstarts-tree-url}/funqy-quickstarts/funqy-http-quickstart[funqy-http-quickstart].</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>No hay nada especial en el código y, lo que es más importante, nada específico de Google Cloud. Las funciones de Funqy pueden desplegarse en muchos entornos diferentes y Google Cloud Functions es uno de ellos. El código Java es en realidad el mismo código exacto que el {quickstarts-tree-url}/funqy-quickstarts/funqy-http-quickstart[funqy-http-quickstart].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The steps to get this quickstart running are exactly the same as defined in the xref:gcp-functions-http.adoc[Google Cloud Functions HTTP Guide].  This differences are that you are running from a quickstart and the Maven dependencies are slightly different.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Los pasos para ejecutar este quickstart son exactamente los mismos que se definen en la xref:gcp-functions-http.html[Guía HTTP de Google Cloud Functions]. Las diferencias son que se está ejecutando desde un inicio rápido y las dependencias de Maven son ligeramente diferentes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>One azure function deployment can represent any number of JAX-RS, servlet, Reactive Routes, or xref:funqy-http.adoc[Funqy HTTP] endpoints.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Un despliegue de funciones azure puede representar cualquier número de endpoints JAX-RS, servlet, Reactive Routes o xref:funqy-http.html[Funqy HTTP].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://azure.microsoft.com[An Azure Account].  Free accounts work.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>https://azure.microsoft.com[Una cuenta de Azure]. Las cuentas gratuitas funcionan.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide walks you through running a Maven Archetype to generate a sample project that contains three http endpoints written with JAX-RS APIs, Servlet APIs, Reactive Routes, or xref:funqy-http.adoc[Funqy HTTP] APIs.  After building, you will then be able to deploy to Azure.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Esta guía utiliza un arquetipo de Maven para generar un proyecto de ejemplo que contiene tres endpoints http escritos con APIs JAX-RS, APIs Servlet, Rutas Reactivas o APIs xref:funqy-http.html[Funqy HTTP]. Después de la construcción, usted será capaz de desplegar a Azure.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`groupId` - The maven groupId of this generated project.  Type in `org.acme`.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>`groupId` - El groupId de maven de este proyecto generado. Escriba en `org.acme`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`appName` - Use the default value.  This is the application name in Azure.  It must be a unique subdomain name under `*.azurewebsites.net`. Otherwise deploying to Azure will fail.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>`appName` - Utilice el valor por defecto. Este es el nombre de la aplicación en Azure. Debe ser un nombre de subdominio único bajo `*.azurewebsites.net`. De lo contrario, el despliegue en Azure fallará.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`appRegion` - Defaults to `westus`.  Dependent on your azure region.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>`appRegion` - Por defecto, `westus`. Depende de su región azure.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`function` - Use the default which is `quarkus`.  Name of your azure function. Can be anything you want.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>`function` - Utilice el valor por defecto que es `quarkus`. Nombre de su función azure. Puede ser cualquier cosa que desee.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`resourceGroup` - Use the default value.  Any value is fine though.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>`resourceGroup` - Utilice el valor por defecto. Sin embargo, cualquier valor es válido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `pom.xml` you generated in the previous step pulls in the `azure-functions-maven-plugin`.  Running maven install generates config files and a staging directory required by the `azure-functions-maven-plugin`.  Here's how to execute it.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>El `pom.xml` que generó en el paso anterior usa el `azure-functions-maven-plugin`. Ejecutar maven install genera los archivos de configuración y un directorio de staging requeridos por el `azure-functions-maven-plugin`. Así es como se ejecuta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>i.e.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>i.e.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://{appName}.azurewebsites.net/api/hello https://{appName}.azurewebsites.net/api/servlet/hello https://{appName}.azurewebsites.net/api/vertx/hello https://{appName}.azurewebsites.net/api/funqyHello</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>https://{appName}.azurewebsites.net/api/hello https://{appName}.azurewebsites.net/api/servlet/hello https://{appName}.azurewebsites.net/api/vertx/hello https://{appName}.azurewebsites.net/api/funqyHello</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Templates for Azure Functions deployment descriptors (`host.json`, `function.json`) are within the `azure-config` directory.  Edit them as you need to.  Rerun the build when you are ready.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Las plantillas para los descriptores de despliegue de Azure Functions ( `host.json`, `function.json`) están dentro del directorio `azure-config`. Edítelos según sea necesario. Vuelva a ejecutar la compilación cuando esté listo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*NOTE*: If you change the `function.json` `path` attribute or if you add a `routePrefix`,
your jax-rs endpoints won't route correctly.  See &lt;&lt;config-azure-paths&gt;&gt; for more information.
</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>*NOTA*: Si cambia el atributo `function.json` `path` o si añade un `routePrefix`,
sus endpoints jax-rs no se enrutarán correctamente. Consulte &lt;&lt;config-azure-paths&gt;&gt; para obtener más información.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The default route prefix for an Azure Function is `/api`.  All of your JAX-RS, Servlet, Reactive Routes, and xref:funqy-http.adoc[Funqy HTTP] endpoints must explicitly take this into account.  In the generated project this is handled by the `quarkus.http.root-path` switch in `application.properties`</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>El prefijo de ruta por defecto para una Azure Function es `/api`. Todos tus puntos finales JAX-RS, Servlet, Rutas Reactivas y xref:funqy-http.html[Funqy HTTP] deben tenerlo en cuenta explícitamente. En el proyecto generado esto es manejado por el interruptor `quarkus.http.root-path` en `application.properties`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you modify the `path` or add a `routePrefix` within the `azure-config/function.json` deployment descriptor, your code or configuration must also reflect any prefixes you specify for your path.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Si modifica el `path` o añade un `routePrefix` dentro del descriptor de despliegue `azure-config/function.json`, su código o configuración debe reflejar también cualquier prefijo que especifique para su ruta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`providesIf` allows listing multiple `&lt;positive&gt;` as well as `&lt;negative&gt;` elements.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>`providesIf` permite listar múltiples elementos `&lt;positive&gt;` así como `&lt;negative&gt;`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>CapabilityBuildItem</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>CapabilityBuildItem</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Each provided capability will be represented with an instance of `io.quarkus.deployment.builditem.CapabilityBuildItem` at build time. Theoretically, `CapabilityBuildItem`'s could be produced by extension build steps directly, bypassing the corresponding declaration in the extension descriptors. However, this way of providing capabilities should be avoided, unless there is a very good reason not to declare a capability in the descriptor.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Cada capacidad proporcionada se representará con una instancia de `io.quarkus.deployment.builditem.CapabilityBuildItem` en el momento de la construcción. Teóricamente, los `CapabilityBuildItem's podrían ser producidos por los pasos de construcción de la extensión directamente, pasando por alto la declaración correspondiente en los descriptores de la extensión. Sin embargo, esta forma de proporcionar capacidades debería evitarse, a menos que haya una muy buena razón para no declarar una capacidad en el descriptor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io`</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>`io`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkus.resteasy`</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>`io.quarkus.resteasy`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkus.resteasy.json`</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>`io.quarkus.resteasy.json`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkus.resteasy.json.jackson`</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>`io.quarkus.resteasy.json.jackson`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkus.resteasy.json.jackson.client`</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>`io.quarkus.resteasy.json.jackson.client`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkus.resteasy.json.jsonb`</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>`io.quarkus.resteasy.json.jsonb`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkus.resteasy.json.jsonb.client`</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>`io.quarkus.resteasy.json.jsonb.client`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Including any one of those extensions in an application will enable the RESTEasy JSON serializer. In case a build step needs to check whether the RESTEasy JSON serializer is already enabled in an application, instead of checking whether any of those capabilities is present, it could simply check whether an extension with prefix `io.quarkus.resteasy.json` is present.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>La inclusión de cualquiera de estas extensiones en una aplicación habilitará el serializador JSON de RESTEasy. En caso de que un paso de compilación necesite comprobar si el serializador JSON de RESTEasy ya está habilitado en una aplicación, en lugar de comprobar si está presente alguna de esas capacidades, podría simplemente comprobar si está presente una extensión con el prefijo `io.quarkus.resteasy.json`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide is the companion from the xref:amqp.adoc[Getting Started with AMQP 1.0].  It explains in more details the configuration and usage of the AMQP connector for reactive messaging.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Esta guía es el complemento de la guía xref:amqp.html[Introducción a AMQP 1.0]. En ella se explica con más detalle la configuración y el uso del conector AMQP para la mensajería reactiva.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This documentation does not cover all the details of the connector.  Refer to the https://smallrye.io/smallrye-reactive-messaging[SmallRye Reactive Messaging website] for further details.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Esta documentación no cubre todos los detalles del conector. Consulte el https://smallrye.io/smallrye-reactive-messaging[sitio web de SmallRye Reactive Messaging] para obtener más detalles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The AMQP connector allows Quarkus applications to send and receive messages using the AMQP 1.0 protocol.  More details about the protocol can be found in http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-overview-v1.0-os.html[the AMQP 1.0 specification].  It's important to note that AMQP 1.0 and AMQP 0.9.1 (implemented by RabbitMQ) are incompatible.  Check &lt;&lt;using-rabbitmq,Using RabbitMQ&gt;&gt; to get more details.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>El conector AMQP permite a las aplicaciones de Quarkus enviar y recibir mensajes utilizando el protocolo AMQP 1.0. Se pueden encontrar más detalles sobre el protocolo en http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-overview-v1.0-os.html[la especificación AMQP 1.0]. Es importante tener en cuenta que AMQP 1.0 y AMQP 0.9.1 (implementado por RabbitMQ) son incompatibles. Consulta &lt;&lt;using-rabbitmq,Usando RabbitMQ&gt;&gt; para obtener más detalles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To use the connector, you need to add the `quarkus-smallrye-reactive-messaging-amqp` extension.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Para utilizar el conector, es necesario añadir la extensión `quarkus-smallrye-reactive-messaging-amqp`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once added to your project, you can map _channels_ to AMQP addresses by configuring the `connector` attribute:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Una vez añadido a tu proyecto, puedes asignar _canales_ a direcciones AMQP configurando el atributo `connector`:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you have a single connector on your classpath, you can omit the `connector` attribute configuration.  Quarkus automatically associates _orphan_ channels to the (unique) connector found on the classpath.  _Orphans_ channels are outgoing channels without a downstream consumer or incoming channels without an upstream producer.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Si tiene un solo conector en su classpath, puede omitir la configuración del atributo `connector`. Quarkus asocia automáticamente los canales _huérfanos_ al conector (único) que se encuentra en el classpath. Los canales _huérfanos_ son canales salientes sin un consumidor descendente o canales entrantes sin un productor ascendente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The AMQP connector connects to AMQP 1.0 brokers such as Apache ActiveMQ or Artemis.  To configure the location and credentials of the broker, add the following properties in the `application.properties`:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>El conector AMQP se conecta a brokers AMQP 1.0 como Apache ActiveMQ o Artemis. Para configurar la ubicación y las credenciales del broker, añada las siguientes propiedades en la página `application.properties`:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's imagine your application receives `Message&lt;Double&gt;`.  You can consume the payload directly:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Imaginemos que tu aplicación recibe `Message&lt;Double&gt;`. Puede consumir la carga útil directamente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The connector converts incoming AMQP Messages into Reactive Messaging `Message&lt;T&gt;` instances.  `T` depends on the _body_ of the received AMQP Message.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>El conector convierte los mensajes AMQP entrantes en instancias de Reactive Messaging `Message&lt;T&gt;. `T` depende del _cuerpo_ del mensaje AMQP recibido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`byte[]`</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>`byte[]`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`List`</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>`List`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://vertx.io/docs/apidocs/io/vertx/core/json/JsonObject.html[`JsonObject`]</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>https://vertx.io/docs/apidocs/io/vertx/core/json/JsonObject.html[`JsonObject`]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you send objects with this AMQP connector (outbound connector), it gets encoded as JSON and sent as binary.  The `content-type` is set to `application/json`.  So, you can rebuild the object as follows:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Si envías objetos con este conector AMQP (conector de salida), se codifica como JSON y se envía como binario. La dirección `content-type` está configurada como `application/json`. Por lo tanto, puede reconstruir el objeto de la siguiente manera:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If a message produced from an AMQP message is _nacked_, a failure strategy is applied.  The AMQP connector supports six strategies:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Si un mensaje producido a partir de un mensaje AMQP es _nacked_, se aplica una estrategia de fallo. El conector AMQP soporta seis estrategias:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`fail` - fail the application; no more AMQP messages will be processed (default).  The AMQP message is marked as rejected.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>`fail` - falla la aplicación; no se procesarán más mensajes AMQP (por defecto). El mensaje AMQP se marca como rechazado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`accept` - this strategy marks the AMQP message as _accepted_. The processing continues ignoring the failure.  Refer to the http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-messaging-v1.0-os.html#type-accepted[accepted delivery state documentation].</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>`accept` - esta estrategia marca el mensaje AMQP como _aceptado_. El procesamiento continúa ignorando el fallo. Consulte la http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-messaging-v1.0-os.html#type-accepted[documentación sobre el estado de entrega] aceptado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`release` - this strategy marks the AMQP message as _released_. The processing continues with the next message. The broker can redeliver the message.  Refer to the http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-messaging-v1.0-os.html#type-released[released delivery state documentation].</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>`release` - esta estrategia marca el mensaje AMQP como _liberado_. El procesamiento continúa con el siguiente mensaje. El broker puede volver a entregar el mensaje. Consulte la http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-messaging-v1.0-os.html#type-released[documentación del estado de entrega liber]ado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`reject` - this strategy marks the AMQP message as rejected. The processing continues with the next message.  Refer to the http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-messaging-v1.0-os.html#type-rejected[rejected delivery state documentation].</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>`reject` - esta estrategia marca el mensaje AMQP como rechazado. El procesamiento continúa con el siguiente mensaje. Consulte la http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-messaging-v1.0-os.html#type-rejected[documentación del estado de entrega rechaz]ado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`modified-failed` - this strategy marks the AMQP message as _modified_ and indicates that it failed (with the `delivery-failed` attribute). The processing continues with the next message, but the broker may attempt to redeliver the message.  Refer to the http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-messaging-v1.0-os.html#type-modified[modified delivery state documentation]</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>`modified-failed` - esta estrategia marca el mensaje AMQP como _modificado_ e indica que ha fallado (con el atributo `delivery-failed` ). El procesamiento continúa con el siguiente mensaje, pero el broker puede intentar volver a entregar el mensaje. Consulte la http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-messaging-v1.0-os.html#type-modified[documentación sobre el estado de entrega modificado]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`modified-failed-undeliverable-here` - this strategy marks the AMQP message as _modified_ and indicates that it failed (with the `delivery-failed` attribute). It also indicates that the application cannot process the message, meaning that the broker will not attempt to redeliver the message to this node. The processing continues with the next message.  Refer to the http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-messaging-v1.0-os.html#type-modified[modified delivery state documentation]</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>`modified-failed-undeliverable-here` - esta estrategia marca el mensaje AMQP como _modificado_ e indica que ha fallado (con el atributo `delivery-failed` ). También indica que la aplicación no puede procesar el mensaje, lo que significa que el broker no intentará volver a entregar el mensaje a este nodo. El procesamiento continúa con el siguiente mensaje. Consulte la http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-messaging-v1.0-os.html#type-modified[documentación sobre el estado de entrega modificado]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When sending a `Message&lt;T&gt;`, the connector converts the message into an AMQP Message.  The payload is converted to the AMQP Message _body_.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Cuando se envía un `Message&lt;T&gt;`, el conector convierte el mensaje en un mensaje AMQP. La carga útil se convierte en el _cuerpo_ del mensaje AMQP.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://vertx.io/docs/apidocs/io/vertx/core/json/JsonObject.html[`JsonObject`] or https://vertx.io/docs/apidocs/io/vertx/core/json/JsonArray.html[`JsonArray`]</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>https://vertx.io/docs/apidocs/io/vertx/core/json/JsonObject.html[`JsonObject`] o  link:https://vertx.io/docs/apidocs/io/vertx/core/json/JsonArray.html[`JsonArray`]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.vertx.mutiny.core.buffer.Buffer`</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>`io.vertx.mutiny.core.buffer.Buffer`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When sending `Messages`, you can add an instance of `OutgoingAmqpMetadata` to influence how the message is going to be sent to AMQP.  For example, you can configure the subjects, properties:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Cuando se envía `Messages`, se puede añadir una instancia de `OutgoingAmqpMetadata` para influir en cómo se va a enviar el mensaje a AMQP. Por ejemplo, puedes configurar los asuntos, las propiedades:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sometimes it is desirable to select the destination of a message dynamically.  In this case, you should not configure the address inside your application configuration file, but instead, use the outbound metadata to set the address.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>A veces es conveniente seleccionar el destino de un mensaje de forma dinámica. En este caso, no debe configurar la dirección dentro del archivo de configuración de su aplicación, sino que debe utilizar los metadatos de salida para establecer la dirección.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, the Reactive Messaging `Message` is acknowledged when the broker acknowledged the message.  When using routers, this acknowledgement may not be enabled.  In this case, configure the `auto-acknowledgement` attribute to acknowledge the message as soon as it has been sent to the router.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Por defecto, la Mensajería Reactiva `Message` es reconocida cuando el broker reconoce el mensaje. Cuando se utilizan routers, este acuse de recibo puede no estar habilitado. En este caso, configure el atributo `auto-acknowledgement` para que acuse el mensaje tan pronto como se haya enviado al router.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The back-pressure is handled by AMQP _credits_.  The outbound connector only requests the amount of allowed credits.  When the amount of credits reaches 0, it waits (in a non-blocking fashion) until the broker grants more credits to the AMQP sender.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>La contrapresión se gestiona mediante _créditos_ AMQP. El conector de salida sólo solicita la cantidad de créditos permitidos. Cuando la cantidad de créditos llega a 0, espera (de forma no bloqueante) hasta que el broker conceda más créditos al emisor AMQP.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can configure the AMQP address using the `address` attribute:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Puedes configurar la dirección AMQP utilizando el atributo `address`:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To use an existing queue, you need to configure the `address`, `container-id` and, optionally, the `link-name` attributes.  For example, if you have an Apache Artemis broker configured with:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Para utilizar una cola existente, debe configurar los atributos `address`, `container-id` y, opcionalmente, `link-name`. Por ejemplo, si tienes un broker Apache Artemis configurado con:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You may need to configure the `link-name` attribute, if the queue name is not the channel name:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Es posible que tenga que configurar el atributo `link-name`, si el nombre de la cola no es el nombre del canal:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To use a `MULTICAST` queue, you need to provide the _FQQN_ (fully-qualified queue name) instead of just the name of the queue:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Para utilizar una cola de `MULTICAST`, es necesario proporcionar el _FQQN_ (nombre de cola totalmente calificado) en lugar de sólo el nombre de la cola:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reactive Messaging invokes your method on an I/O thread.  See the xref:quarkus-reactive-architecture.adoc[Quarkus Reactive Architecture documentation] for further details on this topic.  But, you often need to combine Reactive Messaging with blocking processing such as database interactions.  For this, you need to use the `@Blocking` annotation indicating that the processing is _blocking_ and should not be run on the caller thread.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>La mensajería reactiva invoca su método en un hilo de E/S. Consulta la xref:quarkus-reactive-architecture.html[documentación de la Arquitectura Reactiva de Quarkus] para más detalles sobre este tema. Pero, a menudo necesitas combinar la Mensajería Reactiva con el procesamiento de bloqueo, como las interacciones con la base de datos. Para ello, es necesario utilizar la anotación `@Blocking` indicando que el procesamiento es _de_ bloqueo y no debe ser ejecutado en el hilo de llamada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are 2 `@Blocking` annotations:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Hay 2 anotaciones en `@Blocking`:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.smallrye.reactive.messaging.annotations.Blocking`</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>`io.smallrye.reactive.messaging.annotations.Blocking`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.smallrye.common.annotation.Blocking`</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>`io.smallrye.common.annotation.Blocking`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>They have the same effect.  Thus, you can use both.  The first one provides more fine-grained tuning such as the worker pool to use and whether it preserves the order.  The second one, used also with other reactive features of Quarkus, uses the default worker pool and preserves the order.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Tienen el mismo efecto. Por lo tanto, puede utilizar ambos. El primero proporciona un ajuste más fino, como el grupo de trabajadores a utilizar y si preserva el orden. El segundo, utilizado también con otras características reactivas de Quarkus, utiliza el grupo de trabajadores por defecto y preserva el orden.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@Transactional</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>@Transactional</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If your method is annotated with `@Transactional`, it will be considered _blocking_ automatically, even if the method is not annotated with `@Blocking`.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Si su método está anotado con `@Transactional`, se considerará automáticamente _bloqueante_, incluso si el método no está anotado con `@Blocking`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The connector uses the Vert.x AMQP client underneath.  More details about this client can be found in the https://vertx.io/docs/vertx-amqp-client/java/[Vert.x website].</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>El conector utiliza el cliente AMQP de Vert.x por debajo. Puedes encontrar más detalles sobre este cliente en el https://vertx.io/docs/vertx-amqp-client/java/[sitio web de Vert.x].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This instance is retrieved and used to configure the client used by the connector.  You need to indicate the name of the client using the `client-options-name` attribute:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Esta instancia se recupera y se utiliza para configurar el cliente utilizado por el conector. Es necesario indicar el nombre del cliente utilizando el atributo `client-options-name`:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you use the AMQP connector with the `quarkus-smallrye-health` extension, it contributes to the readiness and liveness probes.  The AMQP connector reports the readiness and liveness of each channel managed by the connector.  At the moment, the AMQP connector uses the same logic for the readiness and liveness checks.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Si utilizas el conector AMQP con la extensión `quarkus-smallrye-health`, contribuye a las sondas de disponibilidad y vida. El conector AMQP informa de la disponibilidad y la capacidad de respuesta de cada canal gestionado por el conector. Por el momento, el conector AMQP utiliza la misma lógica para las comprobaciones de disponibilidad y vida.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To disable health reporting, set the `health-enabled` attribute for the channel to false.  On the inbound side (receiving messages from AMQP), the check verifies that the receiver is attached to the broker.  On the outbound side (sending records to AMQP), the check verifies that the sender is attached to the broker.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Para desactivar los informes de salud, establezca el atributo `health-enabled` para el canal en falso. En el lado de entrada (recepción de mensajes de AMQP), la comprobación verifica que el receptor está unido al broker. En el lado de salida (envío de registros a AMQP), la comprobación verifica que el remitente está unido al broker.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that a message processing failures nacks the message, which is then handled by the `failure-strategy`.  It the responsibility of the `failure-strategy` to report the failure and influence the outcome of the checks.  The `fail` failure strategy reports the failure, and so the check will report the fault.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Obsérvese que un fallo en el procesamiento de mensajes lo anula, lo cual es tratado por `failure-strategy`. Es responsabilidad de `failure-strategy` informar del fallo e influir en el resultado de las comprobaciones. La estrategia de fallos de `fail` informa del fallo, por lo que la comprobación informará del mismo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This connector is for AMQP 1.0. RabbitMQ implements AMQP 0.9.1.  RabbitMQ does not provide AMQP 1.0 by default, but there is a plugin for it.  To use RabbitMQ with this connector, enable and configure the AMQP 1.0 plugin.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Este conector es para AMQP 1.0. RabbitMQ implementa AMQP 0.9.1. RabbitMQ no proporciona AMQP 1.0 por defecto, pero existe un plugin para ello. Para utilizar RabbitMQ con este conector, active y configure el plugin AMQP 1.0.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Despite the existence of the plugin, a few AMQP 1.0 features won’t work with RabbitMQ.  Thus, we recommend the following configurations.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>A pesar de la existencia del plugin, algunas características de AMQP 1.0 no funcionan con RabbitMQ. Por lo tanto, recomendamos las siguientes configuraciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The AMQP connector supports https://cloudevents.io/[Cloud Events].  When the connector detects a _structured_ or _binary_ Cloud Events, it adds a `IncomingCloudEventMetadata&lt;T&gt;` into the metadata of the `Message`.  `IncomingCloudEventMetadata` contains accessors to the mandatory and optional Cloud Event attributes.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>El conector AMQP soporta  https://cloudevents.io/[Cloud Events]. Cuando el conector detecta un Cloud Events _estructurado_ o _binario_, añade un `IncomingCloudEventMetadata&lt;T&gt;` en los metadatos del `Message`. `IncomingCloudEventMetadata` contiene accesos a los atributos obligatorios y opcionales del Cloud Event.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The AMQP connector supports https://cloudevents.io/[Cloud Events].  The connector sends the outbound record as Cloud Events if:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>El conector AMQP es compatible con https://cloudevents.io/[Cloud Events]. El conector envía el registro de salida como Cloud Events si:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the message metadata contains an `io.smallrye.reactive.messaging.ce.OutgoingCloudEventMetadata` instance,</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>los metadatos del mensaje contienen una instancia de `io.smallrye.reactive.messaging.ce.OutgoingCloudEventMetadata`,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the channel configuration defines the `cloud-events-type` and `cloud-events-source` attributes.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>la configuración del canal define los atributos `cloud-events-type` y `cloud-events-source`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus specific configuration</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Configuración específica de Quarkus</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[.no-hyphens]#*address*#</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>[.no-hyphens]#*address*#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[.no-hyphens]#*auto-acknowledgement*#</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>[.no-hyphens]#*auto-acknowledgement*#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[.no-hyphens]#*broadcast*#</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>[.no-hyphens]#*broadcast*#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[.no-hyphens]#*client-options-name*#

[.no-hyphens]#_(amqp-client-options-name)_#</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>[.no-hyphens]#*client-options-name*#

[.no-hyphens]#_(amqp-client-options-name)_#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[.no-hyphens]#*connect-timeout*#

[.no-hyphens]#_(amqp-connect-timeout)_#</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>[.no-hyphens]#*connect-timeout*#

[.no-hyphens]#_(amqp-connect-timeout)_#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[.no-hyphens]#*container-id*#</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>[.no-hyphens]#*container-id*#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[.no-hyphens]#*durable*#</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>[.no-hyphens]#*durable*#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[.no-hyphens]#*failure-strategy*#</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>[.no-hyphens]#*failure-strategy*#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`fail`</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>`fail`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[.no-hyphens]#*health-timeout*#</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>[.no-hyphens]#*health-timeout*#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[.no-hyphens]#*host*#

[.no-hyphens]#_(amqp-host)_#</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>[.no-hyphens]#*host*#

[.no-hyphens]#_(amqp-host)_#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[.no-hyphens]#*link-name*#</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>[.no-hyphens]#*link-name*#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[.no-hyphens]#*password*#

[.no-hyphens]#_(amqp-password)_#</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>[.no-hyphens]#*password*#

[.no-hyphens]#_(amqp-password)_#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[.no-hyphens]#*port*#

[.no-hyphens]#_(amqp-port)_#</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>[.no-hyphens]#*port*#

[.no-hyphens]#_(amqp-port)_#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[.no-hyphens]#*reconnect-attempts*#

[.no-hyphens]#_(amqp-reconnect-attempts)_#</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>[.no-hyphens]#*reconnect-attempts*#

[.no-hyphens]#_(amqp-reconnect-attempts)_#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[.no-hyphens]#*reconnect-interval*#

[.no-hyphens]#_(amqp-reconnect-interval)_#</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>[.no-hyphens]#*reconnect-interval*#

[.no-hyphens]#_(amqp-reconnect-interval)_#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[.no-hyphens]#*sni-server-name*#

[.no-hyphens]#_(amqp-sni-server-name)_#</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>[.no-hyphens]#*sni-server-name*#

[.no-hyphens]#_(amqp-sni-server-name)_#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[.no-hyphens]#*use-ssl*#

[.no-hyphens]#_(amqp-use-ssl)_#</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>[.no-hyphens]#*use-ssl*#

[.no-hyphens]#_(amqp-use-ssl)_#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[.no-hyphens]#*username*#

[.no-hyphens]#_(amqp-username)_#</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>[.no-hyphens]#*username*#

[.no-hyphens]#_(amqp-username)_#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[.no-hyphens]#*virtual-host*#

[.no-hyphens]#_(amqp-virtual-host)_#</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>[.no-hyphens]#*virtual-host*#

[.no-hyphens]#_(amqp-virtual-host)_#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[.no-hyphens]#*credit-retrieval-period*#</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>[.no-hyphens]#*credit-retrieval-period*#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[.no-hyphens]#*ttl*#</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>[.no-hyphens]#*ttl*#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[.no-hyphens]#*use-anonymous-sender*#</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>[.no-hyphens]#*use-anonymous-sender*#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Maven</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Maven</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>NOTE</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>NOTA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the `quarkus-apicurio-registry-avro` extension is present, Dev Services for Apicurio Registry automatically starts an Apicurio Registry instance in dev mode and when running tests.  Also, all Kafka channels in SmallRye Reactive Messaging are automatically configured to use this registry.  (This automatic configuration of course only applies to serializers and deserializers from the Apicurio Registry Avro library.)</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Si la extensión `quarkus-apicurio-registry-avro` está presente, Dev Services for Apicurio Registry inicia automáticamente una instancia de Apicurio Registry en modo dev y al ejecutar pruebas. Además, todos los canales Kafka en SmallRye Reactive Messaging se configuran automáticamente para utilizar este registro. (Esta configuración automática, por supuesto, sólo se aplica a los serializadores y deserializadores de la biblioteca Avro de Apicurio Registry).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Enabling / Disabling Dev Services for Apicurio Registry</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Activación/desactivación de los servicios de desarrollo para el registro de Apicurio</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev Services for Apicurio Registry relies on Docker to start the registry.  If your environment does not support Docker, you will need to start the registry manually, or use an already running registry.  You can configure the registry URL for all Kafka channels in SmallRye Reactive Messaging with a single property:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Dev Services for Apicurio Registry se basa en Docker para iniciar el registro. Si su entorno no soporta Docker, tendrá que iniciar el registro manualmente, o utilizar un registro ya en funcionamiento. Puede configurar la URL del registro para todos los canales Kafka en SmallRye Reactive Messaging con una sola propiedad:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Most of the time you need to share the registry between applications.  Dev Services for Apicurio Registry implements a _service discovery_ mechanism for your multiple Quarkus applications running in _dev_ mode to share a single registry.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>La mayoría de las veces se necesita compartir el registro entre aplicaciones. Dev Services for Apicurio Registry implementa un mecanismo de _descubrimiento de servicios_ para que sus múltiples aplicaciones Quarkus que se ejecutan en modo _dev_ compartan un único registro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need multiple (shared) registries, you can configure the `quarkus.apicurio-registry.devservices.service-name` attribute and indicate the registry name.  It looks for a container with the same value, or starts a new one if none can be found.  The default service name is `apicurio-registry`.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Si necesitas varios registros (compartidos), puedes configurar el atributo `quarkus.apicurio-registry.devservices.service-name` e indicar el nombre del registro. Se busca un contenedor con el mismo valor, o se inicia uno nuevo si no se encuentra ninguno. El nombre de servicio por defecto es `apicurio-registry`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sharing is enabled by default in dev mode, but disabled in test mode.  You can disable the sharing with `quarkus.apicurio-registry.devservices.shared=false`.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>El uso compartido está activado por defecto en el modo de desarrollo, pero está desactivada en el modo de prueba. Puede desactivar el uso compartido con `quarkus.apicurio-registry.devservices.shared=false`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, Dev Services for Apicurio Registry picks a random port and configures the application.  You can set the port by configuring the `quarkus.apicurio-registry.devservices.port` property.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Por defecto, Dev Services for Apicurio Registry escoge un puerto al azar y configura la aplicación. Puede establecer el puerto configurando la propiedad `quarkus.apicurio-registry.devservices.port`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev Services for Apicurio Registry uses `apicurio/apicurio-registry-mem` images.  You can select any 2.x version from https://hub.docker.com/r/apicurio/apicurio-registry-mem:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Los servicios de desarrollo para el Registro de Apicurio utilizan imágenes de `apicurio/apicurio-registry-mem`. Puede seleccionar cualquier versión 2.x de https://hub.docker.com/r/apicurio/apicurio-registry-mem:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Read about xref:funqy.adoc[Funqy Basics].  This is a short read!</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Lea sobre xref:funqy.html[los fundamentos de Funqy]. Esta es una lectura corta!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Setting up Knative locally in a Minikube environment is beyond the scope of this guide.  It is advised to follow https://redhat-developer-demos.github.io/knative-tutorial/knative-tutorial/index.html[this] Knative Tutorial put together by Red Hat.  It walks through how to set up Knative on Minikube or OpenShift in a local environment.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Configurar Knative localmente en un entorno Minikube está más allá del alcance de esta guía. Se recomienda seguir https://redhat-developer-demos.github.io/knative-tutorial/knative-tutorial/index.html[este] tutorial de Knative elaborado por Red Hat. Se trata de cómo configurar Knative en Minikube u OpenShift en un entorno local.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The quickstart works by manually sending an HTTP request containing a Cloud Event to the Knative Broker using `curl`.  The Knative Broker receives the request and triggers the startup of the Funqy container built by the quickstart.  The event triggers the invocation of a chain of Funqy functions.  The output of one function triggers the invocation of another Funqy function.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>El quickstart funciona enviando manualmente una petición HTTP que contiene un Cloud Event al Knative Broker usando `curl`. El Broker Knative recibe la petición y desencadena el inicio del contenedor Funqy construido por el quickstart. El evento desencadena la invocación de una cadena de funciones Funqy. La salida de una función desencadena la invocación de otra función Funqy.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When living within a Knative Events environment, Funqy functions are triggered by a specific Cloud Event type.  You can have multiple Funqy functions within a single application/deployment, but they must be triggered by a specific Cloud Event Type.  The exception to this rule is if there is only one Funqy function in the application.  In that case, the event is pushed to that function irregardless of the Cloud Event type.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Cuando viven dentro de un entorno de Knative Events, las funciones de Funqy son activadas por un tipo de Evento de la Nube específico. Puede tener múltiples funciones Funqy dentro de una sola aplicación/despliegue, pero deben ser activadas por un Tipo de Evento de la Nube específico. La excepción a esta regla es si sólo hay una función Funqy en la aplicación. En ese caso, el evento es empujado a esa función independientemente del tipo de Evento en la Nube.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Currently, Funqy can only consume JSON-based data.  It supports both Binary and Structured mode of execution, but the data component of the Cloud Event message must be JSON.  This JSON must also be marshallable to and from the Java parameters and return types of your functions.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Actualmente, Funqy sólo puede consumir datos basados en JSON. Soporta tanto el modo de ejecución Binario como el Estructurado, pero el componente de datos del mensaje de Evento en la Nube debe ser JSON. Este JSON también debe ser marshallable hacia y desde los parámetros Java y los tipos de retorno de sus funciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's start looking at our quickstart code so that you can understand how Knative Events map to Funqy.  Open up {quickstarts-tree-url}/funqy-quickstarts/funqy-knative-events-quickstart/src/main/java/org/acme/funqy/SimpleFunctionChain.java[SimpleFunctionChain.java]</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Empecemos a ver nuestro código de inicio rápido para que puedas entender cómo los eventos Knative se asignan a Funqy. Abre {quickstarts-tree-url}/funqy-quickstarts/funqy-knative-events-quickstart/src/main/java/org/acme/funqy/SimpleFunctionChain.java[SimpleFunctionChain.java].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As is, a Funqy function has a default Cloud Event mapping.  By default, the Cloud Event type must match the function name for the function to trigger.  If the function returns output, the response is converted into a Cloud Event and returned to the Broker to be routed to other triggers.  The default Cloud Event type for this response is the function name + `.output`.  The default Cloud Event source is the function name.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Tal y como está, una función Funqy tiene un mapeo de Eventos en la Nube por defecto. Por defecto, el tipo de Cloud Event debe coincidir con el nombre de la función para que esta se active. Si la función devuelve una salida, la respuesta se convierte en un Evento en la Nube y se devuelve al Broker para que se dirija a otros activadores. El tipo de evento en la nube por defecto para esta respuesta es el nombre de la función + `.output`. La fuente de eventos en la nube por defecto es el nombre de la función.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So, for the `defaultChain` function, the Cloud Event type that triggers the function is `defaultChain`.  It generates a response that triggers a new Cloud Event whose type is `defaultChain.output` and the event source is `defaultChain`.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Así, para la función `defaultChain`, el tipo de Evento en la Nube que desencadena la función es `defaultChain`. Genera una respuesta que desencadena un nuevo Evento en la Nube cuyo tipo es `defaultChain.output` y el origen del evento es `defaultChain`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While the default mapping is simple, it might not always be feasible.  You can change this default mapping through configuration.  Let's look at the next function:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Aunque la asignación por defecto es sencilla, puede que no siempre sea factible. Puedes cambiar esta asignación por defecto a través de la configuración. Veamos la siguiente función:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this case, the configuration maps the incoming Cloud Event type `defaultChain.output` to the `configChain` function.  The `configChain` function maps its response to the `annotated` Cloud Event type, and the Cloud Event source `configChain`.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>En este caso, la configuración asigna el tipo de evento en la nube entrante `defaultChain.output` a la función `configChain`. La función `configChain` asigna su respuesta al tipo de Evento en la Nube `annotated`, y la fuente de Evento en la Nube `configChain`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Funqy Knative Events extension also has annotations to do this Cloud Event mapping to your functions.  Take a look at the `annotatedChain` method</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>La extensión Funqy Knative Events también tiene anotaciones para hacer este mapeo de Cloud Event a sus funciones. Echa un vistazo al método `annotatedChain`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you use the `@CloudEventMapping` annotation on your function you can map the Cloud Event type trigger and the Cloud Event response.  In this example the `annotatedChain` function will be triggered by the `annotated` Cloud Event type and the response will be mapped to a `lastChainLink` type and `annotated` Cloud Event source.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Si utilizas la anotación `@CloudEventMapping` en tu función, puedes asignar el desencadenamiento del tipo de Evento en la Nube y la respuesta del Evento en la Nube. En este ejemplo, la función `annotatedChain` será activada por el tipo de evento en la nube `annotated` y la respuesta se asignará a un tipo `lastChainLink` y a una fuente de evento en la nube `annotated`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So, if look at all the functions defined within `SimpleFunctionChain` you'll notice that one function triggers the next.  The last function that is triggered is `lastChainLink`.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Así pues, si observamos todas las funciones definidas en `SimpleFunctionChain` nos daremos cuenta de que una función desencadena la siguiente. La última función que se activa es `lastChainLink`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are two things to notice about this function.  One, it has no output.  Your functions are not required to return output.  Second, there is an additional `event` parameter to the function.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Hay dos cosas que hay que tener en cuenta sobre esta función. Una, no tiene salida. Sus funciones no están obligadas a devolver salida. Segundo, hay un parámetro adicional `event` a la función.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to know additional information about the incoming Cloud Event, you can inject the `io.quarkus.funqy.knative.events.CloudEvent` interface using the Funqy `@Context` annotation.  The `CloudEvent` interface exposes information about the triggering event.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Si desea conocer información adicional sobre el evento entrante de la nube, puede inyectar la interfaz `io.quarkus.funqy.knative.events.CloudEvent` utilizando la anotación Funqy `@Context`. La interfaz `CloudEvent` expone información sobre el evento desencadenante.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Funqy Knative Events support dev mode and unit testing using RestAssured.  You can invoke on Funqy Knative Events functions using the same invocation model as xref:funqy-http.adoc[Funqy HTTP] using normal HTTP requests, or Cloud Event Binary mode, or Structured Mode.  All invocation modes are supported at the same time.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Funqy Knative Events soporta el modo dev y las pruebas unitarias utilizando RestAssured. Puede invocar en las funciones de Funqy Knative Events usando el mismo modelo de invocación que xref:funqy-http.html[Funqy HTTP] usando peticiones HTTP normales, o el modo binario de Cloud Event, o el modo estructurado. Todos los modos de invocación están soportados al mismo tiempo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Funqy also works with Quarkus Dev mode!</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>¡Funqy también funciona con el modo Quarkus Dev!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Make sure to replace `yourAccountName` with your docker or quay account name when you run `docker build`.  The Dockerfile is a standard Quarkus dockerfile.  No special Knative magic.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Asegúrese de reemplazar `yourAccountName` con su nombre de cuenta docker o quay cuando ejecute `docker build`. El Dockerfile es un dockerfile estándar de Quarkus. No hay magia especial de Knative.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The first step is to set up the broker in our namespace.  Following is an example command from the the Knative cli.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>El primer paso es configurar el broker en nuestro espacio de nombres. A continuación se muestra un ejemplo de comando desde el cli de Knative.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The broker we have created is called `default`, this broker will receive the cloud events.  The broker is also referenced in the function YAML files.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>El broker que hemos creado se llama `default`, este broker recibirá los eventos de la nube. El broker también está referenciado en los archivos YAML de la función.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The second step is to define a Kubernetes/OpenShift service to point to the Docker image you created and pushed during build. Take a look at {quickstarts-tree-url}/funqy-quickstarts/funqy-knative-events-quickstart/src/main/k8s/funqy-service.yaml[funqy-service.yaml]</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>El segundo paso es definir un servicio Kubernetes/OpenShift que apunte a la imagen Docker que creaste y empujaste durante la construcción. Echa un vistazo a {quickstarts-tree-url}/funqy-quickstarts/funqy-knative-events-quickstart/src/main/k8s/funqy-service.yaml[funqy-service.yaml].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For our quickstart, one Kubernetes service will contain all functions. There's no reason you couldn't break up this quickstart into multiple different projects and deploy a service for each function.  For simplicity, and to show that you don't have to have a deployment per function, the quickstart combines everything into one project, image, and service.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Para nuestro inicio rápido, un servicio de Kubernetes contendrá todas las funciones. No hay ninguna razón por la que no se pueda dividir este inicio rápido en varios proyectos diferentes y desplegar un servicio para cada función. Para simplificar, y para mostrar que no es necesario tener un despliegue por función, el inicio rápido combina todo en un proyecto, imagen y servicio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The next step is to deploy Knative Event triggers for each of the event types. As noted in the code section, each Funqy function is mapped to a specific Cloud Event type.  You must create Knative Event triggers that map a Cloud Event and route it to a specific Kubernetes service.  We have 4 different triggers.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>El siguiente paso es desplegar los activadores de Knative Event para cada uno de los tipos de eventos. Como se ha indicado en la sección de código, cada función de Funqy se asigna a un tipo de evento de la nube específico. Debes crear desencadenantes Knative Event que mapeen un Cloud Event y lo dirijan a un servicio Kubernetes específico. Tenemos 4 disparadores diferentes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>{quickstarts-tree-url}/funqy-quickstarts/funqy-knative-events-quickstart/src/main/k8s/defaultChain-trigger.yaml[defaultChain-trigger.yaml]</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>{quickstarts-tree-url}/funqy-quickstarts/funqy-knative-events-quickstart/src/main/k8s/defaultChain-trigger.yaml[defaultChain-trigger.yaml]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `spec:filter:attributes:type` maps a Cloud Event type to the Kubernetes service defined in `spec:subscriber:ref`.  When a Cloud Event is pushed to the Broker, it will trigger the spin up of the service mapped to that event.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>`spec:filter:attributes:type` asigna un tipo de evento de nube al servicio de Kubernetes definido en `spec:subscriber:ref`. Cuando se envía un evento de la nube al corredor, se activará el giro del servicio asignado a ese evento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There's a trigger YAML file for each of our 4 Funqy functions.  Deploy them all:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Hay un archivo YAML de activación para cada una de nuestras 4 funciones Funqy. Despliégalos todos:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You'll need two different terminal windows.  One to do a curl request to the Broker, the other to watch the pod log files so you can see the messages flowing through the Funqy function event chain.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Necesitará dos ventanas de terminal diferentes. Una para hacer una petición curl al Broker, la otra para ver los archivos de registro del pod y así poder ver los mensajes que fluyen a través de la cadena de eventos de la función Funqy.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Make sure you have the `stern` tool installed.  See the Knative Tutorial setup for information on that.  Run stern to look for logs outputted by our Funqy deployment</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Asegúrese de que tiene instalada la herramienta `stern`. Consulta la configuración del Tutorial Knative para obtener información al respecto. Ejecuta stern para buscar los registros emitidos por nuestro despliegue de Funqy</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Open a separate terminal.  You'll first need to learn the URL of the broker.  Execute this command to find it.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Abra un terminal independiente. Primero tendrás que conocer la URL del broker. Ejecuta este comando para encontrarlo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Next thing we need to do is ssh into our Kubernetes cluster so that we can send a curl request to our broker.  Following command will create a simple OS pod so we can curl into our functions.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Lo siguiente que tenemos que hacer es ssh en nuestro clúster Kubernetes para que podamos enviar una solicitud curl a nuestro broker. El siguiente comando creará un simple pod OS para que podamos curl en nuestras funciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You will now be in a shell within the Kubernetes cluster.  Within the shell, execute this curl command , the broker address is an example and might differ based on your project or broker name.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Ahora estarás en un shell dentro del cluster de Kubernetes. Dentro del shell, ejecute este comando curl , la dirección del broker es un ejemplo y puede diferir según el nombre de su proyecto o broker.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This posts a Knative Event to the broker, which will trigger the `defaultChain` function.  As discussed earlier, the output of `defaultChain` triggers an event that is posted to `configChain` which triggers an event posted to `annotatedChain` then finally to the `lastChainLink` function.  You can see this flow in your `stern` window.  Something like this should be outputted.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Esto envía un Evento Knative al broker, que activará la función `defaultChain`. Como se ha comentado anteriormente, la salida de `defaultChain` desencadena un evento que se publica en `configChain`, que desencadena un evento publicado en `annotatedChain` y finalmente en la función `lastChainLink`. Puede ver este flujo en su ventana `stern`. Algo como esto debería salir.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To enable YAML configuration, add the `quarkus-config-yaml` extension:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Para activar la configuración de YAML, añada la extensión `quarkus-config-yaml`:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Remove the `src/main/resources/application.properties` and create a `src/main/resources/application.yaml` file.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Elimine el `src/main/resources/application.properties` y cree un archivo `src/main/resources/application.yaml`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus supports both the `yml` and `yaml` file extensions.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Quarkus admite las extensiones de archivo `yml` y `yaml`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Everything under the `"%test"` key is only enabled when the `test` profile is active. For example, in the previous snippet it disables OIDC (`quarkus.oidc.enabled: false`), whereas without the `test` profile, it would be enabled.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Todo lo que está bajo la clave `"%test"` sólo se habilita cuando el perfil `test` está activo. Por ejemplo, en el fragmento anterior desactiva OIDC ( `quarkus.oidc.enabled: false`), mientras que sin el perfil `test`, estaría activado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you enable the `staging` profile, the HTTP port will be 8082, whereas it would be 8081 otherwise.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Si habilita el perfil `staging`, el puerto HTTP será el 8082, mientras que en caso contrario sería el 8081.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The YAML configuration also support profile aware files. In this case, properties for a specific profile may reside in an `application-{profile}.yaml` named file. The previous example may be expressed as:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>La configuración YAML también admite archivos conscientes de los perfiles. En este caso, las propiedades de un perfil específico pueden residir en un archivo con nombre `application-{profile}.yaml`. El ejemplo anterior puede expresarse como:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>application-staging.yaml</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>application-staging.yaml</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can deploy your Lambda as a pure Java jar, or you can compile your project to a native image and deploy that for a smaller memory footprint and startup time.  Our integration also generates SAM deployment files that can be consumed by https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/what-is-sam.html[Amazon's SAM framework].</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Puede desplegar su Lambda como una jar de Java, o puede compilar su proyecto en una imagen nativa y desplegarla para obtener una menor huella de memoria y tiempo de inicio. Nuestra integración también genera archivos de despliegue SAM que pueden ser consumidos por https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/what-is-sam.html[el framework SAM de Amazon].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus has a different extension for each Gateway API.  The HTTP Gateway API is implemented within the `quarkus-amazon-lambda-http` extension.  The REST Gateway API is implemented within the `quarkus-amazon-lambda-rest` extension.  If you are confused on which Gateway product to use, Amazon has a https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-vs-rest.html[great guide] to help you navigate this decision.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Quarkus tiene una extensión diferente para cada API de Gateway. La API HTTP Gateway se implementa dentro de la extensión `quarkus-amazon-lambda-http`. La API REST Gateway se implementa dentro de la extensión `quarkus-amazon-lambda-rest`. Si estás confundido sobre qué producto Gateway utilizar, Amazon tiene una https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-vs-rest.html[excelente guía] para ayudarte a tomar esta decisión.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-sam-cli-install.html[AWS SAM CLI]</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-sam-cli-install.html[AWS SAM CLI]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide walks you through generating an example Java project via a Maven archetype.  Later on it walks through the structure of the project so you can adapt any existing projects you have to use Amazon Lambda.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Esta guía le acompaña a través de la generación de un proyecto Java de ejemplo a través de un arquetipo de Maven. Más adelante, le guiará por la estructura del proyecto para que pueda adaptar cualquier proyecto existente que tenga para utilizar Amazon Lambda.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Installing all the AWS bits is probably the most difficult thing about this guide.  Make sure that you follow all the steps for installing AWS SAM CLI.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Instalar todos los bits de AWS es probablemente lo más difícil de esta guía. Asegúrate de seguir todos los pasos para instalar AWS SAM CLI.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will compile the code and run the unit tests included within the generated project.  Unit testing is the same as any other Java project and does not require running on Amazon.  Quarkus dev mode is also available with this extension.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Esto compilará el código y ejecutará las pruebas unitarias incluidas en el proyecto generado. Las pruebas unitarias son las mismas que en cualquier otro proyecto Java y no requieren ser ejecutadas en Amazon. El modo Quarkus dev también está disponible con esta extensión.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are building on a non-Linux system, you will need to also pass in a property instructing quarkus to use a Docker build as Amazon Lambda requires Linux binaries.  You can do this by passing `-Dquarkus.native.container-build=true` to your build command.  This requires you to have Docker installed locally, however.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Si estás construyendo en un sistema que no es Linux, tendrás que pasar también una propiedad que indique a quarkus que utilice una construcción Docker, ya que Amazon Lambda requiere binarios Linux. Puedes hacer esto pasando `-Dquarkus.native.container-build=true` a tu comando de construcción. Sin embargo, esto requiere que tengas Docker instalado localmente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>After you run the build, there are a few extra files generated by the Quarkus lambda extension you are using.  These files are in the the build directory: `target/` for Maven, `build/` for Gradle.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Después de ejecutar la construcción, hay algunos archivos adicionales generados por la extensión lambda de Quarkus que estás utilizando. Estos archivos están en el directorio de construcción: `target/` para Maven, `build/` para Gradle.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In dev and test mode, Quarkus will start a mock AWS Lambda event server that will convert HTTP requests to the corresponding API Gateway event types and post them to the underlying Quarkus HTTP lambda environment for processing.  This simulates the AWS Lambda environment as much as possible locally without requiring tools like Docker and SAM CLI.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>En el modo de desarrollo y prueba, Quarkus iniciará un servidor de eventos AWS Lambda falso que convertirá las solicitudes HTTP en los tipos de eventos de API Gateway correspondientes y los enviará al entorno HTTP Lambda subyacente de Quarkus para su procesamiento. Esto simula el entorno de AWS Lambda tanto como sea posible localmente sin requerir herramientas como Docker y SAM CLI.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using Quarkus Dev Mode just invoke HTTP requests on `http://localhost:8080` as you normally would when testing your REST endpoints.  This request will hit the Mock Event Server and will be converted to the API Gateway json message that is consumed by the Quarkus Lambda Poll loop.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Cuando se utiliza el Modo Dev de Quarkus sólo hay que invocar peticiones HTTP en `http://localhost:8080` como lo harías normalmente al probar tus endpoints REST. Esta solicitud llegará al Servidor de Eventos Mock y se convertirá en el mensaje json de API Gateway que es consumido por el bucle Quarkus Lambda.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For testing, Quarkus starts up a separate Mock Event server under port 8081.  The default port for Rest Assured is automatically set to 8081 by Quarkus, so you don't have to worry about setting this up.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Para las pruebas, Quarkus inicia un servidor de Eventos Mock separado bajo el puerto 8081. El puerto por defecto para Rest Assured se establece automáticamente en 8081 por Quarkus, por lo que no tiene que preocuparse de configurar esto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to simulate more complex API Gateway events in your tests, then manually do an HTTP POST to `http://localhost:8080/\_lambda_` (port 8081 in test mode) with the raw API Gateway json events.  These events will be placed directly on the Quarkus Lambda poll loop for processing.  Here's an example of that:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Si quieres simular eventos más complejos de la API Gateway en tus pruebas, entonces haz manualmente un HTTP POST a `http://localhost:8080/_lambda_` (puerto 8081 en modo de prueba) con los eventos json de API Gateway sin procesar. Estos eventos se colocarán directamente en el bucle de Quarkus Lambda para su procesamiento. Aquí hay un ejemplo de eso:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to hand code raw events for the AWS HTTP API, the AWS Lambda library has the request event type which is `com.amazonaws.services.lambda.runtime.events.APIGatewayV2HTTPEvent` and the response event type of `com.amazonaws.services.lambda.runtime.events.APIGatewayV2HTTPResponse`.  This corresponds to the `quarkus-amazon-lambda-http` extension and the AWS HTTP API.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Si desea codificar a mano eventos sin procesar para la API de AWS HTTP, la biblioteca de AWS Lambda tiene el tipo de evento de solicitud que es `com.amazonaws.services.lambda.runtime.events.APIGatewayV2HTTPEvent` y el tipo de evento de respuesta de `com.amazonaws.services.lambda.runtime.events.APIGatewayV2HTTPResponse`. Esto corresponde a la extensión `quarkus-amazon-lambda-http` y a la API de AWS HTTP.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to hand code raw events for the AWS REST API, Quarkus has its own implementation: `io.quarkus.amazon.lambda.http.model.AwsProxyRequest` and `io.quarkus.amazon.lambda.http.model.AwsProxyResponse`.  This corresponds to `quarkus-amazon-lambda-rest` extension and the AWS REST API.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Si quieres codificar a mano los eventos en bruto para la API de AWS REST, Quarkus tiene su propia implementación: `io.quarkus.amazon.lambda.http.model.AwsProxyRequest` y `io.quarkus.amazon.lambda.http.model.AwsProxyResponse`. Esto corresponde a la extensión `quarkus-amazon-lambda-rest` y a la API REST de AWS.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The AWS SAM CLI allows you to run your lambda's locally on your laptop in a simulated Lambda environment.  This requires Docker to be installed.  After you have built your Maven project, execute this command:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>La CLI de AWS SAM le permite ejecutar sus lambdas localmente en su portátil en un entorno de lambda simulado. Esto requiere que Docker esté instalado. Después de haber construido su proyecto Maven, ejecute este comando:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>http://127.0.0.1:3000/hello</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>http://127.0.0.1:3000/hello</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the console you'll see startup messages from the lambda.  This particular deployment starts a JVM and loads your lambda as pure Java.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>En la consola verás los mensajes de inicio de la lambda. Este despliegue particular inicia una JVM y carga tu lambda como Java puro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Answer all the questions and your lambda will be deployed and the necessary hooks to the API Gateway will be set up. If everything deploys successfully, the root URL of your microservice will be output to the console.  Something like this:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Responde a todas las preguntas y tu lambda se desplegará y se configurarán los hooks necesarios para el API Gateway. Si todo se despliega con éxito, la URL raíz de tu microservicio se mostrará en la consola. Algo así:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Responses for binary types will be automatically encoded with base64.  This is different than the behavior using `quarkus:dev` which will return the raw bytes.  Amazon's API has additional restrictions requiring the base64 encoding.  In general, client code will automatically handle this encoding but in certain custom situations, you should be aware you may need to manually manage that encoding.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Las respuestas para los tipos binarios se codificarán automáticamente con base64. Esto es diferente al comportamiento usando `quarkus:dev` que devolverá los bytes sin procesar. La API de Amazon tiene restricciones adicionales que requieren la codificación base64. En general, el código del cliente manejará automáticamente esta codificación, pero en ciertas situaciones personalizadas, debes tener en cuenta que puedes necesitar manejar manualmente esa codificación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is nothing special about the POM other than the inclusion of the `quarkus-amazon-lambda-http` extension (if you are deploying an AWS Gateway HTTP API) or the `quarkus-amazon-lambda-rest` extension (if you are deploy an AWS Gateway REST API).  These extensions automatically generate everything you might need for your lambda deployment.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>No hay nada especial en el POM aparte de la inclusión de la extensión `quarkus-amazon-lambda-http` (si está implementando una API HTTP de AWS Gateway) o la extensión `quarkus-amazon-lambda-rest` (si está implementando una API REST de AWS Gateway). Estas extensiones generan automáticamente todo lo que pueda necesitar para su implementación de Lambda.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `sam.yaml` syntax is beyond the scope of this document.  There's a couple of things that must be highlighted just in case you are going to craft your own custom `sam.yaml` deployment files.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>La sintaxis de `sam.yaml` está fuera del alcance de este documento. Hay un par de cosas que hay que resaltar en caso de que vayas a elaborar tus propios archivos de despliegue personalizados de `sam.yaml`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The first thing to note is that for pure Java lambda deployments require a specific handler class.  Do not change the Lambda handler name.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Lo primero que hay que tener en cuenta es que para las implantaciones de lambda en Java puro se requiere una clase manejadora específica. No cambie el nombre del manejador Lambda.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to go native, there's an environment variable that must be set for native GraalVM deployments.  If you look at `sam.native.yaml` you'll see this:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Si quieres ir de forma nativa, hay una variable de entorno que se debe establecer para los despliegues nativos de GraalVM. Si miras en `sam.native.yaml` verás esto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, there is one specific thing for AWS Gateway REST API deployments.  That API assumes that HTTP response bodies are text unless you explicitly tell it which media types are binary through configuration.  To make things easier, the Quarkus extension forces a binary (base 64) encoding of all HTTP response messages and the `sam.yaml` file must configure the API Gateway to assume all media types are binary:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Por último, hay una cosa específica para las implementaciones de la API REST de AWS Gateway. Esa API asume que los cuerpos de las respuestas HTTP son texto, a menos que se le indique explícitamente qué tipos de medios son binarios mediante la configuración. Para facilitar las cosas, la extensión de Quarkus fuerza una codificación binaria (base 64) de todos los mensajes de respuesta HTTP y el archivo `sam.yaml` debe configurar la API Gateway para asumir que todos los tipos de medios son binarios:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For the AWS HTTP API you can inject the AWS variables `com.amazonaws.services.lambda.runtime.Context` and `com.amazonaws.services.lambda.runtime.events.APIGatewayV2HTTPEvent`.  Here is an example:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Para la API HTTP de AWS puedes inyectar las variables de AWS `com.amazonaws.services.lambda.runtime.Context` y `com.amazonaws.services.lambda.runtime.events.APIGatewayV2HTTPEvent`. Aquí tienes un ejemplo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For the AWS REST API you can inject the AWS variables `com.amazonaws.services.lambda.runtime.Context` and `io.quarkus.amazon.lambda.http.model.AwsProxyRequestContext`.  Here is an example:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Para la API de AWS REST puedes inyectar las variables de AWS `com.amazonaws.services.lambda.runtime.Context` y `io.quarkus.amazon.lambda.http.model.AwsProxyRequestContext`. Aquí tienes un ejemplo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are building native images, and want to use https://aws.amazon.com/xray[AWS X-Ray Tracing] with your lambda you will need to include `quarkus-amazon-lambda-xray` as a dependency in your pom.  The AWS X-Ray library is not fully compatible with GraalVM so we had to do some integration work to make this work.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Si estás construyendo imágenes nativas, y quieres usar https://aws.amazon.com/xray[AWS X-Ray Tracing] con tu lambda necesitarás incluir `quarkus-amazon-lambda-xray` como una dependencia en tu pom. La biblioteca de AWS X-Ray no es totalmente compatible con GraalVM, por lo que hemos tenido que hacer un trabajo de integración para que funcione.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you invoke an HTTP request on the API Gateway, the Gateway turns that HTTP request into a JSON event document that is forwarded to a Quarkus Lambda.  The Quarkus Lambda parses this json and converts in into an internal representation of an HTTP request that can be consumed by any HTTP framework Quarkus supports (JAX-RS, servlet, Reactive Routes).</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Cuando se invoca una solicitud HTTP en la pasarela de la API, la pasarela convierte esa solicitud HTTP en un documento de evento JSON que se reenvía a un Quarkus Lambda. La Lambda de Quarkus analiza este json y lo convierte en una representación interna de una solicitud HTTP que puede ser consumida por cualquier marco HTTP que Quarkus admita (JAX-RS, servlet, Rutas Reactivas).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>API Gateway supports many different ways to securely invoke on your HTTP endpoints that are backed by Lambda and Quarkus.  If you enable it, Quarkus will automatically parse relevant parts of the https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-lambda.html[event json document] and look for security based metadata and register a `java.security.Principal` internally that can be looked up in JAX-RS by injecting a `javax.ws.rs.core.SecurityContext`, via `HttpServletRequest.getUserPrincipal()` in servlet, and `RouteContext.user()` in Reactive Routes.  If you want more security information, the `Principal` object can be typecast to a class that will give you more information.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>API Gateway admite muchas formas diferentes de invocar de forma segura en sus puntos finales HTTP que están respaldados por Lambda y Quarkus. Si lo habilitas, Quarkus analizará automáticamente las partes relevantes del https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-lambda.html[documento json] del evento y buscará metadatos basados en la seguridad y registrará un `java.security.Principal` internamente que puede ser buscado en JAX-RS inyectando un `javax.ws.rs.core.SecurityContext`, a través de `HttpServletRequest.getUserPrincipal()` en servlet, y `RouteContext.user()` en Reactive Routes. Si quieres más información de seguridad, el objeto `Principal` puede ser typecast a una clase que te dará más información.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To enable this security feature, add this to your `application.properties` file:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Para activar esta función de seguridad, añada esto a su archivo `application.properties`:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>HTTP `quarkus-amazon-lambda-http`</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>HTTP `quarkus-amazon-lambda-http`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Cognito JWT</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Cognito JWT</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkus.amazon.lambda.http.CognitoPrincipal`</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>`io.quarkus.amazon.lambda.http.CognitoPrincipal`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`requestContext.authorizer.jwt.claims.cognito:username`</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>`requestContext.authorizer.jwt.claims.cognito:username`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkus.amazon.lambda.http.IAMPrincipal`</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>`io.quarkus.amazon.lambda.http.IAMPrincipal`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`requestContext.authorizer.iam.userId`</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>`requestContext.authorizer.iam.userId`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkus.amazon.lambda.http.CustomPrincipal`</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>`io.quarkus.amazon.lambda.http.CustomPrincipal`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`requestContext.authorizer.lambda.principalId`</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>`requestContext.authorizer.lambda.principalId`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>REST `quarkus-amazon-lambda-rest`</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>REST `quarkus-amazon-lambda-rest`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Cognito</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Cognito</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`requestContext.authorizer.claims.cognito:username`</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>`requestContext.authorizer.claims.cognito:username`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`requestContext.identity.user`</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>`requestContext.identity.user`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`requestContext.authorizer.principalId`</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>`requestContext.authorizer.principalId`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The default support for AWS security only maps the principal name to Quarkus security APIs and does nothing to map claims or roles or permissions.  You have can full control how security metadata in the lambda HTTP event is mapped to Quarkus security APIs using implementations of the `io.quarkus.amazon.lambda.http.LambdaIdentityProvider` interface.  By implementing this interface, you can do things like define role mappings for your principal or publish additional attributes provided by IAM or Cognito or your Custom Lambda security integration.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>El soporte por defecto para la seguridad de AWS sólo asigna el nombre principal a las API de seguridad de Quarkus y no hace nada para asignar reclamaciones, funciones o permisos. Usted puede controlar completamente cómo se asignan los metadatos de seguridad en el evento HTTP lambda a las API de seguridad de Quarkus utilizando implementaciones de la interfaz `io.quarkus.amazon.lambda.http.LambdaIdentityProvider`. Al implementar esta interfaz, puede hacer cosas como definir asignaciones de roles para su director o publicar atributos adicionales proporcionados por IAM o Cognito o su integración de seguridad Lambda personalizada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For HTTP, the important method to override is `LambdaIdentityProvider.authenticate(APIGatewayV2HTTPEvent event)`.  From this you will allocate a SecurityIdentity based on how you want to map security data from `APIGatewayV2HTTPEvent`</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>En el caso de HTTP, el método importante a anular es `LambdaIdentityProvider.authenticate(APIGatewayV2HTTPEvent event)`. A partir de él, asignarás una SecurityIdentity basada en cómo quieres asignar los datos de seguridad de `APIGatewayV2HTTPEvent`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For REST, the important method to override is `LambdaIdentityProvider.authenticate(AwsProxyRequest event)`.  From this you will allocate a SecurityIdentity based on how you want to map security data from `AwsProxyRequest`.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Para REST, el método importante que hay que anular es `LambdaIdentityProvider.authenticate(AwsProxyRequest event)`. A partir de esto, asignarás una SecurityIdentity basada en cómo quieres asignar los datos de seguridad de `AwsProxyRequest`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Your implemented provider must be a CDI bean.  Here's an example:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Su proveedor implementado debe ser un bean CDI. He aquí un ejemplo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Simple SAM Local Principal</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Simple SAM Local Principal</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are testing your application with `sam local` you can hardcode a principal name to use when your application runs by setting the `QUARKUS_AWS_LAMBDA_FORCE_USER_NAME` environment variable</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Si está probando su aplicación con `sam local`, puede codificar un nombre principal para utilizarlo cuando se ejecute su aplicación, estableciendo la variable de entorno `QUARKUS_AWS_LAMBDA_FORCE_USER_NAME`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Lastly, the `producer` will read the quotes and send them to the browser using server-sent events.  The user will therefore see the quote price updated from _pending_ to the received price in real-time.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Por último, `producer` leerá las cotizaciones y las enviará al navegador mediante eventos enviados por el servidor. Así, el usuario verá cómo se actualiza el precio de la cotización desde el _pendiente_ hasta el recibido en tiempo real.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We recommend that you follow the instructions in the next sections and create applications step by step.  However, you can go right to the completed example.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Le recomendamos que siga las instrucciones de las siguientes secciones y cree las aplicaciones paso a paso. Sin embargo, puede ir directamente al ejemplo completado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To create the _producer_ project, in a terminal run:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Para crear el proyecto _productor_, en un terminal ejecute:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To create the _processor_ project, from the same directory, run:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Para crear el proyecto del _procesador_, desde el mismo directorio, ejecute:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@RegisterForReflection</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>@RegisterForReflection</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `@RegisterForReflection` annotation instructs Quarkus to include the class (including fields and methods) when building the native executable.  This will be useful later when we run the applications as native executables inside containers.  Without, the native compilation would remove the fields and methods during the dead-code elimination phase.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>La anotación `@RegisterForReflection` indica a Quarkus que incluya la clase (incluyendo los campos y métodos) cuando construya el ejecutable nativo. Esto será útil más adelante cuando ejecutemos las aplicaciones como ejecutables nativos dentro de contenedores. Sin ella, la compilación nativa eliminaría los campos y métodos durante la fase de eliminación del código muerto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inject a Reactive Messaging `Emitter` to send messages to the `quote-requests` channel.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Inyectar una Mensajería Reactiva `Emitter` para enviar mensajes al canal `quote-requests`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`mp.messaging.[outgoing|incoming].{channel-name}.property=value`</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>`mp.messaging.[outgoing|incoming].{channel-name}.property=value`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Back to our `producer` project.  Let's modify the `QuotesResource` to consume quotes, bind it to an HTTP endpoint to send events to clients:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Volvamos a nuestro proyecto `producer`. Vamos a modificar el `QuotesResource` para consumir citas, enlazarlo a un endpoint HTTP para enviar eventos a los clientes:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create inside the `producer` project `src/main/resources/META-INF/resources/quotes.html` file, with the following content:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Cree dentro del proyecto `producer` el archivo `src/main/resources/META-INF/resources/quotes.html`, con el siguiente contenido:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Nothing spectacular here.  On each received quote, it updates the page.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>No hay nada espectacular aquí. En cada cotización recibida, actualiza la página.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once packaged, run `docker compose up --build`.  The UI is exposed on http://localhost:8080/quotes.html</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Una vez empaquetado, ejecute `docker compose up --build`. La interfaz de usuario se expone en http://localhost:8080/quotes.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `-Dquarkus.native.container-build=true` instructs Quarkus to build Linux 64bits native executables, who can run inside containers.  Then, run the system using:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>El `-Dquarkus.native.container-build=true` instruye a Quarkus para construir ejecutables nativos de Linux 64bits, que pueden ejecutarse dentro de contenedores. Luego, ejecuta el sistema usando:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As before, the UI is exposed on http://localhost:8080/quotes.html</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Como antes, la interfaz de usuario está expuesta en http://localhost:8080/quotes.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://docs.microsoft.com/en-us/azure/aks/tutorial-kubernetes-deploy-cluster?WT.mc_id=opensource-quarkus-brborges[Tutorial: Deploy an Azure Kubernetes Service (AKS) cluster]</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>https://docs.microsoft.com/en-us/azure/aks/tutorial-kubernetes-deploy-cluster?WT.mc_id=opensource-quarkus-brborges[Tutorial: Despliegue de un clúster de Azure Kubernetes Service (AKS)]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use xref:funqy-http.adoc[Funqy HTTP] on Azure Functions.  This allows you to invoke on multiple Funqy functions using HTTP deployed as one Azure Function.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Puede utilizar xref:funqy-http.html[Funqy HTTP] en Azure Functions. Esto le permite invocar múltiples funciones de Funqy utilizando HTTP desplegado como una sola función de Azure.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Funqy HTTP + Azure Functions binding is not a replacement for REST over HTTP.  Because Funqy needs to be portable cross a lot of different protocols and function providers its HTTP binding is very minimalistic and you will lose REST features like linking and the ability to leverage HTTP features like cache-control and conditional GETs.  You may want to consider using Quarkus's JAX-RS, Spring MVC, or Vert.x Web Reactive Route xref:azure-functions-http.adoc[support] instead.  They also work with Quarkus and Azure Functions.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>El enlace Funqy HTTP + Azure Functions no es un sustituto de REST sobre HTTP. Debido a que Funqy necesita ser portátil a través de un montón de diferentes protocolos y proveedores de funciones, su enlace HTTP es muy minimalista y perderá las características de REST como la vinculación y la capacidad de aprovechar las características de HTTP como el control de caché y GETs condicionales. Es posible que desee considerar el uso de JAX-RS de Quarkus, Spring MVC, o el xref:azure-functions-http.html[soporte de.x Web Reactive Route en su lugar. También funcionan con Quarkus y Azure Functions.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Follow the xref:azure-functions-http.adoc[Azure Functions HTTP Guide].  It walks through using a variety of HTTP frameworks on Azure Functions.  Including Funqy.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Siga la xref:azure-functions-http.html[Guía HTTP] de Azure Functions. Explora el uso de una variedad de frameworks HTTP en Azure Functions. Incluyendo Funqy.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In which cases could conditional dependencies be useful? A typical example would be a component that should be activated **only** in case all of its required dependencies are available. If one or more of the component's required dependencies aren't available, instead of failing, the component should simply not be activated.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>¿En qué casos podrían ser útiles las dependencias condicionales? Un ejemplo típico sería un componente que debe activarse **sólo** en caso de que todas sus dependencias requeridas estén disponibles. Si una o más de las dependencias necesarias del componente no están disponibles, en lugar de fallar, el componente simplemente no debería activarse.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>runtime Quarkus extension artifact ID, in our example `quarkus-extension-b`;</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>ID del artefacto de extensión de Quarkus en tiempo de ejecución, en nuestro ejemplo `quarkus-extension-b`;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>an artifact key (in the format of `groupId:artifactId[:&lt;classifier&gt;:&lt;extension&gt;]` but typically simply `&lt;groupId&gt;:&lt;artifactId&gt;`) of the artifact that must be present among the application dependencies for the condition to be satisfied.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>una clave de artefacto (con el formato de `groupId:artifactId[:&lt;classifier&gt;:&lt;extension&gt;]`, pero normalmente es simplemente `&lt;groupId&gt;:&lt;artifactId&gt;`) del artefacto que debe estar presente entre las dependencias de la aplicación para que se cumpla la condición.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>runtime Quarkus extension artifact ID, in our example `quarkus-extension-a`</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>ID del artefacto de extensión de Quarkus en tiempo de ejecución, en nuestro ejemplo `quarkus-extension-a`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn how to create a Hello World Quarkus app.  This guide covers:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Aprende como crear una aplicación Hello World de Quarkus. Esta guía cubre:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you have multiple JDK's installed it is not certain Maven will pick up the expected java and you could end up with unexpected results.  You can verify which JDK Maven uses by running `mvn --version`.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Si tienes varios JDK's instalados no es seguro que Maven use el java esperado y podrías terminar con resultados inesperados. Puedes verificar qué JDK utiliza Maven ejecutando `mvn --version`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we create a straightforward application serving a `hello` endpoint. To demonstrate dependency injection, this endpoint uses a `greeting` bean.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>En esta guía, creamos una aplicación sencilla que sirve un endpoint de `hello`. Para demostrar la inyección de dependencias, este endpoint utiliza un bean `greeting`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If using Powershell , wrap `-D` parameters in double quotes e.g. `"-DprojectArtifactId=getting-started"`</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Si utiliza Powershell, envuelva los parámetros de `-D` entre comillas dobles, por ejemplo `"-DprojectArtifactId=getting-started"`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>a landing page that is accessible on `http://localhost:8080` after starting the application</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>una página inicial que es accesible en `&amp;lt;a href="http://localhost:8080" class="bare"&amp;gt;http://localhost:8080&amp;lt;/a&amp;gt;` después de iniciar la aplicación</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once generated, look at the `pom.xml`.  You will find the import of the Quarkus BOM, allowing you to omit the version of the different Quarkus dependencies.  In addition, you can see the `quarkus-maven-plugin` responsible of the packaging of the application and also providing the development mode.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Una vez generado, mira el `pom.xml`. Encontrarás la importación Quarkus BOM, permitiendo omitir la versión de las diferentes dependencias de Quarkus. Además, se puede ver el `quarkus-maven-plugin` responsable del empaquetado de la aplicación y también proporcionar el modo de desarrollo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With Quarkus, there is no need to create an `Application` class. It's supported, but not required. In addition, only one instance of the resource is created and not one per request. You can configure this using the different `*Scoped` annotations (`ApplicationScoped`, `RequestScoped`, etc).</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Con Quarkus, no es necesario crear una clase `Application`. Se admite, pero no se requiere. Además, solo se crea una instancia del recurso y no una por solicitud. Esto se puede configurar utilizando las diferentes anotaciones de `*Scoped` ( `ApplicationScoped`, `RequestScoped`, etc).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dependency injection in Quarkus is based on ArC which is a CDI-based dependency injection solution tailored for Quarkus' architecture.  If you're new to CDI then we recommend you to read the xref:cdi.adoc[Introduction to CDI] guide.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>La inyección de dependencias en Quarkus se basa en ArC, que es una solución de inyección de dependencias basada en CDI y adaptada a la arquitectura de Quarkus. Si eres nuevo en CDI, te recomendamos que leas la guía de xref:cdi.adoc[Introduction to CDI].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's modify the application and add a companion bean.  Create the `src/main/java/org/acme/GreetingService.java` file with the following content:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Vamos a modificar la aplicación y a añadir un bean de acompañamiento. Crea el archivo `src/main/java/org/acme/GreetingService.java` con el siguiente contenido:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus:dev` runs Quarkus in development mode. This enables live reload with background compilation, which means that when you modify your Java files and/or your resource files and refresh your browser, these changes will automatically take effect.  This works too for resource files like the configuration property file.  Refreshing the browser triggers a scan of the workspace, and if any changes are detected, the Java files are recompiled and the application is redeployed; your request is then serviced by the redeployed application. If there are any issues with compilation or deployment an error page will let you know.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>`quarkus:dev` ejecuta Quarkus en modo de desarrollo. Esto permite la recarga en vivo con compilación en segundo plano, lo que significa que cuando se modifican los archivos Java y/o los archivos de recursos y se actualiza el navegador, estos cambios tendrán efecto automáticamente. Esto funciona también para los archivos de recursos como el archivo de propiedades de configuración. Al actualizar el navegador, se realiza un análisis del área de trabajo y, si se detecta algún cambio, se recopilaran los archivos Java y se vuelve a desplegar la aplicación; la solicitud se atiende entonces con la aplicación re-desplegada. Si hay algún problema con la compilación o el despliegue, una página de error le informará.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus supports https://junit.org/junit5/[JUnit 5] tests.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Quarkus es compatible con las pruebas de https://junit.org/junit5/[JUnit 5].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Because of this, in the case of Maven, the version of the https://maven.apache.org/surefire/maven-surefire-plugin/[Surefire Maven Plugin] must be set, as the default version does not support JUnit 5:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Debido a esto, en el caso de Maven, se debe establecer la versión del https://maven.apache.org/surefire/maven-surefire-plugin/[Surefire Maven Plugin], ya que la versión por defecto no soporta JUnit 5:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The generated project contains a simple test.  Edit the `src/test/java/org/acme/GreetingResourceTest.java` to match the following content:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>El proyecto generado contiene una prueba sencilla. Edite el `src/test/java/org/acme/GreetingResourceTest.java` para que coincida con el siguiente contenido:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By using the `QuarkusTest` runner, you instruct JUnit to start the application before the tests.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Utilizando el runner `QuarkusTest`, se indica a JUnit que inicie la aplicación antes que las pruebas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The test port can be controlled via the `quarkus.http.test-port` config property. Quarkus also creates a system property called `test.url` that is set to the base test URL for situations where you cannot use injection.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>El puerto de prueba puede ser controlado a través de la propiedad de configuración `quarkus.http.test-port`. Quarkus también crea una propiedad del sistema llamada `test.url` que se establece en la URL de prueba base para situaciones en las que no se puede utilizar la inyección.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus heavily utilizes https://github.com/wildfly/jandex[Jandex] at build time, to discover various classes or annotations. One immediately recognizable application of this, is CDI bean discovery.  As a result, most of the Quarkus extensions will not work properly if this build time discovery isn't properly setup.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Quarkus utiliza en gran medida https://github.com/wildfly/jandex[Jandex] en tiempo de construcción, para descubrir varias clases o anotaciones. Una aplicación inmediatamente reconocible de esto, es el descubrimiento de bean CDI. Como resultado, la mayoría de las extensiones de Quarkus no funcionarán correctamente si este descubrimiento en tiempo de construcción no está configurado correctamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>However, when working with a multi-module project, be sure to read the `Working with multi-module projects` section of the xref:maven-tooling.adoc#multi-module-maven[Maven] or xref:gradle-tooling.adoc#multi-module-maven[Gradle] guides.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Sin embargo, cuando trabajes con un proyecto multimódulo, asegúrate de leer la sección `Working with multi-module projects` de las guías de xref:maven-tooling.adoc#multi-module-maven[Maven] o xref:gradle-tooling.adoc#multi-module-maven[Gradle] </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you plan to use external modules (for example, an external library for all your domain objects), you will need to make these modules known to the indexing process either by adding the Jandex plugin (if you can modify them)  or via the `quarkus.index-dependency` property inside your `application.properties` (useful in cases where you can't modify the module).</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Si tiene previsto utilizar módulos externos (por ejemplo, una biblioteca externa para todos sus objetos de dominio), tendrá que dar a conocer estos módulos al proceso de indexación, ya sea añadiendo el plugin de Jandex (si puede modificarlos) o a través de la propiedad `quarkus.index-dependency` dentro de su `application.properties` (útil en los casos en que no pueda modificar el módulo).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the `quarkus-app` directory which contains the `quarkus-run.jar` jar file - being an executable _jar_. Be aware that it's not an _über-jar_ as the dependencies are copied into subdirectories of `quarkus-app/lib/`.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>el directorio `quarkus-app` que contiene el archivo jar `quarkus-run.jar` - siendo un _jar_ ejecutable. Tenga en cuenta que no es un _über-jar_ ya que las dependencias se copian en subdirectorios de `quarkus-app/lib/`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to deploy your application somewhere (typically in a container), you need to deploy the whole `quarkus-app` directory.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Si quieres desplegar tu aplicación en algún lugar (normalmente en un contenedor), necesitas desplegar todo el directorio `quarkus-app`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default when a Quarkus application starts (in regular or dev mode), it will display an ASCII art banner. The banner can be disabled by setting `quarkus.banner.enabled=false` in `application.properties`, by setting the `-Dquarkus.banner.enabled=false` Java System Property, or by setting the `QUARKUS_BANNER_ENABLED` environment variable to `false`.  Furthermore, users can supply a custom banner by placing the banner file in `src/main/resources` and configuring `quarkus.banner.path=name-of-file` in `application.properties`.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Por defecto, cuando una aplicación Quarkus se inicia (en modo normal o dev), mostrará un banner de arte ASCII. El banner puede deshabilitarse configurando `quarkus.banner.enabled=false` en `application.properties`, configurando la propiedad del sistema Java `-Dquarkus.banner.enabled=false`, o configurando la variable de entorno `QUARKUS_BANNER_ENABLED` en `false`. Además, los usuarios pueden proporcionar un banner personalizado colocando el archivo de banner en `src/main/resources` y configurando `quarkus.banner.path=name-of-file` en `application.properties`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What's next?</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>¿Qué es lo que sigue?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covered the creation of an application using Quarkus.  However, there is much more.  We recommend continuing the journey with the xref:building-native-image.adoc[building a native executable guide], where you learn about creating a native executable and packaging it in a container.  If you are interested in reactive, we recommend the xref:getting-started-reactive.adoc[Getting Started with Reactive guide], where you can see how to implement reactive applications with Quarkus.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Esta guía cubre la creación de una aplicación utilizando Quarkus. Sin embargo, hay mucho más. Recomendamos continuar el viaje con la guía de xref:building-native-image.adoc[building a native executable guide], donde se aprende a crear un ejecutable nativo y empaquetarlo en un contenedor. Si te interesa lo reactivo, te recomendamos la guía xref:getting-started-reactive.adoc[Getting Started with Reactive guide], donde podrás ver cómo implementar aplicaciones reactivas con Quarkus.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In addition, the xref:tooling.adoc[tooling guide] document explains how to:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Además, el documento xref:tooling.adoc[Guía de herramientas] explica cómo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Credential profiles file at the default location (`~/.aws/credentials`) shared by all AWS SDKs and the AWS CLI</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Archivo de perfiles de credenciales en la ubicación por defecto ( `~/.aws/credentials`) compartido por todos los SDKs de AWS y la CLI de AWS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `quarkus-amazon-lambda` extension allows you to use Quarkus to build your AWS Lambdas.  Your lambdas can use injection annotations from CDI or Spring and other Quarkus facilities as you need them.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>La extensión `quarkus-amazon-lambda` le permite utilizar Quarkus para construir sus AWS Lambdas. Tus lambdas pueden utilizar anotaciones de inyección de CDI o Spring y otras facilidades de Quarkus según las necesites.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus's integration with lambdas also supports Quarkus's Live Coding development cycle.  You an bring up your Quarkus lambda project in dev or test mode and code on your project live.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>La integración de Quarkus con las lambdas también es compatible con el ciclo de desarrollo Live Coding de Quarkus. Usted puede traer su proyecto Quarkus lambda en el modo de desarrollo o de prueba y el código en su proyecto en vivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Installing all the AWS bits is probably the most difficult thing about this guide.  Make sure that you follow all the steps for installing AWS CLI.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Instalar todos los bits de AWS es probablemente lo más difícil de esta guía. Asegúrate de seguir todos los pasos para instalar AWS CLI.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `quarkus-amazon-lambda` extension scans your project for a class that directly implements the Amazon `RequestHandler&lt;?, ?&gt;` or `RequestStreamHandler` interface.  It must find a class in your project that implements this interface or it will throw a build time failure.  If it finds more than one handler class, a build time exception will also be thrown.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>La extensión `quarkus-amazon-lambda` busca en tu proyecto una clase que implemente directamente la interfaz de Amazon `RequestHandler&lt;?, ?&gt;` o `RequestStreamHandler`. Debe encontrar una clase en tu proyecto que implemente esta interfaz o lanzará un fallo de compilación. Si encuentra más de una clase manejadora, también se lanzará una excepción de tiempo de compilación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sometimes, though, you might have a few related lambdas that share code and creating multiple maven modules is just an overhead you don't want to do.  The `quarkus-amazon-lambda` extension allows you to bundle multiple lambdas in one project and use configuration or an environment variable to pick the handler you want to deploy.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>A veces, sin embargo, puedes tener unas cuantas lambdas relacionadas que comparten código y crear múltiples módulos de maven es una sobrecarga que no quieres hacer. La extensión `quarkus-amazon-lambda` te permite agrupar múltiples lambdas en un proyecto y utilizar la configuración o una variable de entorno para elegir el manejador que quieres desplegar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The generated project has three lambdas within it.  Two that implement the `RequestHandler&lt;?, ?&gt;` interface, and one that implements the `RequestStreamHandler` interface. One that is used and two that are unused.  If you open up `src/main/resources/application.properties` you'll see this:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>El proyecto generado tiene tres lambdas dentro de él. Dos que implementan la interfaz `RequestHandler&lt;?, ?&gt;`, y una que implementa la interfaz `RequestStreamHandler`. Una que se usa y dos que no se usan. Si abres `src/main/resources/application.properties` verás esto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The CDI name of the handler class must match the value specified within the `quarkus.lambda.handler` property.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>El nombre CDI de la clase manejadora debe coincidir con el valor especificado en la propiedad `quarkus.lambda.handler`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are a few steps to get your lambda running on AWS.  The generated maven project contains a helpful script to create, update, delete, and invoke your lambdas for pure Java and native deployments.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Hay algunos pasos para conseguir que su lambda se ejecute en AWS. El proyecto maven generado contiene un script útil para crear, actualizar, eliminar e invocar sus lambdas para implementaciones puramente Java y nativas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>View the https://docs.aws.amazon.com/lambda/latest/dg/gettingstarted-awscli.html[Getting Started Guide] for deploying a lambda with AWS CLI.  Specifically, make sure you have created an `Execution Role`.  You will need to define a `LAMBDA_ROLE_ARN` environment variable in your profile or console window, Alternatively, you can edit the `manage.sh` script that is generated by the build and put the role value directly there:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Consulte la https://docs.aws.amazon.com/lambda/latest/dg/gettingstarted-awscli.html[Guía de inicio] para implementar un lambda con AWS CLI. Específicamente, asegúrese de haber creado un `Execution Role`. Tendrá que definir una variable de entorno `LAMBDA_ROLE_ARN` en su perfil o ventana de consola, alternativamente, puede editar el script `manage.sh` que es generado por la construcción y poner el valor del rol directamente allí:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>After you run the build, there are a few extra files generated by the `quarkus-amazon-lambda` extension.  These files are in the the build directory: `target/` for maven, `build/` for gradle.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Después de ejecutar la construcción, hay algunos archivos adicionales generados por la extensión `quarkus-amazon-lambda`. Estos archivos están en el directorio de construcción: `target/` para maven, `build/` para gradle.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `target/manage.sh` script is for managing your lambda using the AWS Lambda Java runtime.  This script is provided only for your convenience. Examine the output of the `manage.sh` script if you want to learn what aws commands are executed to create, delete, and update your lambdas.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>El script `target/manage.sh` es para administrar su lambda utilizando el tiempo de ejecución de AWS Lambda Java. Este script se proporciona sólo para su comodidad. Examine la salida del script `manage.sh` si desea saber qué comandos de aws se ejecutan para crear, eliminar y actualizar sus lambdas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To verify your setup, that you have the AWS CLI installed, executed aws configure for the AWS access keys, and setup the `LAMBDA_ROLE_ARN` environment variable (as described above), please execute `manage.sh` without any parameters.  A usage statement will be printed to guide you accordingly.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Para verificar su configuración, que tiene la CLI de AWS instalada, ha ejecutado aws configure para las claves de acceso de AWS y ha configurado la variable de entorno `LAMBDA_ROLE_ARN` (como se ha descrito anteriormente), ejecute `manage.sh` sin ningún parámetro. Se imprimirá una declaración de uso para guiarte en consecuencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To see the `usage` statement, and validate AWS configuration:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Para ver la declaración `usage`, y validar la configuración de AWS:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can `create` your function using the following command:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Puede crear su función utilizando el siguiente comando, `create` :</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Do not change the handler switch.  This must be hardcoded to `io.quarkus.amazon.lambda.runtime.QuarkusStreamHandler::handleRequest`.  This handler bootstraps Quarkus and wraps your actual handler so that injection can be performed.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>No cambie el switch del manejador. Esto debe ser codificado en `io.quarkus.amazon.lambda.runtime.QuarkusStreamHandler::handleRequest`. Este manejador arranca Quarkus y envuelve su manejador real para que la inyección pueda ser realizada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If there are any problems creating the function, you must delete it with the `delete` function before re-running the `create` command.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Si hay algún problema en la creación de la función, debe borrarla con la función `delete` antes de volver a ejecutar el comando `create`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can update the Java code as you see fit.  Once you've rebuilt, you can redeploy your lambda by executing the `update` command.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Puedes actualizar el código Java como creas conveniente. Una vez que hayas reconstruido, puedes volver a desplegar tu lambda ejecutando el comando `update`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want a lower memory footprint and faster initialization times for your lambda, you can compile your Java code to a native executable.  Just make sure to rebuild your project with the `-Pnative` switch.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Si quieres una menor huella de memoria y tiempos de inicialización más rápidos para tu lambda, puedes compilar tu código Java a un ejecutable nativo. Sólo asegúrese de reconstruir su proyecto con el interruptor `-Pnative`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are building on a non-Linux system, you will need to also pass in a property instructing Quarkus to use a docker build as Amazon Lambda requires linux binaries.  You can do this by passing this property to your build: `-Dquarkus.native.container-build=true`. This requires you to have Docker installed locally, however.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Si estás construyendo en un sistema que no es Linux, tendrás que pasar también una propiedad que indique a Quarkus que utilice una construcción docker, ya que Amazon Lambda requiere binarios linux. Puedes hacerlo pasando esta propiedad a tu construcción: `-Dquarkus.native.container-build=true`. Sin embargo, esto requiere que tengas Docker instalado localmente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Either of these commands will compile and create a native executable image.  It also generates a zip file `target/function.zip`.  This zip file contains your native executable image renamed to `bootstrap`.  This is a requirement of the AWS Lambda Custom (Provided) Runtime.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Cualquiera de estos comandos compilará y creará una imagen ejecutable nativa. También genera un archivo zip `target/function.zip`. Este archivo zip contiene su imagen ejecutable nativa renombrada a `bootstrap`. Este es un requisito del tiempo de ejecución personalizado (proporcionado) de AWS Lambda.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The instructions here are exactly as above with one change: you'll need to add `native` as the first parameter to the `manage.sh` script:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Las instrucciones son exactamente las mismas que las anteriores con un cambio: tendrá que añadir `native` como primer parámetro del script `manage.sh`:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As above, commands can be stacked.  The only requirement is that `native` be the first parameter should you wish to work with native image builds.  The script will take care of the rest of the details necessary to manage your native image function deployments.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Como en el caso anterior, los comandos se pueden apilar. El único requisito es que `native` sea el primer parámetro si desea trabajar con construcciones de imágenes nativas. El script se encargará del resto de los detalles necesarios para gestionar sus despliegues de funciones de imagen nativa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is nothing special about the POM other than the inclusion of the `quarkus-amazon-lambda` extension as a dependency.  The extension automatically generates everything you might need for your lambda deployment.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>No hay nada especial en el POM, aparte de la inclusión de la extensión `quarkus-amazon-lambda` como dependencia. La extensión genera automáticamente todo lo que puedas necesitar para tu despliegue de lambda.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Gradle build</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Construcción de Gradle</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Similarly for Gradle projects, you also just have to add the `quarkus-amazon-lambda` dependency.  The extension automatically generates everything you might need for your lambda deployment.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Del mismo modo, para los proyectos de Gradle, también sólo tienes que añadir la dependencia de `quarkus-amazon-lambda`. La extensión genera automáticamente todo lo que puedas necesitar para el despliegue de tu lambda.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To mirror the AWS Lambda environment as closely as possible in a dev environment, the Quarkus Amazon Lambda extension boots up a mock AWS Lambda event server in Quarkus Dev and Test mode.  This mock event server simulates a true AWS Lambda environment.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Para reflejar el entorno de AWS Lambda con la mayor exactitud posible en un entorno de desarrollo, la extensión de Quarkus Amazon Lambda inicia un servidor de eventos de AWS Lambda falso en el modo de desarrollo y prueba de Quarkus. Este servidor de eventos falso simula un verdadero entorno de AWS Lambda.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While running in Quarkus Dev Mode, you can feed events to it by doing an HTTP POST to `http://localhost:8080`.  The mock event server will receive the events and your lambda will be invoked.  You can perform live coding on your lambda and changes will automatically be recompiled and available the next invocation you make.  Here's an example:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Mientras se ejecuta en el modo de desarrollo de Quarkus, puede alimentar los eventos haciendo un POST HTTP a `http://localhost:8080`. El servidor de eventos falso recibirá los eventos y su lambda será invocado. Puedes realizar codificación en vivo en tu lambda y los cambios se recompilarán automáticamente y estarán disponibles en la siguiente invocación que hagas. Aquí tienes un ejemplo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For your unit tests, you can also invoke on the mock event server using any HTTP client you want.  Here's an example using rest-assured.  Quarkus starts up a separate Mock Event server under port 8081.  The default port for Rest Assured is automatically set to 8081 by Quarkus so you can invoke on this endpoint.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Para tus pruebas unitarias, también puedes invocar en el servidor de eventos falso usando cualquier cliente HTTP que quieras. Aquí hay un ejemplo usando rest-assured. Quarkus inicia un servidor de eventos simulados separado bajo el puerto 8081. El puerto por defecto para Rest Assured se establece automáticamente a 8081 por Quarkus para que pueda invocar en este punto final.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-sam-cli-install.html[AWS SAM CLI] allows you to run your lambdas locally on your laptop in a simulated Lambda environment.  This requires https://www.docker.com/products/docker-desktop[docker] to be installed.  This is an optional approach should you choose to take advantage of it.  Otherwise, the Quarkus JUnit integration should be sufficient for most of your needs.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>La  https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-sam-cli-install.html[AWS SAM CLI]  le permite ejecutar sus lambdas localmente en su portátil en un entorno de Lambda simulado. Esto requiere la instalación de https://www.docker.com/products/docker-desktop[docker]. Este es un enfoque opcional en caso de que decidas aprovecharlo. De lo contrario, la integración de Quarkus JUnit debería ser suficiente para la mayoría de sus necesidades.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Run the following SAM CLI command to locally test your lambda function, passing the appropriate SAM `template`.  The `event` parameter takes any JSON file, in this case the sample `payload.json`.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Ejecute el siguiente comando CLI de SAM para probar localmente su función lambda, pasando el parámetro apropiado de SAM `template`. El parámetro `event` toma cualquier archivo JSON, en este caso el ejemplo `payload.json`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The native image can also be locally tested using the `sam.native.yaml` template:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>La imagen nativa también puede probarse localmente utilizando la plantilla `sam.native.yaml`:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The are times where you may have to add some additions to the `function.zip` lambda deployment that is generated by the build.  To do this create a `zip.jvm` or `zip.native` directory within `src/main`.  Create `zip.jvm/` if you are doing a pure Java lambda.  `zip.native/` if you are doing a native deployment.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Hay veces en las que puedes tener que añadir algunas adiciones al despliegue de lambda `function.zip` que es generado por la construcción. Para ello crea un directorio `zip.jvm` o `zip.native` dentro de `src/main`. Crea `zip.jvm/` si estás haciendo una lambda puramente Java. `zip.native/` si estás haciendo un despliegue nativo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are times you may want to set a specific system properties or other arguments when lambda invokes your native quarkus lambda deployment.  If you include a `bootstrap` script file within `zip.native`, the quarkus extension will automatically rename the executable to `runner` within `function.zip` and set the unix mode of the `bootstrap` script to executable.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Hay veces que puedes querer establecer unas propiedades específicas del sistema u otros argumentos cuando lambda invoca tu despliegue lambda nativo de quarkus. Si incluyes un archivo de script `bootstrap` dentro de `zip.native`, la extensión quarkus renombrará automáticamente el ejecutable a `runner` dentro de `function.zip` y establecerá el modo unix del script `bootstrap` a ejecutable.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The native executable must be referenced as `runner` if you include a custom `bootstrap` script.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>El ejecutable nativo debe ser referenciado como `runner` si incluye un script personalizado de `bootstrap`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In addition, remember to enable the AWS X-Ray tracing parameter in `manage.sh`, in the `cmd_create()` function.  This can also be set in the AWS Management Console.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Además, recuerde habilitar el parámetro de rastreo de AWS X-Ray en `manage.sh`, en la función `cmd_create()`. Esto también se puede configurar en la consola de administración de AWS.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>AWS X-Ray does add many classes to your distribution, do ensure you are using at least the 256MB AWS Lambda memory size.  This is explicitly set in `manage.sh` `cmd_create()`. Whilst the native image potentially can always use a lower memory setting, it would be recommended to keep the setting the same, especially to help compare performance.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>AWS X-Ray añade muchas clases a su distribución, asegúrese de que está utilizando al menos el tamaño de memoria de 256 MB de AWS Lambda. Esto se establece explícitamente en `manage.sh` `cmd_create()` . Aunque la imagen nativa siempre puede utilizar una configuración de memoria más baja, se recomienda mantener la misma configuración, especialmente para ayudar a comparar el rendimiento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If your code makes HTTPS calls, such as to a micro-service (or AWS service), you will need to add configuration to the native image, as GraalVM will only include the dependencies when explicitly declared.  Quarkus, by default enables this functionality on extensions that implicitly require it.  For further information, please consult the xref:native-and-ssl.adoc[Quarkus SSL guide]</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Si tu código hace llamadas HTTPS, como por ejemplo a un microservicio (o servicio AWS), tendrás que añadir la configuración a la imagen nativa, ya que GraalVM sólo incluirá las dependencias cuando se declaren explícitamente. Quarkus, por defecto habilita esta funcionalidad en las extensiones que implícitamente lo requieren. Para más información, consulta la xref:native-and-ssl.adoc[Guía de Quarkus SSL]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus now has extensions for DynamoDB, S3, SNS and SQS (more coming).  Please check link:{amazon-services-guide}[those guides] on how to use the various AWS Services with Quarkus, as opposed to wiring manually like below.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Quarkus ahora tiene extensiones para DynamoDB, S3, SNS y SQS (más en camino). Por favor, consulte link:{amazon-services-guide}[estas guías] sobre cómo utilizar los diversos servicios de AWS con Quarkus, en lugar de cablear manualmente como se indica a continuación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Add `quarkus-jaxb` as a dependency in your Maven `pom.xml`, or Gradle `build.gradle` file.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Añade `quarkus-jaxb` como dependencia en tu archivo Maven `pom.xml`, o Gradle `build.gradle`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>if you see `java.security.InvalidAlgorithmParameterException: the trustAnchors parameter must be non-empty` or similar SSL error, due to the current status of GraalVM, there is some additional work to bundle the `function.zip`, as below.  For more information, please see the xref:native-and-ssl.adoc[Quarkus Native SSL Guide].</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>si ves `java.security.InvalidAlgorithmParameterException: the trustAnchors parameter must be non-empty` o un error SSL similar, debido al estado actual de GraalVM, hay algo de trabajo adicional para agrupar el `function.zip`, como se indica a continuación. Para más información, por favor vea la xref:native-and-ssl.html[Guía de SSL nativa de Quarkus].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To do this, first create a directory `src/main/zip.native/` with your build.  Next create a shell script file called `bootstrap` within `src/main/zip.native/`, like below. An example is create automatically in your build folder (target or build), called `bootstrap-example.sh`</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Para ello, primero cree un directorio `src/main/zip.native/` con su construcción. A continuación, cree un archivo de secuencia de comandos llamado `bootstrap` dentro de `src/main/zip.native/`, como se indica a continuación. Un ejemplo es crear automáticamente en su carpeta de construcción (target o build), llamado `bootstrap-example.sh`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Second, cacerts, the certificate store.  You may need to periodically obtain an updated copy, also.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>En segundo lugar, cacerts, el almacén de certificados. Es posible que tenga que obtener periódicamente una copia actualizada, también.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Kafka</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Kafka</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>MongoDB</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>MongoDB</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Elasticsearch</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Elasticsearch</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>One Google Cloud Functions deployment can represent any number of JAX-RS, Servlet, Reactive Routes, or xref:funqy-http.adoc[Funqy HTTP] endpoints.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Una implementación de Google Cloud Functions puede representar cualquier número de endpoints JAX-RS, Servlet, Rutas Reactivas o xref:funqy-http.html[Funqy HTTP].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide walks you through generating a sample project followed by creating three HTTP endpoints written with JAX-RS APIs, Servlet APIs, Reactive Routes, or xref:funqy-http.adoc[Funqy HTTP] APIs. Once built, you will be able to deploy the project to Google Cloud.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Esta guía le guiará a través de la generación de un proyecto de ejemplo, seguido de la creación de tres endpoints HTTP escritos con APIs JAX-RS, APIs Servlet, Rutas Reactivas o APIs xref:funqy-http.html[Funqy HTTP]. Una vez construido, podrás desplegar el proyecto en Google Cloud.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create an application with the `quarkus-google-cloud-functions-http` extension.  You can use the following Maven command to create it:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Cree una aplicación con la extensión `quarkus-google-cloud-functions-http`. Puedes utilizar el siguiente comando de Maven para crearla:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These various endpoints are for demonstration purposes.  For real life applications, you should choose one of this technology and stick to it.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Estos diferentes endpoints son para fines de demostración. Para las aplicaciones de la vida real, debes elegir una de estas tecnologías y ceñirte a ella.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Package your application using the standard `mvn clean package` command.  The result of the previous command is a single JAR file inside the `target/deployment` directory that contains the classes and the dependencies of the project.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Empaqueta tu aplicación utilizando el comando estándar `mvn clean package`. El resultado del comando anterior es un único archivo JAR dentro del directorio `target/deployment` que contiene las clases y las dependencias del proyecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to use RabbitMQ, you should use the xref:rabbitmq.adoc[SmallRye Reactive Messaging RabbitMQ extension].  Alternatively, if want to use RabbitMQ with AMQP 1.0 you need to enable the AMQP 1.0 plugin in the RabbitMQ broker; check the https://smallrye.io/smallrye-reactive-messaging/smallrye-reactive-messaging/3.9/amqp/amqp.html#amqp-rabbitmq[connecting to RabbitMQ] documentation.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Si quieres usar RabbitMQ, debes usar la xref:rabbitmq.adoc[extensión SmallRye Reactive Messaging RabbitMQ]. Alternativamente, si quieres usar RabbitMQ con AMQP 1.0 necesitas habilitar el plugin AMQP 1.0 en el broker RabbitMQ; consulta la documentación de https://smallrye.io/smallrye-reactive-messaging/smallrye-reactive-messaging/3.9/amqp/amqp.html#amqp-rabbitmq[conexión a RabbitMQ].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we are going to develop two applications communicating with an AMQP broker.  We will use https://activemq.apache.org/components/artemis/[Artemis], but you can use any AMQP 1.0 broker.  The first application sends a _quote request_ to an AMQP queue and consumes messages from the _quote_ queue.  The second application receives the _quote request_ and sends a _quote_ back.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>En esta guía, vamos a desarrollar dos aplicaciones que se comunican con un broker AMQP. Usaremos https://activemq.apache.org/components/artemis/[Artemis], pero puedes usar cualquier broker AMQP 1.0. La primera aplicación envía una solicitud _de_ cotización a una cola AMQP y consume mensajes de la cola de _cotización_. La segunda aplicación recibe la solicitud de _cotización_ y envía una _cotización_ de vuelta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The first application, the `producer`, will let the user request some quotes over an HTTP endpoint.  For each quote request, a random identifier is generated and returned to the user, to put the quote request on _pending_.  At the same time the generated request id is sent over the `quote-requests` queue.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>La primera aplicación, la `producer`, permitirá al usuario solicitar algunas cotizaciones a través de un endpoint HTTP. Para cada solicitud de cotización, se genera un identificador aleatorio que se devuelve al usuario, para poner la solicitud de cotización en _espera_. Al mismo tiempo, el identificador de solicitud generado se envía a través de la cola de `quote-requests`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `Quote` class will be used in both `producer` and `processor` projects.  For the sake of simplicity we will duplicate the class.  In both projects, create the `src/main/java/org/acme/amqp/model/Quote.java` file, with the following content:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>La clase `Quote` se utilizará en los proyectos `producer` y `processor`. Para simplificar, duplicaremos la clase. En ambos proyectos, cree el archivo `src/main/java/org/acme/amqp/model/Quote.java`, con el siguiente contenido:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inside the `producer` project locate the generated `src/main/java/org/acme/amqp/producer/QuotesResource.java` file, and update the content to be:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Dentro del proyecto `producer` localice el archivo generado `src/main/java/org/acme/amqp/producer/QuotesResource.java`, y actualice el contenido para que sea:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `quote-requests` channel is going to be managed as a AMQP queue, as that's the only connector on the classpath.  If not indicated otherwise, like in this example, Quarkus uses the channel name as AMQP queue name.  So, in this example, the application sends messages to the `quote-requests` queue.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>El canal `quote-requests` va a ser gestionado como una cola AMQP, ya que es el único conector en el classpath. Si no se indica lo contrario, como en este ejemplo, Quarkus utiliza el nombre del canal como nombre de la cola AMQP. Así, en este ejemplo, la aplicación envía mensajes a la cola `quote-requests`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now let's consume the quote request and give out a price.  Inside the `processor` project, locate the `src/main/java/org/acme/amqp/processor/QuoteProcessor.java` file and add the following:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Ahora vamos a consumir la solicitud de quota y dar un precio. Dentro del proyecto `processor`, localice el archivo `src/main/java/org/acme/amqp/processor/QuoteProcessor.java` y añada lo siguiente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `process` method is called for every AMQP message from the `quote-requests` queue, and will send a `Quote` object to the `quotes` queue.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>El método `process` es llamado por cada mensaje AMQP de la cola `quote-requests`, y enviará un objeto `Quote` a la cola `quotes`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Because we want to consume messages from the `quotes-requests` queue into the `requests` channel, we need to configure this association.  Open the `src/main/resources/application.properties` file and add:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Como queremos consumir mensajes de la cola `quotes-requests` en el canal `requests`, necesitamos configurar esta asociación. Abre el archivo `src/main/resources/application.properties` y añade:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus starts a AMQP broker automatically, configures the application and shares the broker instance between different applications.  See xref:amqp-dev-services.adoc[Dev Services for AMQP] for more details.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Quarkus inicia un broker AMQP automáticamente, configura la aplicación y comparte la instancia del broker entre diferentes aplicaciones. Ver xref:amqp-dev-services.html[Dev Services for AMQP] para más detalles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When not running in dev or test mode, you will need to start your AMQP broker.  You can follow the instructions from the https://activemq.apache.org/components/artemis/documentation/latest/using-server.html[Apache ActiveMQ Artemis website] or create a `docker-compose.yaml` file with the following content:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Cuando no se esté ejecutando en modo dev o test, tendrá que iniciar su broker AMQP. Puede seguir las instrucciones del https://activemq.apache.org/components/artemis/documentation/latest/using-server.html[sitio web de Apache ActiveMQ Artemis] o crear un archivo `docker-compose.yaml` con el siguiente contenido:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note how the AMQP broker location is configured.  The `amqp.host` and `amqp.port` (`AMQP_HOST` and `AMQP_PORT` environment variables) properties configure location.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Observe cómo se configura la ubicación del broker AMQP. Las propiedades `amqp.host` y `amqp.port` ( `AMQP_HOST` y `AMQP_PORT` variables de entorno) configuran la ubicación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide has shown how you can interact with AMQP 1.0 using Quarkus.  It utilizes https://smallrye.io/smallrye-reactive-messaging[SmallRye Reactive Messaging] to build data streaming applications.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Esta guía ha mostrado cómo puedes interactuar con AMQP 1.0 usando Quarkus. Utiliza https://smallrye.io/smallrye-reactive-messaging[SmallRye Reactive Messaging] para construir aplicaciones de streaming de datos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you did the Kafka quickstart, you have realized that it's the same code.  The only difference is the connector configuration and the JSON mapping.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Si has hecho el quickstart de Kafka, te habrás dado cuenta de que es el mismo código. La única diferencia es la configuración del conector y el mapeo JSON.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Keycloak</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Keycloak</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Your macOS has the wrong `*.h` files compared to the OS and no gcc compilation will work.  This can happen when you migrate from versions of the OS.  See https://stackoverflow.com/questions/48029309/cannot-compile-any-c-programs-error-unknown-type-name-uint8-t</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Tu macOS tiene los archivos `*.h` equivocados en comparación con el SO y no funcionará la compilación con gcc. Esto puede ocurrir cuando se migra desde versiones del SO. Ver https://stackoverflow.com/questions/48029309/cannot-compile-any-c-programs-error-unknown-type-name-uint8-t</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`sudo mv /usr/local/include /usr/local/include.old`</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>`sudo mv /usr/local/include /usr/local/include.old`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>(optional?) `brew install llvm`</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>(¿opcional?) `brew install llvm`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;&lt;#jib,Jib&gt;&gt;</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>&lt;&lt;#jib,Jib&gt;&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;&lt;#docker,Docker&gt;&gt;</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>&lt;&lt;#docker,Docker&gt;&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;&lt;#s2i,S2I&gt;&gt;</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>&lt;&lt;#s2i,S2I&gt;&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;&lt;#buildpack,Buildpack&gt;&gt;</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>&lt;&lt;#buildpack,Buildpack&gt;&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Jib</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Jib</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The extension `quarkus-container-image-jib` is powered by https://github.com/GoogleContainerTools/jib[Jib] for performing container image builds.  The major benefit of using Jib with Quarkus is that all the dependencies (everything found under `target/lib`) are cached in a different layer than the actual application making rebuilds really fast and small (when it comes to pushing).  Another important benefit of using this extension is that it provides the ability to create a container image without having to have any dedicated client side tooling (like Docker) or running daemon processes (like the Docker daemon)  when all that is needed is the ability to push to a container image registry.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>La extensión `quarkus-container-image-jib` es impulsada por https://github.com/GoogleContainerTools/jib[Jib] para realizar construcciones de imágenes de contenedores. El mayor beneficio de usar Jib con Quarkus es que todas las dependencias (todo lo que se encuentra en `target/lib`) se almacenan en caché en una capa diferente a la de la aplicación real, haciendo que las reconstrucciones sean realmente rápidas y pequeñas (cuando se trata de subir). Otro beneficio importante de usar esta extensión es que proporciona la capacidad de crear una imagen de contenedor sin tener que tener ninguna herramienta dedicada del lado del cliente (como Docker) o ejecutar procesos de demonio (como el demonio Docker) cuando todo lo que se necesita es la capacidad de subir a un registro de imagen de contenedor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are cases when additional files (other than ones produced by the Quarkus build) need to be added to a container image.  To support these cases, Quarkus copies any file under `src/main/jib` into the built container image (which is essentially the same idea that the Jib Maven and Gradle plugins support).  For example, the presence of `src/main/jib/foo/bar` would result in `/foo/bar` being added into the container filesystem.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Hay casos en los que es necesario añadir archivos adicionales (distintos de los producidos por la construcción de Quarkus) a una imagen de contenedor. Para soportar estos casos, Quarkus copia cualquier archivo bajo `src/main/jib` en la imagen de contenedor construida (que es esencialmente la misma idea que soportan los plugins Jib Maven y Gradle). Por ejemplo, la presencia de `src/main/jib/foo/bar` haría que se añadiera `/foo/bar` al sistema de archivos del contenedor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Docker</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Docker</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The extension `quarkus-container-image-s2i` is using S2I binary builds in order to perform container builds inside the OpenShift cluster.  The idea behind the binary build is that you just upload the artifact and its dependencies to the cluster and during the build they will be merged to a builder image (defaults to `fabric8/s2i-java`).</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>La extensión `quarkus-container-image-s2i` está usando construcciones binarias S2I para realizar construcciones de contenedores dentro del clúster OpenShift. La idea detrás de la construcción binaria es que sólo tienes que subir el artefacto y sus dependencias al clúster y durante la construcción se fusionarán con una imagen constructora (por defecto `fabric8/s2i-java`).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The benefit of this approach, is that it can be combined with OpenShift's `DeploymentConfig` that makes it easy to roll out changes to the cluster.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>La ventaja de este enfoque es que puede combinarse con el sitio web de OpenShift `DeploymentConfig`, que facilita la introducción de cambios en el clúster.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>S2I builds require creating a `BuildConfig` and two `ImageStream` resources, one for the builder image and one for the output image.  The creation of such objects is being taken care of by the Quarkus Kubernetes extension.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Las construcciones S2I requieren la creación de un `BuildConfig` y dos recursos `ImageStream`, uno para la imagen constructora y otro para la imagen de salida. De la creación de estos objetos se encarga la extensión Quarkus Kubernetes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Buildpack</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Buildpack</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The extension `quarkus-container-image-buildpack` is using buildpacks in order to perform container image builds.  Under the hood buildpacks will use a Docker daemon for the actual build.  While buildpacks support alternatives to Docker, this extension will only work with Docker.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>La extensión `quarkus-container-image-buildpack` utiliza buildpacks para realizar la construcción de imágenes de contenedores. Bajo el capó, los buildpacks utilizarán un demonio Docker para la construcción real. Mientras que los buildpacks soportan alternativas a Docker, esta extensión sólo funcionará con Docker.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If no registry is set (using `quarkus.container-image.registry`) then `docker.io` will be used as the default.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Si no se establece ningún registro (utilizando `quarkus.container-image.registry`), se utilizará `docker.io` por defecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using CI Environments</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Uso de entornos de IC</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, https://gitlab.com/[GitLab] provides such a registry and in the provided CI environment, makes available the `CI_REGISTRY_IMAGE` environment variable (see GitLab's https://docs.gitlab.com/ee/ci/variables/[documentation]) for more information), which can be used in Quarkus like so:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Por ejemplo, https://gitlab.com/[GitLab] proporciona un registro de este tipo y en el entorno de CI proporcionado, pone a disposición la variable de entorno `CI_REGISTRY_IMAGE` (véase la https://docs.gitlab.com/ee/ci/variables/[documentación] de GitLab) para obtener más información), que se puede utilizar en Quarkus de esta manera:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>S2I  Options</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Opciones S2I</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is a collection of preferred term in the documentation and website.  Please stay within these terms for consistency.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Esta es una colección de términos preferidos en la documentación y el sitio web. Por favor, manténgase dentro de estos términos por coherencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>* Substrate VM</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>* Substrate VM</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>* Docker image</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>* Imagen Docker</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>imperative and reactive. 'Nuff said.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>imperativo y reactivo. No hay más que decir.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All this functionality is part of the Quarkus `deployment` modules, so does not affect the production application in any way. If you want to disable all Dev Services you can use the `quarkus.devservices.enabled=false` config property, although in most cases this is not necessary as simply configuring the service will result in the Dev Service being disabled automatically.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Toda esta funcionalidad es parte de los módulos de Quarkus `deployment`, por lo que no afecta a la aplicación de producción de ninguna manera. Si quieres desactivar todos los Dev Services puedes usar la propiedad `quarkus.devservices.enabled=false` config, aunque en la mayoría de los casos esto no es necesario ya que simplemente configurando el servicio se desactivará el Dev Service automáticamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that the default startup timeout is 60s, if this is not enough you can increase it with the `quarkus.devservices.timeout` property.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Tenga en cuenta que el tiempo de espera de inicio por defecto es de 60s, si esto no es suficiente puede aumentarlo con la propiedad `quarkus.devservices.timeout`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In order to use Dev Services you will generally need a working Docker environment (remote environments are supported).  If you don't have Docker installed you will need to configure your services normally.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Para utilizar los servicios de desarrollo, por lo general, necesitará un entorno Docker en funcionamiento (se admiten entornos remotos). Si no tiene Docker instalado, tendrá que configurar sus servicios normalmente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Kafka Dev Service will be enabled when the `quarkus-kafka-client` extension is present in your application, and the broker address has not been explicitly configured. More information can be found at the xref:kafka-dev-services.adoc[Kafka Dev Services Guide].</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>El Kafka Dev Service se habilitará cuando la extensión `quarkus-kafka-client` esté presente en su aplicación, y la dirección del broker no haya sido configurada explícitamente. Puede encontrar más información en la xref:kafka-dev-services.html[Guía de Servicios de Desarrollo] de Kafka.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Keycloak Dev Service will be enabled when the `quarkus-oidc` extension is present in your application, and the server address has not been explicitly configured. More information can be found at the xref:security-openid-connect-dev-services.adoc[OIDC Dev Services Guide].</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>El Keycloak Dev Service se habilitará cuando la extensión `quarkus-oidc` esté presente en su aplicación, y la dirección del servidor no haya sido configurada explícitamente. Puede encontrar más información en la xref:security-openid-connect-dev-services.html[Guía de Servicios de Desarrollo] de OIDC.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Kogito</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Kogito</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Kogito Dev Service will be enabled when either `kogito-quarkus` or `kogito-quarkus-processes` extension is present in your application. More information can be found at the xref:kogito-dev-services.adoc[Kogito Dev Services Guide].</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>El Kogito Dev Service se activará cuando la extensión `kogito-quarkus` o `kogito-quarkus-processes` esté presente en su aplicación. Puede encontrar más información en la xref:kogito-dev-services.html[Guía de Servicios de Desarrollo] de Kogito.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>RabbitMQ</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>RabbitMQ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The RabbitMQ Dev Service will be enabled when the `quarkus-smallrye-reactive-messaging-rabbitmq` extension is present in your application, and the broker address has not been explicitly configured. More information can be found at the xref:rabbitmq-dev-services.adoc[RabbitMQ Dev Services Guide].</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>El RabbitMQ Dev Service se habilitará cuando la extensión `quarkus-smallrye-reactive-messaging-rabbitmq` esté presente en su aplicación, y la dirección del broker no haya sido configurada explícitamente. Puede encontrar más información en la xref:rabbitmq-dev-services.html[Guía de servicios de desarrollo] de RabbitMQ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Redis</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Redis</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Redis Dev Service will be enabled when the `quarkus-redis-client` extension is present in your application, and the server address has not been explicitly configured. More information can be found at the xref:redis-dev-services.adoc[Redis Dev Services Guide].</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>El Redis Dev Service se habilitará cuando la extensión `quarkus-redis-client` esté presente en su aplicación, y la dirección del servidor no haya sido configurada explícitamente. Puedes encontrar más información en la xref:redis-dev-services.html[Guía de Servicios de Desarrollo] de Redis.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Infinispan</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Infinispan</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev Services for AMQP automatically starts an AMQP 1.0 broker in dev mode and when running tests.  So, you don't have to start a broker manually.  The application is configured automatically.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Dev Services for AMQP inicia automáticamente un broker AMQP 1.0 en modo dev y cuando se ejecutan pruebas. Por lo tanto, no tienes que iniciar un broker manualmente. La aplicación se configura automáticamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Enabling / Disabling Dev Services for AMQP</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Activación/desactivación de los servicios de desarrollo para AMQP</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev Services for AMQP relies on Docker to start the broker.  If your environment does not support Docker, you will need to start the broker manually, or connect to an already running broker.  You can configure the broker access using the `amqp-host`, `amqp-port`, `amqp-user` and `amqp-password` properties.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Dev Services for AMQP se basa en Docker para iniciar el broker. Si tu entorno no soporta Docker, tendrás que iniciar el broker manualmente, o conectarte a un broker ya en funcionamiento. Puede configurar el acceso al broker utilizando las propiedades `amqp-host`, `amqp-port`, `amqp-user` y `amqp-password`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Most of the time you need to share the broker between applications.  Dev Services for AMQP implements a _service discovery_ mechanism for your multiple Quarkus applications running in _dev_ mode to share a single broker.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>La mayoría de las veces se necesita compartir el broker entre aplicaciones. Dev Services for AMQP implementa un mecanismo de _descubrimiento de servicios_ para que sus múltiples aplicaciones Quarkus que se ejecutan en modo _dev_ compartan un único broker.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need multiple (shared) brokers, you can configure the `quarkus.amqp.devservices.service-name` attribute and indicate the broker name.  It looks for a container with the same value, or starts a new one if none can be found.  The default service name is `amqp`.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Si necesitas varios brokers (compartidos), puedes configurar el atributo `quarkus.amqp.devservices.service-name` e indicar el nombre del broker. Se busca un contenedor con el mismo valor, o se inicia uno nuevo si no se encuentra ninguno. El nombre de servicio por defecto es `amqp`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sharing is enabled by default in dev mode, but disabled in test mode.  You can disable the sharing with `quarkus.amqp.devservices.shared=false`.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>El uso compartido está activado por defecto en el modo de desarrollo, pero está desactivada en el modo de prueba. Puede desactivar el uso compartido con `quarkus.amqp.devservices.shared=false`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, Dev Services for AMQP picks a random port and configures the application.  You can set the port by configuring the `quarkus.amqp.devservices.port` property.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Por defecto, Dev Services for AMQP elige un puerto aleatorio y configura la aplicación. Puedes establecer el puerto configurando la propiedad `quarkus.amqp.devservices.port`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev Services for AMQP uses https://quay.io/repository/artemiscloud/activemq-artemis-broker[activemq-artemis-broker] images.  You can configure the image and version using the `quarkus.amqp.devservices.image-name` property:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Dev Services for AMQP utiliza imágenes https://quay.io/repository/artemiscloud/activemq-artemis-broker[activemq-artemis-broker]. Puedes configurar la imagen y la versión utilizando la propiedad `quarkus.amqp.devservices.image-name`:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Heroku is a platform as a service (PaaS) that enables developers to build, run, and operate applications entirely in the cloud.  It supports several languages like Java, Ruby, Node.js, Scala, Clojure, Python, PHP, and Go.  In addition it offers a container registry that can be used to deploy prebuilt container images.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Heroku es una plataforma como servicio (PaaS) que permite a los desarrolladores construir, ejecutar y operar aplicaciones completamente en la nube. Es compatible con varios lenguajes como Java, Ruby, Node.js, Scala, Clojure, Python, PHP y Go. Además, ofrece un registro de contenedores que puede utilizarse para desplegar imágenes de contenedores preconstruidas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All three approaches need to be aware of the port that Heroku assigns to it to handle traffic.  Luckily, there's a dynamic configuration property for it.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Los tres enfoques necesitan conocer el puerto que Heroku le asigna para manejar el tráfico. Por suerte, hay una propiedad de configuración dinámica para ello.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Heroku can react on changes in your repository, run CI and redeploy your application when your code changes.  Therefore we start with a valid repository already.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Heroku puede reaccionar a los cambios en su repositorio, ejecutar CI y volver a desplegar su aplicación cuando su código cambia. Por lo tanto, ya empezamos con un repositorio válido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Heroku picks a random port and assigns it to the container that is eventually running your Quarkus application.  That port is available as an environment variable under `$PORT`.  The easiest way to make Quarkus in all deployment scenarios aware of it is using the following configuration:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Heroku escoge un puerto al azar y lo asigna al contenedor que eventualmente ejecuta tu aplicación Quarkus. Ese puerto está disponible como una variable de entorno en `$PORT`. La forma más fácil de hacer que Quarkus en todos los escenarios de despliegue lo conozca es utilizando la siguiente configuración:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This reads as: "Listen on `$PORT` if this is a defined variable, otherwise listen on 8080 as usual." Run the following to add this to your `application.properties`:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Esto se lee como: "Escuchar en `$PORT` si esta es una variable definida, de lo contrario escuchar en 8080 como de costumbre". Ejecute lo siguiente para añadir esto a su `application.properties`:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The image we are going to build needs to be named accordingly to work with Heroku's registry and deployment.  We get the generated name via `heroku info` and pass it on to the (local) build:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>La imagen que vamos a construir necesita ser nombrada en consecuencia para trabajar con el registro y el despliegue de Heroku. Obtenemos el nombre generado a través de `heroku info` y lo pasamos a la construcción (local):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The initial push is rather big, as all layers of the image need to be transferred.  The following pushes will be smaller.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>La subida inicial es bastante grande, ya que hay que transferir todas las capas de la imagen. Los siguientes subidas serán más pequeños.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The biggest advantage we take when deploying our app as a container is to deploy a container with the natively compiled application.  Why? Because Heroku will stop or sleep the application when there's no incoming traffic.  A native application will wake up much faster from its sleep.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>La mayor ventaja que obtenemos al desplegar nuestra aplicación como contenedor es desplegar un contenedor con la aplicación compilada de forma nativa. ¿Por qué? Porque Heroku detendrá o dormirá la aplicación cuando no haya tráfico entrante. Una aplicación nativa se despertará mucho más rápido de su reposo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The process is pretty much the same.  We opt in to compiling a native image inside a local container, so that we don't have to deal with installing GraalVM locally:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>El proceso es prácticamente el mismo. Optamos por compilar una imagen nativa dentro de un contenedor local, para no tener que lidiar con la instalación de GraalVM localmente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The sample project includes the RESTEasy Reactive, Undertow, Reactive Routes, xref:funqy-http.adoc[Funqy HTTP] extensions.  If you are only using one of those APIs (i.e. jax-rs only), respectively remove the maven dependency `quarkus-resteasy-reactive`, `quarkus-undertow`, `quarkus-funqy-http`, and/or `quarkus-reactive-routes`.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>El proyecto de ejemplo incluye las extensiones RESTEasy Reactive, Undertow, Reactive Routes y xref:funqy-http.html[Funqy HTTP]. Si sólo utiliza una de esas APIs (es decir, sólo jax-rs), elimine respectivamente la dependencia de maven `quarkus-resteasy-reactive`, `quarkus-undertow`, `quarkus-funqy-http`, y/o `quarkus-reactive-routes`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus extensions may provide certain capabilities and require certain capabilities to be provided by other extensions in an application to function properly.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Las extensiones de Quarkus pueden proporcionar ciertas capacidades y requerir que otras extensiones proporcionen ciertas capacidades en una aplicación para funcionar correctamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A capability represents a technical aspect, for example, it could be an implementation of some functionality, a contract or a specification. Each capability has a name which should follow the Java package naming convention, e.g. `io.quarkus.rest`.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Una capacidad representa un aspecto técnico, por ejemplo, puede ser una implementación de alguna funcionalidad, un contrato o una especificación. Cada capacidad tiene un nombre que debe seguir la convención de nomenclatura de paquetes de Java, por ejemplo, `io.quarkus.rest`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `quarkus-bootstrap-maven-plugin:extension-descriptor` Maven goal and the `extensionDescriptor` Gradle task, that generate extension descriptors, allow configuring provided and required capabilities in the following way:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>El objetivo de Maven `quarkus-bootstrap-maven-plugin:extension-descriptor` y la tarea de Gradle `extensionDescriptor`, que generan descriptores de extensión, permiten configurar las capacidades proporcionadas y requeridas de la siguiente manera:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Gradle (Groovy DSL)</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Gradle (Groovy DSL)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The corresponding `requiresIf` element is also supported.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>También se admite el elemento correspondiente `requiresIf`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is possible to specify `onlyIfNot` conditions as well. Conditions can also be set for required capabilities.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>También es posible especificar las condiciones de `onlyIfNot`. También se pueden establecer condiciones para las capacidades requeridas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is possible to specify `onlyIfNot` conditions as well. . Conditions can also be set for required capabilities.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>También es posible especificar las condiciones de `onlyIfNot`. . También se pueden establecer condiciones para las capacidades requeridas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With Quarkus you can deploy your favorite Java HTTP frameworks as Amazon Lambda's using either the https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api.html[AWS Gateway HTTP API] or https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-rest-api.html[AWS Gateway REST API].  This means that you can deploy your microservices written with RESTEasy Reactive (JAX-RS), Undertow (servlet), Reactive Routes, xref:funqy-http.adoc[Funqy HTTP] or any other Quarkus HTTP framework as an AWS Lambda.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Con Quarkus puede implementar sus marcos Java HTTP favoritos como Amazon Lambda utilizando la https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api.html[API HTTP de AWS Gateway] o https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-rest-api.html[la API REST de AWS Gateway]. Esto significa que puede implementar sus microservicios escritos con RESTEasy Reactive (JAX-RS), Undertow (servlet), Reactive Routes, xref:funqy-http.adoc[Funqy HTTP] o cualquier otro marco HTTP de Quarkus como un AWS Lambda.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The mock event server is also started for `@NativeImageTest` and `@QuarkusIntegrationTest` tests so will work with native binaries too.  All this provides similar functionality to the SAM CLI local testing, without the overhead of Docker.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>El servidor de eventos simulados también se inicia para las pruebas de `@NativeImageTest` y `@QuarkusIntegrationTest`, por lo que también funcionará con binarios nativos. Todo esto proporciona una funcionalidad similar a las pruebas locales de SAM CLI, sin la sobrecarga de Docker.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Also, at least in the generated Maven archetype `pom.xml`, the `quarkus-resteasy-reactive`, `quarkus-reactive-routes`, and `quarkus-undertow` dependencies are all optional.  Pick which HTTP framework(s) you want to use (JAX-RS, Reactive Routes, and/or Servlet) and remove the other dependencies to shrink your deployment.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Además, al menos en el arquetipo de Maven generado `pom.xml`, las dependencias `quarkus-resteasy-reactive`, `quarkus-reactive-routes`, y `quarkus-undertow` son todas opcionales. Escoge qué marco(s) HTTP quieres usar (JAX-RS, Reactive Routes, y/o Servlet) y elimina las otras dependencias para reducir tu despliegue.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using RESTEasy Reactive and JAX-RS, you can inject various AWS Context variables into your JAX-RS resource classes using the JAX-RS `@Context` annotation or anywhere else with the CDI `@Inject` annotation.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Si utiliza RESTEasy Reactive y JAX-RS, puede inyectar varias variables de contexto de AWS en sus clases de recursos JAX-RS utilizando la anotación JAX-RS `@Context` o en cualquier otro lugar con la anotación CDI `@Inject`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For a regular JVM distribution you need to base your image off the official AWS Java base images. Below is an example of a Dockerfile that would create a container image from your Quarkus Lambda project. It assumes that `mvn package` has been executed and binaries are available in the `target/` directory:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Para una distribución regular de JVM necesitas basar tu imagen en las imágenes base oficiales de AWS Java. A continuación se muestra un ejemplo de un archivo Docker que crearía una imagen de contenedor de su proyecto Quarkus Lambda. Asume que `mvn package` ha sido ejecutado y los binarios están disponibles en el directorio `target/`:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To create a lambda container image that uses the native executable we'll need to do things a little differently. In this case, we won't need to use the `java:11` base image from AWS but instead we'll use a special image that assumes that the runtime environment for the lambda is provided. The example below creates such a container. It assumes that a Maven build has been executed (such as `mvn package -Dnative=true`) and has generated the native binary into the `target/` directory. The binary needs to be named `bootstrap` and be placed in `/var/runtime/`:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Para crear una imagen de contenedor lambda que utilice el ejecutable nativo tendremos que hacer las cosas de forma un poco diferente. En este caso, no necesitaremos utilizar la imagen base de `java:11` de AWS, sino que utilizaremos una imagen especial que asume que se proporciona el entorno de ejecución para lambda. El siguiente ejemplo crea un contenedor de este tipo. Asume que se ha ejecutado una construcción de Maven (como `mvn package -Dnative=true`) y ha generado el binario nativo en el directorio `target/`. El binario necesita ser llamado `bootstrap` y ser colocado en `/var/runtime/`:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Below, you can see how the container images created above can be built and deployed to AWS using the `docker` and `aws` command line tools. These instructions work for both native and jvm container images and assume that the `aws` command line tool has been logged in.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>A continuación, puede ver cómo las imágenes de contenedor creadas anteriormente pueden construirse e implementarse en AWS utilizando las herramientas de línea de comandos `docker` y `aws`. Estas instrucciones funcionan tanto para imágenes de contenedor nativas como jvm y asumen que la herramienta de línea de comandos `aws` ha sido iniciada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Make sure you reference the image you uploaded previously (assumes that a role exists that can be used to run the lambda). Please note that it is not unlikely that for the JVM lambda function, the default memory limit of `128Mb` will not be enough to run the function. In that case, you can increase the memory limit when creating the function by providing the `--memory-size 256` parameter to your `aws lambda create-function` command. You can also adjust the function in the AWS console after you've created it.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Asegúrate de que haces referencia a la imagen que has subido previamente (se supone que existe un rol que puede ser utilizado para ejecutar la lambda). Ten en cuenta que no es improbable que para la función lambda de JVM, el límite de memoria por defecto de `128Mb` no sea suficiente para ejecutar la función. En ese caso, puede aumentar el límite de memoria al crear la función proporcionando el parámetro `--memory-size 256` a su comando `aws lambda create-function`. También puede ajustar la función en la consola de AWS después de haberla creado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus supports Cloud Functions gen 1 and gen 2. For an overview of Cloud Functions gen 2 see https://cloud.google.com/functions/docs/2nd-gen/overview[this page] on the Google Cloud Functions documentation. To use gen 2 you must use `gcloud beta` command and add the `--gen2` parameter.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Quarkus soporta Cloud Functions gen 1 y gen 2. Para una visión general de Cloud Functions gen 2, consulte  https://cloud.google.com/functions/docs/2nd-gen/overview[esta página] en la documentación de Google Cloud Functions. Para utilizar gen 2 debe utilizar el comando `gcloud beta` y añadir el parámetro `--gen2`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Elasticsearch Dev Service will be enabled when one of the Elasticsearch based extensions (Elasticsearch client or Hibernate Search ORM Elasticsearch)  is present in your application, and the server address has not been explicitly configured.  More information can be found at the xref:elasticsearch-dev-services.adoc[Elasticsearch Dev Services Guide].</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>El servicio de desarrollo de Elasticsearch se activará cuando una de las extensiones basadas en Elasticsearch (cliente de Elasticsearch o ORM de búsqueda de Hibernate Elasticsearch) esté presente en su aplicación, y la dirección del servidor no se haya configurado explícitamente. Puede encontrar más información en la xref:elasticsearch-dev-services.html[Guía de Servicios de Desarrollo] de Elasticsearch.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If any Elasticsearch-related extension is present (e.g. `quarkus-elasticsearch-rest-client` or `quarkus-hibernate-search-orm-elasticsearch`), Dev Services for Elasticsearch automatically starts an Elasticsearch server in dev mode and when running tests.  So, you don't have to start a server manually.  The application is configured automatically.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Si cualquier extensión relacionada con Elasticsearch está presente (por ejemplo, `quarkus-elasticsearch-rest-client` o `quarkus-hibernate-search-orm-elasticsearch`), Dev Services for Elasticsearch inicia automáticamente un servidor de Elasticsearch en modo dev y cuando se ejecutan pruebas. Por lo tanto, no tienes que iniciar un servidor manualmente. La aplicación se configura automáticamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Enabling / Disabling Dev Services for Elasticsearch</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Activación/desactivación de los servicios de desarrollo para Elasticsearch</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.elasticsearch.hosts`</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>`quarkus.elasticsearch.hosts`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.hibernate-search-orm.elasticsearch.hosts`</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>`quarkus.hibernate-search-orm.elasticsearch.hosts`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev Services for Elasticsearch relies on Docker to start the server.  If your environment does not support Docker, you will need to start the server manually, or connect to an already running server.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Dev Services for Elasticsearch se basa en Docker para iniciar el servidor. Si su entorno no admite Docker, tendrá que iniciar el servidor manualmente o conectarse a un servidor ya en funcionamiento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sometimes you need to share the server between applications.  Dev Services for Elasticsearch implements a _service discovery_ mechanism for your multiple Quarkus applications running in _dev_ mode to share a single server.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>A veces es necesario compartir el servidor entre aplicaciones. Dev Services for Elasticsearch implementa un mecanismo de _descubrimiento de servicios_ para que sus múltiples aplicaciones Quarkus que se ejecutan en modo _dev_ compartan un único servidor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need multiple (shared) servers, you can configure the `quarkus.elasticsearch.devservices.service-name` attribute and indicate the server name.  It looks for a container with the same value, or starts a new one if none can be found.  The default service name is `elasticsearch`.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Si necesitas varios servidores (compartidos), puedes configurar el atributo `quarkus.elasticsearch.devservices.service-name` e indicar el nombre del servidor. Se busca un contenedor con el mismo valor, o se inicia uno nuevo si no se encuentra ninguno. El nombre de servicio por defecto es `elasticsearch`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sharing is enabled by default in dev mode, but disabled in test mode.  You can disable the sharing with `quarkus.elasticsearch.devservices.shared=false`.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>El uso compartido está activado por defecto en el modo de desarrollo, pero está desactivada en el modo de prueba. Puede desactivar el uso compartido con `quarkus.elasticsearch.devservices.shared=false`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, Dev Services for Elasticsearch picks a random port and configures the application.  You can set the port by configuring the `quarkus.elasticsearch.devservices.port` property.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Por defecto, Dev Services for Elasticsearch elige un puerto aleatorio y configura la aplicación. Puedes establecer el puerto configurando la propiedad `quarkus.elasticsearch.devservices.port`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Kube-Native</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Kube-Native</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;code class="bash"&gt;$ ./my-native-java-rest-app
Quarkus started in 0.008s&lt;/code&gt;</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>&lt;code class="bash"&gt;$ ./my-native-java-rest-app
Quarkus started in 0.008s&lt;/code&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>QUARKUS 2.0 IS HERE!</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>¡QUARKUS 2.0 YA ESTÁ AQUÍ!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus 2.0 feature icons</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Características icónicas de Quarkus 2.0</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="#" class="scroll-down" address="true"&gt;&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>&lt;a href="#" class="scroll-down" address="true"&gt;&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Combine both the familiar imperative code and the reactive style when developing applications.  &lt;a href="/vision/continuum"&gt;Learn more&lt;/a&gt;.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Combine tanto el código imperativo conocido como el estilo reactivo al desarrollar aplicaciones. &lt;a href="/vision/continuum"&gt;Aprenda más&lt;/a&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="/kubernetes-native"&gt;Kube-Native&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>&lt;a href="/kubernetes-native"&gt;Kube-Native&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A cohesive platform for optimized developer joy with unified configuration and no hassle native executable generation. Zero config, live reload in the blink of an eye and streamlined code for the 80% common usages, flexible for the remainder 20%.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Una plataforma cohesiva para la alegría optimizada de los desarrolladores con una configuración unificada y una generación de ejecutables nativos sin complicaciones. Cero configuración, recarga en vivo en un abrir y cerrar de ojos y código racionalizado para el 80% de los usos comunes, flexible para el 20% restante.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="/worldtour/"&gt;</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>&lt;a href="/worldtour/"&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus World Tour 2022</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Quarkus World Tour 2022</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>SUPERSONIC&lt;span class="light-blue"&gt;/&lt;/span&gt;</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>SUPERSONIC&lt;span class="light-blue"&gt;/&lt;/span&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>SUBATOMIC&lt;span class="light-blue"&gt;/&lt;/span&gt;</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>SUBATOMIC&lt;span class="light-blue"&gt;/&lt;/span&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus {{ site.data.versions.quarkus.version | replace: ".Final", "" }}</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Quarkus {{ site.data.versions.quarkus.version | replace: ".Final", "" }}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Quarkus</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Supersonic Subatomic Java</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Supersonic Subatomic Java</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="https://t.co/AUnQuWDzcY?amp=1"&gt;</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>&lt;a href="https://t.co/AUnQuWDzcY?amp=1"&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/worldtour/"&gt;</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>&lt;a href="{{site.baseurl}}/worldtour/"&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;code class="bash"&gt;$ mvn package -Pnative

  # Or

$ gradle build -Dquarkus.package.type=native&lt;/code&gt;</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>&lt;code class="bash"&gt;$ mvn package -Pnative

  # Or

$ gradle build -Dquarkus.package.type=native&lt;/code&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/books/</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>/libros/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What is your license?</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>¿Qué licencia tiene?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Where can I get it?</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>¿Dónde puedo conseguirlo?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus is published in Maven Central, check out link:/extensions[which extensions] you need and just import them in your `pom.xml` to get Quarkus. We recommend you start your Quarkus experience via our link:/get-started[Getting Started guides].</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Quarkus es publicado en Maven Central, para obtener Quarkus consulte el link:/extensions[which extensions] y simplemente impórtelos en su `pom.xml`. Le recomendamos que comience su experiencia con Quarkus a través de nuestro link:/get-started[Getting Started guides].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus is stable?</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>¿Quarkus es estable?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What is a Quarkus extension?</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>¿Qué es una extensión de Quarkus?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Think of Quarkus extensions as your project dependencies. Extensions configure, boot and integrate a framework or technology into your Quarkus application. They also do all of the heavy lifting of providing the right information to GraalVM for your application to compile natively. This will allow 3rd party projects to easily take advantage of the work we have done to make it easier to target GraalVM.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Piense en las extensiones de Quarkus como dependencias de su proyecto. Las extensiones configuran, arrancan e integran marcos o tecnologías en su aplicación de Quarkus, y ademas hacen todo el trabajo pesado de proporcionar la información correcta a GraalVM para que su aplicación se compile de forma nativa. Esto permite que los proyectos de terceros aprovechen fácilmente el trabajo que hemos realizado para que sea más fácil apuntar a GraalVM.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What are the extension statuses?</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>¿Cuáles son los estados de las extensiones?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*Preview*: backward compatibility and presence in the ecosystem is not guaranteed. Specific improvements might require to change configuration or APIs and plans to become _stable_ are under way. Such extensions are in the middle of their maturation process.
</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>*Preview*: la compatibilidad con versiones anteriores y la presencia en el ecosistema no están garantizadas. Ciertas mejoras pueden requerir cambios de configuración o API, y hay planes en marcha para volverse _stable_. Estas extensiones están en medio del proceso de maduración.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can find the extension status on https://code.quarkus.io[code.quarkus.io] or in the extension link:/guides/[guides].</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Puede encontrar el estado de la extensión en https://code.quarkus.io[code.quarkus.io] o en las link:/guides/[guías] de la extensión.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Can I write an extension?</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>¿Puedo crear una extensión?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Will the Quarkus team accept my extension?</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>¿El equipo de Quarkus aceptará mi extensión?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Oh yeah! We had quite a few extensions written outside the Quarkus "initial" team.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>¡Por supuesto! Se ha creado un número significativo de extensiones fuera del equipo "inicial" de Quarkus.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>## What is GraalVM?</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>## ¿Qué es GraalVM?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example by default reflection in GraalVM will not work, unless a class/member has been explicitly registered for reflection. This is normally achieved by listing every class, method, field and constructor in a JSON file, and passing this as a parameter into the native image build. This obviously gets quite cumbersome for all but the most trivial projects. Quarkus provides a framework that makes it easy to work around these annotations, and programmatically determine what should be registered.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Por ejemplo, de forma predeterminada, la reflexión en GraalVM no funcionará, a menos que una clase/miembro se haya registrado explícitamente para la reflexión. Esto normalmente se logra listando cada clase, método, campo y constructor en un archivo JSON, y pasándolo como un parámetro Obviamente, esto se vuelve bastante engorroso para todos los proyectos, excepto para los más triviales. Quarkus proporciona un marco que facilita el trabajo en torno a estas anotaciones y proporciona un marco que le permite decidir mediante programación qué registrar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>## How do you unify imperative and reactive programming?</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>## ¿Cómo se unifica la programación imperativa y reactiva?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>## What does Container First mean?</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>## ¿Qué significa Container First?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>## What is your view on standards?</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>## ¿Cuál es su punto de vista sobre los estándares?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>## What are you doing to improve developer joy?</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>## ¿Qué estás haciendo para mejorar la alegría de los desarrolladores?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What is Quarkus?</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>¿Qué es Quarkus?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/publications/</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>/publicaciones/</seg>
      </tuv>
    </tu>
  </body>
</tmx>
