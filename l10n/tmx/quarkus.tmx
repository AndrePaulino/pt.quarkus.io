<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE tmx SYSTEM "tmx14.dtd">
<tmx version="1.4">
  <header creationtool="Translate Toolkit" creationtoolversion="3.6.1" segtype="sentence" o-tmf="UTF-8" adminlang="en" srclang="en" datatype="PlainText"/>
  <body>
    <tu>
      <tuv xml:lang="en">
        <seg>What is Quarkus?</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>¿Qué es Quarkus?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What is your license?</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>¿Qué licencia tiene?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Where can I get it?</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>¿Dónde puedo conseguirlo?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus is published in Maven Central, check out [which extensions](/extensions) you need and just import them in your `pom.xml` to get Quarkus. We recommend you start your Quarkus experience via our [Getting Started guides](/get-started).
</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Quarkus está publicado en Maven Central, comprueba [qué extensiones(/extensions) necesitas y simplemente impórtalas en tu `pom.xml` para obtener Quarkus. Te recomendamos que comiences tu experiencia con Quarkus a través de nuestras [Guías de inicio](/get-started).
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus is stable?</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>¿Quarkus es estable?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can go to [code.quarkus.io](https://code.quarkus.io/) to see if a particular extension is _stable_ (default) or _preview_.
</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Puedes ir a https://code.quarkus.io/[code.quarkus.io] para ver si una extensión en particular es _stable_ (default) o _preview_.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What is a Quarkus extension?</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>¿Qué es una extensión de Quarkus?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Think of Quarkus extensions as your project dependencies. Extensions configure, boot and integrate a framework or technology into your Quarkus application. They also do all of the heavy lifting of providing the right information to GraalVM for your application to compile natively. This will allow 3rd party projects to easily take advantage of the work we have done to make it easier to target GraalVM.
</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Piense en las extensiones de Quarkus como dependencias de su proyecto. Las extensiones configuran, arrancan e integran marcos o tecnologías en su aplicación de Quarkus, y ademas hacen todo el trabajo pesado de proporcionar la información correcta a GraalVM para que su aplicación se compile de forma nativa. Esto permite que los proyectos de terceros aprovechen fácilmente el trabajo que hemos realizado para que sea más fácil apuntar a GraalVM.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What are the extension statuses?</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>¿Cuáles son los estados de las extensiones?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>**Preview**: backward compatibility and presence in the ecosystem is not guaranteed. Specific improvements might require to change configuration or APIs and plans to become _stable_ are under way. Such extensions are in the middle of their maturation process.
</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>**Preview**: la compatibilidad con versiones anteriores y la presencia en el ecosistema no están garantizadas. Ciertas mejoras pueden requerir cambios de configuración o API, y hay planes en marcha para volverse _stable_. Estas extensiones están en medio del proceso de maduración.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can find the extension status on [code.quarkus.io](https://code.quarkus.io) or in the extension [guides](/guides/).
</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Puede encontrar el estado de la extensión en https://code.quarkus.io[code.quarkus.io] o en el enlace de la extensión link:/guides/[guides].
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Will the Quarkus team accept my extension?</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>¿El equipo de Quarkus aceptará mi extensión?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Oh yeah! We had quite a few extensions written outside the Quarkus "initial" team.
</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>¡Por supuesto! Se ha creado un número significativo de extensiones fuera del equipo "inicial" de Quarkus.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The one current restriction is that extensions should work in both OpenJDK and GraalVM native executables. That is the guarantee we give Quarkus users (a cross compilation for their app). We have a maturity model to improve an extension to be fully "Quarked" and benefit from Quarkus, all done in incremental steps. Just hop on our [mailing list](https://quarkus.io/community/#discussions) to discuss your ideas and get help. And you can start reading our [Writing extensions guide](https://quarkus.io/guides/writing-extensions) as well or more simply get inspiration from the [existing ones](https://github.com/quarkusio/quarkus/tree/master/extensions).
</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>La limitacion actual es que las extensiones deben funcionar con los ejecutables nativos de OpenJDK y GraalVM. Esta es una garantía que brindamos a los usuarios de Quarkus (compilación cruzada de aplicaciones). Tenemos un modelo de madurez para mejorar una extensión para que sea completamente "Quarked" y beneficiarse de Quarkus, todo hecho en pasos incrementales. Visite https://quarkus.io/community/#discussions[mailing list] para discutir ideas y obtener apoyo. También puede comenzar a leer https://quarkus.io/guides/writing-extensions[Writing extensions guide] o puede inspirarse en https://github.com/quarkusio/quarkus/tree/main/extensions[existing ones].
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What is GraalVM?</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>## ¿Qué es GraalVM?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[GraalVM](https://www.graalvm.org) is a universal virtual machine for running applications written in various different languages, as well as providing the ability to compile JVM bytecode to a native executable (this native executable runs a special virtual machine called SubstrateVM). These native executables start much faster and can use a lot less memory than a traditional JVM, however not every JVM feature is supported, and some are more limited than normal.
</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>https://www.graalvm.org[GraalVM] es una máquina virtual universal para ejecutar aplicaciones escritas en varios lenguajes diferentes, además de brindar la capacidad de compilar código de bytes JVM en un ejecutable nativo (este ejecutable nativo ejecuta una maquina virtual especial llamada SubstrateVM). Estos ejecutables nativos se inician mucho más rápido y pueden usar mucha menos memoria que una JVM tradicional, sin embargo, no todas las funciones de JVM son compatibles y algunas son más limitadas de lo normal.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example by default reflection in GraalVM will not work, unless a class/member has been explicitly registered for reflection. This is normally achieved by listing every class, method, field and constructor in a JSON file, and passing this as a parameter into the native image build. This obviously gets quite cumbersome for all but the most trivial projects. Quarkus provides a framework that makes it easy to work around these annotations, and programmatically determine what should be registered.
</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Por ejemplo, de forma predeterminada, la reflexión en GraalVM no funcionará, a menos que una clase/miembro se haya registrado explícitamente para la reflexión. Esto normalmente se logra listando cada clase, método, campo y constructor en un archivo JSON, y pasándolo como un parámetro Obviamente, esto se vuelve bastante engorroso para todos los proyectos, excepto para los más triviales. Quarkus proporciona un marco que facilita el trabajo en torno a estas anotaciones y proporciona un marco que le permite decidir mediante programación qué registrar.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>How do you unify imperative and reactive programming?</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>## ¿Cómo se unifica la programación imperativa y reactiva?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What does Container First mean?</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>## ¿Qué significa Container First?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What is your view on standards?</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>## ¿Cuál es su punto de vista sobre los estándares?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What are you doing to improve developer joy?</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>## ¿Qué estás haciendo para mejorar la alegría de los desarrolladores?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In-Person and online events which feature Quarkus tracks, discussion and topics.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Eventos en persona y en línea que presentan desarrollos, debates y temas de Quarkus</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus is published in Maven Central, check out link:/extensions[which extensions] you need and just import them in your `pom.xml` to get Quarkus. We recommend you start your Quarkus experience via our link:/get-started[Getting Started guides].</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Quarkus es publicado en Maven Central, para obtener Quarkus consulte el link:/extensions[which extensions] y simplemente impórtelos en su `pom.xml`. Le recomendamos que comience su experiencia con Quarkus a través de nuestro link:/get-started[Getting Started guides]. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>One of the main goals of Quarkus is ease of extensibility and to build a vibrant ecosystem.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Uno de los principales objetivos de Quarkus es la facilidad de extensibilidad y la construcción de un ecosistema vibrante</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Think of Quarkus extensions as your project dependencies. Extensions configure, boot and integrate a framework or technology into your Quarkus application. They also do all of the heavy lifting of providing the right information to GraalVM for your application to compile natively. This will allow 3rd party projects to easily take advantage of the work we have done to make it easier to target GraalVM.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Piense en las extensiones de Quarkus como dependencias de su proyecto. Las extensiones configuran, arrancan e integran marcos o tecnologías en su aplicación de Quarkus, y ademas hacen todo el trabajo pesado de proporcionar la información correcta a GraalVM para que su aplicación se compile de forma nativa. Esto permite que los proyectos de terceros aprovechen fácilmente el trabajo que hemos realizado para que sea más fácil apuntar a GraalVM</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extensions have a various degree of maturity when they enter the Quarkus ecosystem. A status offers the expectations you can rely on.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Las extensiones tienen varios grados de madurez a medida que ingresan al ecosistema de Quarkus. El estado ofrece el valor esperado de confianza</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*Preview*: backward compatibility and presence in the ecosystem is not guaranteed. Specific improvements might require to change configuration or APIs and plans to become _stable_ are under way. Such extensions are in the middle of their maturation process.
</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>*Preview*: la compatibilidad con versiones anteriores y la presencia en el ecosistema no están garantizadas. Ciertas mejoras pueden requerir cambios de configuración o API, y hay planes en marcha para volverse _stable_. Estas extensiones están en medio del proceso de maduración.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Can I write an extension?</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>¿Puedo crear una extensión?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Oh yeah! We had quite a few extensions written outside the Quarkus "initial" team.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>¡Por supuesto! Se ha creado un número significativo de extensiones fuera del equipo "inicial" de Quarkus.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>## What is GraalVM?</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>## ¿Qué es GraalVM?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example by default reflection in GraalVM will not work, unless a class/member has been explicitly registered for reflection. This is normally achieved by listing every class, method, field and constructor in a JSON file, and passing this as a parameter into the native image build. This obviously gets quite cumbersome for all but the most trivial projects. Quarkus provides a framework that makes it easy to work around these annotations, and programmatically determine what should be registered.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Por ejemplo, de forma predeterminada, la reflexión en GraalVM no funcionará, a menos que una clase/miembro se haya registrado explícitamente para la reflexión. Esto normalmente se logra listando cada clase, método, campo y constructor en un archivo JSON, y pasándolo como un parámetro Obviamente, esto se vuelve bastante engorroso para todos los proyectos, excepto para los más triviales. Quarkus proporciona un marco que facilita el trabajo en torno a estas anotaciones y proporciona un marco que le permite decidir mediante programación qué registrar</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>## How do you unify imperative and reactive programming?</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>## ¿Cómo se unifica la programación imperativa y reactiva?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>## What does Container First mean?</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>## ¿Qué significa Container First?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>## What is your view on standards?</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>## ¿Cuál es su punto de vista sobre los estándares?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>## What are you doing to improve developer joy?</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>## ¿Qué estás haciendo para mejorar la alegría de los desarrolladores?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Browse through these selections of new Quarkus related books and resources to expand your knowledge and hone your coding skills to step up your Quarkus game.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Explore estas selecciones de nuevos libros y recursos relacionados con Quarkus para expandir su conocimiento y perfeccionar sus habilidades de codificación para mejorar su juego de Quarkus</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What's next?</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>¿Qué es lo que sigue?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn how to create a Hello World Quarkus app.  This guide covers:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Aprende como crear una aplicación Hello World de Quarkus. Esta guía cubre:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you have multiple JDK's installed it is not certain Maven will pick up the expected java and you could end up with unexpected results.  You can verify which JDK Maven uses by running `mvn --version`.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Si tienes varios JDK's instalados no es seguro que Maven use el java esperado y podrías terminar con resultados inesperados. Puedes verificar qué JDK utiliza Maven ejecutando `mvn --version`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we create a straightforward application serving a `hello` endpoint. To demonstrate dependency injection, this endpoint uses a `greeting` bean.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>En esta guía, creamos una aplicación sencilla que sirve un endpoint de `hello`. Para demostrar la inyección de dependencias, este endpoint utiliza un bean `greeting`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>a landing page that is accessible on `http://localhost:8080` after starting the application</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>una página inicial que es accesible en `&amp;lt;a href="http://localhost:8080" class="bare"&amp;gt;http://localhost:8080&amp;lt;/a&amp;gt;` después de iniciar la aplicación</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With Quarkus, there is no need to create an `Application` class. It's supported, but not required. In addition, only one instance of the resource is created and not one per request. You can configure this using the different `*Scoped` annotations (`ApplicationScoped`, `RequestScoped`, etc).</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Con Quarkus, no es necesario crear una clase `Application`. Se admite, pero no se requiere. Además, solo se crea una instancia del recurso y no una por solicitud. Esto se puede configurar utilizando las diferentes anotaciones de `*Scoped` ( `ApplicationScoped`, `RequestScoped`, etc).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By using the `QuarkusTest` runner, you instruct JUnit to start the application before the tests.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Utilizando el runner `QuarkusTest`, se indica a JUnit que inicie la aplicación antes que las pruebas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The test port can be controlled via the `quarkus.http.test-port` config property. Quarkus also creates a system property called `test.url` that is set to the base test URL for situations where you cannot use injection.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>El puerto de prueba puede ser controlado a través de la propiedad de configuración `quarkus.http.test-port`. Quarkus también crea una propiedad del sistema llamada `test.url` que se establece en la URL de prueba base para situaciones en las que no se puede utilizar la inyección.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus heavily utilizes https://github.com/wildfly/jandex[Jandex] at build time, to discover various classes or annotations. One immediately recognizable application of this, is CDI bean discovery.  As a result, most of the Quarkus extensions will not work properly if this build time discovery isn't properly setup.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Quarkus utiliza en gran medida https://github.com/wildfly/jandex[Jandex] en tiempo de construcción, para descubrir varias clases o anotaciones. Una aplicación inmediatamente reconocible de esto, es el descubrimiento de bean CDI. Como resultado, la mayoría de las extensiones de Quarkus no funcionarán correctamente si este descubrimiento en tiempo de construcción no está configurado correctamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you plan to use external modules (for example, an external library for all your domain objects), you will need to make these modules known to the indexing process either by adding the Jandex plugin (if you can modify them)  or via the `quarkus.index-dependency` property inside your `application.properties` (useful in cases where you can't modify the module).</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Si tiene previsto utilizar módulos externos (por ejemplo, una biblioteca externa para todos sus objetos de dominio), tendrá que dar a conocer estos módulos al proceso de indexación, ya sea añadiendo el plugin de Jandex (si puede modificarlos) o a través de la propiedad `quarkus.index-dependency` dentro de su `application.properties` (útil en los casos en que no pueda modificar el módulo).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default when a Quarkus application starts (in regular or dev mode), it will display an ASCII art banner. The banner can be disabled by setting `quarkus.banner.enabled=false` in `application.properties`, by setting the `-Dquarkus.banner.enabled=false` Java System Property, or by setting the `QUARKUS_BANNER_ENABLED` environment variable to `false`.  Furthermore, users can supply a custom banner by placing the banner file in `src/main/resources` and configuring `quarkus.banner.path=name-of-file` in `application.properties`.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Por defecto, cuando una aplicación Quarkus se inicia (en modo normal o dev), mostrará un banner de arte ASCII. El banner puede deshabilitarse configurando `quarkus.banner.enabled=false` en `application.properties`, configurando la propiedad del sistema Java `-Dquarkus.banner.enabled=false`, o configurando la variable de entorno `QUARKUS_BANNER_ENABLED` en `false`. Además, los usuarios pueden proporcionar un banner personalizado colocando el archivo de banner en `src/main/resources` y configurando `quarkus.banner.path=name-of-file` en `application.properties`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the `quarkus-app` directory which contains the `quarkus-run.jar` jar file - being an executable _jar_. Be aware that it's not an _über-jar_ as the dependencies are copied into subdirectories of `quarkus-app/lib/`.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>el directorio `quarkus-app` que contiene el archivo jar `quarkus-run.jar` - siendo un _jar_ ejecutable. Tenga en cuenta que no es un _über-jar_ ya que las dependencias se copian en subdirectorios de `quarkus-app/lib/`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to deploy your application somewhere (typically in a container), you need to deploy the whole `quarkus-app` directory.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Si quieres desplegar tu aplicación en algún lugar (normalmente en un contenedor), necesitas desplegar todo el directorio `quarkus-app`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If using Powershell , wrap `-D` parameters in double quotes e.g. `"-DprojectArtifactId=getting-started"`</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Si utiliza Powershell, envuelva los parámetros de `-D` entre comillas dobles, por ejemplo `"-DprojectArtifactId=getting-started"`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once generated, look at the `pom.xml`.  You will find the import of the Quarkus BOM, allowing you to omit the version of the different Quarkus dependencies.  In addition, you can see the `quarkus-maven-plugin` responsible of the packaging of the application and also providing the development mode.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Una vez generado, mira el `pom.xml`. Encontrarás la importación Quarkus BOM, permitiendo omitir la versión de las diferentes dependencias de Quarkus. Además, se puede ver el `quarkus-maven-plugin` responsable del empaquetado de la aplicación y también proporcionar el modo de desarrollo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dependency injection in Quarkus is based on ArC which is a CDI-based dependency injection solution tailored for Quarkus' architecture.  If you're new to CDI then we recommend you to read the xref:cdi.adoc[Introduction to CDI] guide.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>La inyección de dependencias en Quarkus se basa en ArC, que es una solución de inyección de dependencias basada en CDI y adaptada a la arquitectura de Quarkus. Si eres nuevo en CDI, te recomendamos que leas la guía de xref:cdi.adoc[Introduction to CDI].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's modify the application and add a companion bean.  Create the `src/main/java/org/acme/GreetingService.java` file with the following content:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Vamos a modificar la aplicación y a añadir un bean de acompañamiento. Crea el archivo `src/main/java/org/acme/GreetingService.java` con el siguiente contenido:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus:dev` runs Quarkus in development mode. This enables live reload with background compilation, which means that when you modify your Java files and/or your resource files and refresh your browser, these changes will automatically take effect.  This works too for resource files like the configuration property file.  Refreshing the browser triggers a scan of the workspace, and if any changes are detected, the Java files are recompiled and the application is redeployed; your request is then serviced by the redeployed application. If there are any issues with compilation or deployment an error page will let you know.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>`quarkus:dev` ejecuta Quarkus en modo de desarrollo. Esto permite la recarga en vivo con compilación en segundo plano, lo que significa que cuando se modifican los archivos Java y/o los archivos de recursos y se actualiza el navegador, estos cambios tendrán efecto automáticamente. Esto funciona también para los archivos de recursos como el archivo de propiedades de configuración. Al actualizar el navegador, se realiza un análisis del área de trabajo y, si se detecta algún cambio, se recopilaran los archivos Java y se vuelve a desplegar la aplicación; la solicitud se atiende entonces con la aplicación re-desplegada. Si hay algún problema con la compilación o el despliegue, una página de error le informará.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus supports https://junit.org/junit5/[JUnit 5] tests.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Quarkus es compatible con las pruebas de https://junit.org/junit5/[JUnit 5].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Because of this, in the case of Maven, the version of the https://maven.apache.org/surefire/maven-surefire-plugin/[Surefire Maven Plugin] must be set, as the default version does not support JUnit 5:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Debido a esto, en el caso de Maven, se debe establecer la versión del https://maven.apache.org/surefire/maven-surefire-plugin/[Surefire Maven Plugin], ya que la versión por defecto no soporta JUnit 5:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The generated project contains a simple test.  Edit the `src/test/java/org/acme/GreetingResourceTest.java` to match the following content:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>El proyecto generado contiene una prueba sencilla. Edite el `src/test/java/org/acme/GreetingResourceTest.java` para que coincida con el siguiente contenido:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>However, when working with a multi-module project, be sure to read the `Working with multi-module projects` section of the xref:maven-tooling.adoc#multi-module-maven[Maven] or xref:gradle-tooling.adoc#multi-module-maven[Gradle] guides.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Sin embargo, cuando trabajes con un proyecto multimódulo, asegúrate de leer la sección `Working with multi-module projects` de las guías de xref:maven-tooling.adoc#multi-module-maven[Maven] o xref:gradle-tooling.adoc#multi-module-maven[Gradle] </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covered the creation of an application using Quarkus.  However, there is much more.  We recommend continuing the journey with the xref:building-native-image.adoc[building a native executable guide], where you learn about creating a native executable and packaging it in a container.  If you are interested in reactive, we recommend the xref:getting-started-reactive.adoc[Getting Started with Reactive guide], where you can see how to implement reactive applications with Quarkus.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Esta guía cubre la creación de una aplicación utilizando Quarkus. Sin embargo, hay mucho más. Recomendamos continuar el viaje con la guía de xref:building-native-image.adoc[building a native executable guide], donde se aprende a crear un ejecutable nativo y empaquetarlo en un contenedor. Si te interesa lo reactivo, te recomendamos la guía xref:getting-started-reactive.adoc[Getting Started with Reactive guide], donde podrás ver cómo implementar aplicaciones reactivas con Quarkus.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Short informative videos that highlight unique technical points and instructions on how to get the most out of Quarkus.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Vídeos informativos cortos que destacan puntos técnicos únicos e instrucciones sobre cómo sacar el máximo partido a Quarkus</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Why follow this process</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>¿Por qué seguir este proceso?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The community will fix security bugs for the latest major.minor version published at https://quarkus.io/get-started/.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>La comunidad corregirá los errores de seguridad para la última versión major.minor publicada en [https://quarkus.io/get-started/](https://quarkus.io/get-started/).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Support When You Need It.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Soporte cuando lo necesite</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus team and community take all security bugs very seriously. You can find our guidelines here regarding our policy and security disclosure.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>El equipo y la comunidad de Quarkus se toman muy en serio todos los errores de seguridad. Puede encontrar nuestras pautas aquí con respecto a nuestra política y divulgación de seguridad</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus has been honored to receive multiple awards and recognition. We feel these are an affirmation of the great work being done by our dedicated community. We’ve started a trophy case to share the kudos with everyone.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Quarkus ha tenido el honor de recibir múltiples premios y reconocimientos. Creemos que estos son una afirmación del gran trabajo realizado por nuestra comunidad dedicada. Hemos comenzado una vitrina de trofeos para compartir las felicitaciones con todos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Multiple ways to connect with others via forum, stack, chat, or email groups.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Múltiples formas de conectarse con otros a través de foros, stack, chat o grupos de correo electrónico</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus applications are optimised for low memory usage and fast startup times.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Las aplicaciones de Quarkus están optimizadas para un uso de memoria bajo y tiempos de inicio rápidos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus 2.0 continues the mission of making Java the preferred framework for Kubernetes-native development with new developer tools and improved performance.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Quarkus 2.0 continúa la misión de hacer de Java el marco preferido para el desarrollo nativo de Kubernetes con nuevas herramientas para desarrolladores y un rendimiento mejorado</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In addition, the xref:tooling.adoc[tooling guide] document explains how to:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Además, el documento xref:tooling.adoc[Guía de herramientas] explica cómo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is a collection of preferred term in the documentation and website.  Please stay within these terms for consistency.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Esta es una colección de términos preferidos en la documentación y el sitio web. Por favor, manténgase dentro de estos términos por coherencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>* Substrate VM</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>* Substrate VM</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>* Docker image</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>* Imagen Docker</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>imperative and reactive. 'Nuff said.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>imperativo y reactivo. No hay más que decir.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Credential profiles file at the default location (`~/.aws/credentials`) shared by all AWS SDKs and the AWS CLI</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Archivo de perfiles de credenciales en la ubicación por defecto ( `~/.aws/credentials`) compartido por todos los SDKs de AWS y la CLI de AWS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Amazon Lambda</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Amazon Lambda</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `quarkus-amazon-lambda` extension allows you to use Quarkus to build your AWS Lambdas.  Your lambdas can use injection annotations from CDI or Spring and other Quarkus facilities as you need them.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>La extensión `quarkus-amazon-lambda` le permite utilizar Quarkus para construir sus AWS Lambdas. Tus lambdas pueden utilizar anotaciones de inyección de CDI o Spring y otras facilidades de Quarkus según las necesites.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus's integration with lambdas also supports Quarkus's Live Coding development cycle.  You an bring up your Quarkus lambda project in dev or test mode and code on your project live.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>La integración de Quarkus con las lambdas también es compatible con el ciclo de desarrollo Live Coding de Quarkus. Usted puede traer su proyecto Quarkus lambda en el modo de desarrollo o de prueba y el código en su proyecto en vivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Installing all the AWS bits is probably the most difficult thing about this guide.  Make sure that you follow all the steps for installing AWS CLI.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Instalar todos los bits de AWS es probablemente lo más difícil de esta guía. Asegúrate de seguir todos los pasos para instalar AWS CLI.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `quarkus-amazon-lambda` extension scans your project for a class that directly implements the Amazon `RequestHandler&lt;?, ?&gt;` or `RequestStreamHandler` interface.  It must find a class in your project that implements this interface or it will throw a build time failure.  If it finds more than one handler class, a build time exception will also be thrown.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>La extensión `quarkus-amazon-lambda` busca en tu proyecto una clase que implemente directamente la interfaz de Amazon `RequestHandler&lt;?, ?&gt;` o `RequestStreamHandler`. Debe encontrar una clase en tu proyecto que implemente esta interfaz o lanzará un fallo de compilación. Si encuentra más de una clase manejadora, también se lanzará una excepción de tiempo de compilación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sometimes, though, you might have a few related lambdas that share code and creating multiple maven modules is just an overhead you don't want to do.  The `quarkus-amazon-lambda` extension allows you to bundle multiple lambdas in one project and use configuration or an environment variable to pick the handler you want to deploy.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>A veces, sin embargo, puedes tener unas cuantas lambdas relacionadas que comparten código y crear múltiples módulos de maven es una sobrecarga que no quieres hacer. La extensión `quarkus-amazon-lambda` te permite agrupar múltiples lambdas en un proyecto y utilizar la configuración o una variable de entorno para elegir el manejador que quieres desplegar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The generated project has three lambdas within it.  Two that implement the `RequestHandler&lt;?, ?&gt;` interface, and one that implements the `RequestStreamHandler` interface. One that is used and two that are unused.  If you open up `src/main/resources/application.properties` you'll see this:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>El proyecto generado tiene tres lambdas dentro de él. Dos que implementan la interfaz `RequestHandler&lt;?, ?&gt;`, y una que implementa la interfaz `RequestStreamHandler`. Una que se usa y dos que no se usan. Si abres `src/main/resources/application.properties` verás esto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The CDI name of the handler class must match the value specified within the `quarkus.lambda.handler` property.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>El nombre CDI de la clase manejadora debe coincidir con el valor especificado en la propiedad `quarkus.lambda.handler`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are a few steps to get your lambda running on AWS.  The generated maven project contains a helpful script to create, update, delete, and invoke your lambdas for pure Java and native deployments.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Hay algunos pasos para conseguir que su lambda se ejecute en AWS. El proyecto maven generado contiene un script útil para crear, actualizar, eliminar e invocar sus lambdas para implementaciones puramente Java y nativas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>View the https://docs.aws.amazon.com/lambda/latest/dg/gettingstarted-awscli.html[Getting Started Guide] for deploying a lambda with AWS CLI.  Specifically, make sure you have created an `Execution Role`.  You will need to define a `LAMBDA_ROLE_ARN` environment variable in your profile or console window, Alternatively, you can edit the `manage.sh` script that is generated by the build and put the role value directly there:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Consulte la https://docs.aws.amazon.com/lambda/latest/dg/gettingstarted-awscli.html[Guía de inicio] para implementar un lambda con AWS CLI. Específicamente, asegúrese de haber creado un `Execution Role`. Tendrá que definir una variable de entorno `LAMBDA_ROLE_ARN` en su perfil o ventana de consola, alternativamente, puede editar el script `manage.sh` que es generado por la construcción y poner el valor del rol directamente allí:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>After you run the build, there are a few extra files generated by the `quarkus-amazon-lambda` extension.  These files are in the the build directory: `target/` for maven, `build/` for gradle.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Después de ejecutar la construcción, hay algunos archivos adicionales generados por la extensión `quarkus-amazon-lambda`. Estos archivos están en el directorio de construcción: `target/` para maven, `build/` para gradle.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `target/manage.sh` script is for managing your lambda using the AWS Lambda Java runtime.  This script is provided only for your convenience. Examine the output of the `manage.sh` script if you want to learn what aws commands are executed to create, delete, and update your lambdas.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>El script `target/manage.sh` es para administrar su lambda utilizando el tiempo de ejecución de AWS Lambda Java. Este script se proporciona sólo para su comodidad. Examine la salida del script `manage.sh` si desea saber qué comandos de aws se ejecutan para crear, eliminar y actualizar sus lambdas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To verify your setup, that you have the AWS CLI installed, executed aws configure for the AWS access keys, and setup the `LAMBDA_ROLE_ARN` environment variable (as described above), please execute `manage.sh` without any parameters.  A usage statement will be printed to guide you accordingly.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Para verificar su configuración, que tiene la CLI de AWS instalada, ha ejecutado aws configure para las claves de acceso de AWS y ha configurado la variable de entorno `LAMBDA_ROLE_ARN` (como se ha descrito anteriormente), ejecute `manage.sh` sin ningún parámetro. Se imprimirá una declaración de uso para guiarte en consecuencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To see the `usage` statement, and validate AWS configuration:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Para ver la declaración `usage`, y validar la configuración de AWS:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can `create` your function using the following command:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Puede crear su función utilizando el siguiente comando, `create` :</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Do not change the handler switch.  This must be hardcoded to `io.quarkus.amazon.lambda.runtime.QuarkusStreamHandler::handleRequest`.  This handler bootstraps Quarkus and wraps your actual handler so that injection can be performed.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>No cambie el switch del manejador. Esto debe ser codificado en `io.quarkus.amazon.lambda.runtime.QuarkusStreamHandler::handleRequest`. Este manejador arranca Quarkus y envuelve su manejador real para que la inyección pueda ser realizada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If there are any problems creating the function, you must delete it with the `delete` function before re-running the `create` command.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Si hay algún problema en la creación de la función, debe borrarla con la función `delete` antes de volver a ejecutar el comando `create`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can update the Java code as you see fit.  Once you've rebuilt, you can redeploy your lambda by executing the `update` command.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Puedes actualizar el código Java como creas conveniente. Una vez que hayas reconstruido, puedes volver a desplegar tu lambda ejecutando el comando `update`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want a lower memory footprint and faster initialization times for your lambda, you can compile your Java code to a native executable.  Just make sure to rebuild your project with the `-Pnative` switch.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Si quieres una menor huella de memoria y tiempos de inicialización más rápidos para tu lambda, puedes compilar tu código Java a un ejecutable nativo. Sólo asegúrese de reconstruir su proyecto con el interruptor `-Pnative`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are building on a non-Linux system, you will need to also pass in a property instructing Quarkus to use a docker build as Amazon Lambda requires linux binaries.  You can do this by passing this property to your build: `-Dquarkus.native.container-build=true`. This requires you to have Docker installed locally, however.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Si estás construyendo en un sistema que no es Linux, tendrás que pasar también una propiedad que indique a Quarkus que utilice una construcción docker, ya que Amazon Lambda requiere binarios linux. Puedes hacerlo pasando esta propiedad a tu construcción: `-Dquarkus.native.container-build=true`. Sin embargo, esto requiere que tengas Docker instalado localmente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Either of these commands will compile and create a native executable image.  It also generates a zip file `target/function.zip`.  This zip file contains your native executable image renamed to `bootstrap`.  This is a requirement of the AWS Lambda Custom (Provided) Runtime.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Cualquiera de estos comandos compilará y creará una imagen ejecutable nativa. También genera un archivo zip `target/function.zip`. Este archivo zip contiene su imagen ejecutable nativa renombrada a `bootstrap`. Este es un requisito del tiempo de ejecución personalizado (proporcionado) de AWS Lambda.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The instructions here are exactly as above with one change: you'll need to add `native` as the first parameter to the `manage.sh` script:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Las instrucciones son exactamente las mismas que las anteriores con un cambio: tendrá que añadir `native` como primer parámetro del script `manage.sh`:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As above, commands can be stacked.  The only requirement is that `native` be the first parameter should you wish to work with native image builds.  The script will take care of the rest of the details necessary to manage your native image function deployments.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Como en el caso anterior, los comandos se pueden apilar. El único requisito es que `native` sea el primer parámetro si desea trabajar con construcciones de imágenes nativas. El script se encargará del resto de los detalles necesarios para gestionar sus despliegues de funciones de imagen nativa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is nothing special about the POM other than the inclusion of the `quarkus-amazon-lambda` extension as a dependency.  The extension automatically generates everything you might need for your lambda deployment.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>No hay nada especial en el POM, aparte de la inclusión de la extensión `quarkus-amazon-lambda` como dependencia. La extensión genera automáticamente todo lo que puedas necesitar para tu despliegue de lambda.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Gradle build</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Construcción de Gradle</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Similarly for Gradle projects, you also just have to add the `quarkus-amazon-lambda` dependency.  The extension automatically generates everything you might need for your lambda deployment.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Del mismo modo, para los proyectos de Gradle, también sólo tienes que añadir la dependencia de `quarkus-amazon-lambda`. La extensión genera automáticamente todo lo que puedas necesitar para el despliegue de tu lambda.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To mirror the AWS Lambda environment as closely as possible in a dev environment, the Quarkus Amazon Lambda extension boots up a mock AWS Lambda event server in Quarkus Dev and Test mode.  This mock event server simulates a true AWS Lambda environment.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Para reflejar el entorno de AWS Lambda con la mayor exactitud posible en un entorno de desarrollo, la extensión de Quarkus Amazon Lambda inicia un servidor de eventos de AWS Lambda falso en el modo de desarrollo y prueba de Quarkus. Este servidor de eventos falso simula un verdadero entorno de AWS Lambda.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While running in Quarkus Dev Mode, you can feed events to it by doing an HTTP POST to `http://localhost:8080`.  The mock event server will receive the events and your lambda will be invoked.  You can perform live coding on your lambda and changes will automatically be recompiled and available the next invocation you make.  Here's an example:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Mientras se ejecuta en el modo de desarrollo de Quarkus, puede alimentar los eventos haciendo un POST HTTP a `http://localhost:8080`. El servidor de eventos falso recibirá los eventos y su lambda será invocado. Puedes realizar codificación en vivo en tu lambda y los cambios se recompilarán automáticamente y estarán disponibles en la siguiente invocación que hagas. Aquí tienes un ejemplo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For your unit tests, you can also invoke on the mock event server using any HTTP client you want.  Here's an example using rest-assured.  Quarkus starts up a separate Mock Event server under port 8081.  The default port for Rest Assured is automatically set to 8081 by Quarkus so you can invoke on this endpoint.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Para tus pruebas unitarias, también puedes invocar en el servidor de eventos falso usando cualquier cliente HTTP que quieras. Aquí hay un ejemplo usando rest-assured. Quarkus inicia un servidor de eventos simulados separado bajo el puerto 8081. El puerto por defecto para Rest Assured se establece automáticamente a 8081 por Quarkus para que pueda invocar en este punto final.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The mock event server is also started for `@NativeImageTest` and `@QuarkusIntegrationTest` tests so will work with native binaries too.  All this provides similar functionality to the SAM CLI local testing, without the overhead of Docker.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>El servidor de eventos simulados también se inicia para las pruebas de `@NativeImageTest` y `@QuarkusIntegrationTest`, por lo que también funcionará con binarios nativos. Todo esto proporciona una funcionalidad similar a las pruebas locales de SAM CLI, sin la sobrecarga de Docker.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-sam-cli-install.html[AWS SAM CLI] allows you to run your lambdas locally on your laptop in a simulated Lambda environment.  This requires https://www.docker.com/products/docker-desktop[docker] to be installed.  This is an optional approach should you choose to take advantage of it.  Otherwise, the Quarkus JUnit integration should be sufficient for most of your needs.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>La  https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-sam-cli-install.html[AWS SAM CLI]  le permite ejecutar sus lambdas localmente en su portátil en un entorno de Lambda simulado. Esto requiere la instalación de https://www.docker.com/products/docker-desktop[docker]. Este es un enfoque opcional en caso de que decidas aprovecharlo. De lo contrario, la integración de Quarkus JUnit debería ser suficiente para la mayoría de sus necesidades.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Run the following SAM CLI command to locally test your lambda function, passing the appropriate SAM `template`.  The `event` parameter takes any JSON file, in this case the sample `payload.json`.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Ejecute el siguiente comando CLI de SAM para probar localmente su función lambda, pasando el parámetro apropiado de SAM `template`. El parámetro `event` toma cualquier archivo JSON, en este caso el ejemplo `payload.json`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The native image can also be locally tested using the `sam.native.yaml` template:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>La imagen nativa también puede probarse localmente utilizando la plantilla `sam.native.yaml`:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The are times where you may have to add some additions to the `function.zip` lambda deployment that is generated by the build.  To do this create a `zip.jvm` or `zip.native` directory within `src/main`.  Create `zip.jvm/` if you are doing a pure Java lambda.  `zip.native/` if you are doing a native deployment.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Hay veces en las que puedes tener que añadir algunas adiciones al despliegue de lambda `function.zip` que es generado por la construcción. Para ello crea un directorio `zip.jvm` o `zip.native` dentro de `src/main`. Crea `zip.jvm/` si estás haciendo una lambda puramente Java. `zip.native/` si estás haciendo un despliegue nativo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are times you may want to set a specific system properties or other arguments when lambda invokes your native quarkus lambda deployment.  If you include a `bootstrap` script file within `zip.native`, the quarkus extension will automatically rename the executable to `runner` within `function.zip` and set the unix mode of the `bootstrap` script to executable.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Hay veces que puedes querer establecer unas propiedades específicas del sistema u otros argumentos cuando lambda invoca tu despliegue lambda nativo de quarkus. Si incluyes un archivo de script `bootstrap` dentro de `zip.native`, la extensión quarkus renombrará automáticamente el ejecutable a `runner` dentro de `function.zip` y establecerá el modo unix del script `bootstrap` a ejecutable.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The native executable must be referenced as `runner` if you include a custom `bootstrap` script.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>El ejecutable nativo debe ser referenciado como `runner` si incluye un script personalizado de `bootstrap`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are building native images, and want to use https://aws.amazon.com/xray[AWS X-Ray Tracing] with your lambda you will need to include `quarkus-amazon-lambda-xray` as a dependency in your pom.  The AWS X-Ray library is not fully compatible with GraalVM so we had to do some integration work to make this work.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Si estás construyendo imágenes nativas, y quieres usar https://aws.amazon.com/xray[AWS X-Ray Tracing] con tu lambda necesitarás incluir `quarkus-amazon-lambda-xray` como una dependencia en tu pom. La biblioteca de AWS X-Ray no es totalmente compatible con GraalVM, por lo que hemos tenido que hacer un trabajo de integración para que funcione.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In addition, remember to enable the AWS X-Ray tracing parameter in `manage.sh`, in the `cmd_create()` function.  This can also be set in the AWS Management Console.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Además, recuerde habilitar el parámetro de rastreo de AWS X-Ray en `manage.sh`, en la función `cmd_create()`. Esto también se puede configurar en la consola de administración de AWS.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>AWS X-Ray does add many classes to your distribution, do ensure you are using at least the 256MB AWS Lambda memory size.  This is explicitly set in `manage.sh` `cmd_create()`. Whilst the native image potentially can always use a lower memory setting, it would be recommended to keep the setting the same, especially to help compare performance.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>AWS X-Ray añade muchas clases a su distribución, asegúrese de que está utilizando al menos el tamaño de memoria de 256 MB de AWS Lambda. Esto se establece explícitamente en `manage.sh` `cmd_create()` . Aunque la imagen nativa siempre puede utilizar una configuración de memoria más baja, se recomienda mantener la misma configuración, especialmente para ayudar a comparar el rendimiento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If your code makes HTTPS calls, such as to a micro-service (or AWS service), you will need to add configuration to the native image, as GraalVM will only include the dependencies when explicitly declared.  Quarkus, by default enables this functionality on extensions that implicitly require it.  For further information, please consult the xref:native-and-ssl.adoc[Quarkus SSL guide]</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Si tu código hace llamadas HTTPS, como por ejemplo a un microservicio (o servicio AWS), tendrás que añadir la configuración a la imagen nativa, ya que GraalVM sólo incluirá las dependencias cuando se declaren explícitamente. Quarkus, por defecto habilita esta funcionalidad en las extensiones que implícitamente lo requieren. Para más información, consulta la xref:native-and-ssl.adoc[Guía de Quarkus SSL]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus now has extensions for DynamoDB, S3, SNS and SQS (more coming).  Please check link:{amazon-services-guide}[those guides] on how to use the various AWS Services with Quarkus, as opposed to wiring manually like below.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Quarkus ahora tiene extensiones para DynamoDB, S3, SNS y SQS (más en camino). Por favor, consulte link:{amazon-services-guide}[estas guías] sobre cómo utilizar los diversos servicios de AWS con Quarkus, en lugar de cablear manualmente como se indica a continuación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Add `quarkus-jaxb` as a dependency in your Maven `pom.xml`, or Gradle `build.gradle` file.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Añade `quarkus-jaxb` como dependencia en tu archivo Maven `pom.xml`, o Gradle `build.gradle`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>if you see `java.security.InvalidAlgorithmParameterException: the trustAnchors parameter must be non-empty` or similar SSL error, due to the current status of GraalVM, there is some additional work to bundle the `function.zip`, as below.  For more information, please see the xref:native-and-ssl.adoc[Quarkus Native SSL Guide].</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>si ves `java.security.InvalidAlgorithmParameterException: the trustAnchors parameter must be non-empty` o un error SSL similar, debido al estado actual de GraalVM, hay algo de trabajo adicional para agrupar el `function.zip`, como se indica a continuación. Para más información, por favor vea la xref:native-and-ssl.html[Guía de SSL nativa de Quarkus].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To do this, first create a directory `src/main/zip.native/` with your build.  Next create a shell script file called `bootstrap` within `src/main/zip.native/`, like below. An example is create automatically in your build folder (target or build), called `bootstrap-example.sh`</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Para ello, primero cree un directorio `src/main/zip.native/` con su construcción. A continuación, cree un archivo de secuencia de comandos llamado `bootstrap` dentro de `src/main/zip.native/`, como se indica a continuación. Un ejemplo es crear automáticamente en su carpeta de construcción (target o build), llamado `bootstrap-example.sh`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Second, cacerts, the certificate store.  You may need to periodically obtain an updated copy, also.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>En segundo lugar, cacerts, el almacén de certificados. Es posible que tenga que obtener periódicamente una copia actualizada, también.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For a regular JVM distribution you need to base your image off the official AWS Java base images. Below is an example of a Dockerfile that would create a container image from your Quarkus Lambda project. It assumes that `mvn package` has been executed and binaries are available in the `target/` directory:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Para una distribución regular de JVM necesitas basar tu imagen en las imágenes base oficiales de AWS Java. A continuación se muestra un ejemplo de un archivo Docker que crearía una imagen de contenedor de su proyecto Quarkus Lambda. Asume que `mvn package` ha sido ejecutado y los binarios están disponibles en el directorio `target/`:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To create a lambda container image that uses the native executable we'll need to do things a little differently. In this case, we won't need to use the `java:11` base image from AWS but instead we'll use a special image that assumes that the runtime environment for the lambda is provided. The example below creates such a container. It assumes that a Maven build has been executed (such as `mvn package -Dnative=true`) and has generated the native binary into the `target/` directory. The binary needs to be named `bootstrap` and be placed in `/var/runtime/`:</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Para crear una imagen de contenedor lambda que utilice el ejecutable nativo tendremos que hacer las cosas de forma un poco diferente. En este caso, no necesitaremos utilizar la imagen base de `java:11` de AWS, sino que utilizaremos una imagen especial que asume que se proporciona el entorno de ejecución para lambda. El siguiente ejemplo crea un contenedor de este tipo. Asume que se ha ejecutado una construcción de Maven (como `mvn package -Dnative=true`) y ha generado el binario nativo en el directorio `target/`. El binario necesita ser llamado `bootstrap` y ser colocado en `/var/runtime/`:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Below, you can see how the container images created above can be built and deployed to AWS using the `docker` and `aws` command line tools. These instructions work for both native and jvm container images and assume that the `aws` command line tool has been logged in.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>A continuación, puede ver cómo las imágenes de contenedor creadas anteriormente pueden construirse e implementarse en AWS utilizando las herramientas de línea de comandos `docker` y `aws`. Estas instrucciones funcionan tanto para imágenes de contenedor nativas como jvm y asumen que la herramienta de línea de comandos `aws` ha sido iniciada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Make sure you reference the image you uploaded previously (assumes that a role exists that can be used to run the lambda). Please note that it is not unlikely that for the JVM lambda function, the default memory limit of `128Mb` will not be enough to run the function. In that case, you can increase the memory limit when creating the function by providing the `--memory-size 256` parameter to your `aws lambda create-function` command. You can also adjust the function in the AWS console after you've created it.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Asegúrate de que haces referencia a la imagen que has subido previamente (se supone que existe un rol que puede ser utilizado para ejecutar la lambda). Ten en cuenta que no es improbable que para la función lambda de JVM, el límite de memoria por defecto de `128Mb` no sea suficiente para ejecutar la función. En ese caso, puede aumentar el límite de memoria al crear la función proporcionando el parámetro `--memory-size 256` a su comando `aws lambda create-function`. También puede ajustar la función en la consola de AWS después de haberla creado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus applications are designed to run in containers.</seg>
      </tuv>
      <tuv xml:lang="es_ES">
        <seg>Las aplicaciones de Quarkus están diseñadas para ejecutarse en contenedores.</seg>
      </tuv>
    </tu>
  </body>
</tmx>
