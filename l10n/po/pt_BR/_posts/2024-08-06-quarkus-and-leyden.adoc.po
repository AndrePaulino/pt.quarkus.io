msgid ""
msgstr ""
"Language: pt_BR\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: jekyll-l10n\n"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Project Leyden"
msgstr "Projeto Leyden"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Project Leyden: exploring its potential for Quarkus users."
msgstr "Projeto Leyden: explorando seu potencial para os usuários do Quarkus."

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "You might have heard of https://openjdk.org/projects/leyden/[Project Leyden], an initiative within the OpenJDK project with ambitious goals."
msgstr "O senhor já deve ter ouvido falar do link:https://openjdk.org/projects/leyden/[Projeto Leyden] , uma iniciativa do projeto OpenJDK com objetivos ambiciosos."

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "As Quarkus users, you'll be wondering how this project will benefit you and how it's different from GraalVM native images. While we think it's fair to say that Leyden was inspired or at least motivated by some ideas first implemented in GraalVM's native images, Leyden is remarkably different. It's essential to understand how it works: as we will see, Leyden is not a replacement for GraalVM native images but rather a substantial evolution of the JVM, and we expect it to bring some benefits to native images as well."
msgstr "Como usuários do Quarkus, os senhores devem estar se perguntando como esse projeto os beneficiará e como ele é diferente das imagens nativas do GraalVM. Embora acreditemos que seja justo dizer que o Leyden foi inspirado ou, pelo menos, motivado por algumas ideias implementadas pela primeira vez nas imagens nativas do GraalVM, o Leyden é notavelmente diferente. É essencial entender como ele funciona: como veremos, o Leyden não é um substituto para as imagens nativas do GraalVM, mas sim uma evolução substancial da JVM, e esperamos que ele também traga alguns benefícios para as imagens nativas."

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "To try to clarify this, unfortunately, this post is unusually long: we wish it could have been a short guide, \"This is how you enable Leyden,\" but this isn't quite the time yet, as we need to understand the different models first. Sometimes, the terminology is also different; for example, \"Ahead of Time (AOT)\" has a very specific meaning in the context of GraalVM native images and has traditionally been associated with \"compilation\", but in the context of Leyden is used more broadly to indicate a variety of aspects of JVM operation; hopefully, after reading this, it will be less confusing."
msgstr "Para tentar esclarecer isso, infelizmente, esta postagem é excepcionalmente longa: gostaríamos que tivesse sido um guia curto, \"É assim que o senhor habilita o Leyden\", mas ainda não é o momento, pois precisamos entender os diferentes modelos primeiro. Às vezes, a terminologia também é diferente; por exemplo, \"Ahead of Time (AOT)\" tem um significado muito específico no contexto das imagens nativas do GraalVM e tem sido tradicionalmente associado à \"compilação\", mas no contexto do Leyden é usado de forma mais ampla para indicar uma variedade de aspectos da operação da JVM; esperamos que, depois de ler isso, seja menos confuso."

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Another significant misconception about Leyden is that it's a project to \"improve startup times\"; this statement is not wrong, as improving startup times is one of its goals. Yet the other stated goals of the project offer even more significant potential for our favourite platform, Quarkus, and its users."
msgstr "Outro equívoco significativo sobre o Leyden é que ele é um projeto para \"melhorar os tempos de inicialização\"; essa afirmação não está errada, pois melhorar os tempos de inicialização é um de seus objetivos. No entanto, os outros objetivos declarados do projeto oferecem um potencial ainda mais significativo para nossa plataforma favorita, Quarkus, e seus usuários."

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "So, let's dive in."
msgstr "Então, vamos nos aprofundar."

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "What is Leyden?"
msgstr "O que é Leyden?"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Project Leyden is an initiative from the OpenJDK team. It is an ongoing experiment that is currently being developed by the joint effort of teams from different companies contributing to the project."
msgstr "O Projeto Leyden é uma iniciativa da equipe do OpenJDK. Trata-se de um experimento contínuo que está sendo desenvolvido pelo esforço conjunto de equipes de diferentes empresas que contribuem para o projeto."

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "The primary goal of this Project is to improve the startup time, time to peak performance, and footprint of Java programs."
msgstr "O principal objetivo deste projeto é melhorar o tempo de inicialização, o tempo para atingir o desempenho máximo e o espaço ocupado pelos programas Java."

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "-- Project Leyden, first thing on its project page"
msgstr "- Projeto Leyden, primeira coisa em sua página de projeto"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid ""
"Leyden is a general umbrella project to address slow startup and large footprint. It is useful to keep JDK bootstrap times and footprint low. This helps reduce energy consumption, hardware resource use, and, ultimately, monetary costs.\n"
"However, it's equally as essential to reduce the time to application peak performance, time usually spent loading application classes and executing application code, including JIT compiling methods on hot code paths. Reducing application footprint can have a tremendous impact and this can be achieved by trimming not just application data but also application classes and code. Leyden is addressing ways that the JVM can help developers achieve those goals; in many ways, this is complementary to the techniques offered by Quarkus at the framework level, so we expect some powerful results from them combined."
msgstr "O Leyden é um projeto geral para lidar com a inicialização lenta e o grande espaço ocupado. É útil manter baixos os tempos de inicialização e o espaço ocupado pelo JDK. Isso ajuda a reduzir o consumo de energia, o uso de recursos de hardware e, por fim, os custos monetários. No entanto, é igualmente essencial reduzir o tempo até o desempenho máximo do aplicativo, o tempo normalmente gasto para carregar as classes do aplicativo e executar o código do aplicativo, incluindo métodos de compilação JIT em caminhos de código quente. Reduzir o espaço ocupado pelo aplicativo pode ter um impacto enorme, e isso pode ser alcançado com a redução não apenas dos dados do aplicativo, mas também das classes e do código do aplicativo. O Leyden está abordando maneiras pelas quais a JVM pode ajudar os desenvolvedores a atingir essas metas; de muitas maneiras, isso é complementar às técnicas oferecidas pelo Quarkus no nível da estrutura, portanto, esperamos alguns resultados poderosos da combinação dos dois."

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Note that the project is evolving rapidly: some of the things explained in this article are evolving while this is written. If you plan on getting involved at a more technical level, follow the development in Jira and the https://mail.openjdk.org/mailman/listinfo/leyden-dev[Leyden mailing list]."
msgstr "Observe que o projeto está evoluindo rapidamente: algumas das coisas explicadas neste artigo estão evoluindo enquanto ele é escrito. Se o senhor pretende se envolver em um nível mais técnico, acompanhe o desenvolvimento no Jira e na link:https://mail.openjdk.org/mailman/listinfo/leyden-dev[lista de discussão do Leyden] ."

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Why it’s interesting to Quarkus"
msgstr "Por que isso é interessante para a Quarkus"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid ""
"From a Quarkus perspective, we've done a fair job on all such metrics but we're constantly on the lookout to improve.\n"
"That's why Project Leyden got our attention. We're already working with our colleagues from the OpenJDK team at Red Hat, who are directly involved in implementing Leyden with the wider OpenJDK group: this blog post today is a collaboration among engineers from different teams."
msgstr "Do ponto de vista da Quarkus, fizemos um bom trabalho em todas essas métricas, mas estamos sempre buscando melhorar. É por isso que o Projeto Leyden chamou nossa atenção. Já estamos trabalhando com nossos colegas da equipe OpenJDK da Red Hat, que estão diretamente envolvidos na implementação do Leyden com o grupo OpenJDK mais amplo: esta postagem do blog de hoje é uma colaboração entre engenheiros de diferentes equipes."

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Although Quarkus is already doing a lot of work during the Ahead of Time phase to speed up warmup and response time, the enhancements that Leyden brings to the table are more related to how the JVM behaves. Complementing both approaches, the advantages we can expect from the combination of Quarkus and Leyden are beyond anything you can find with either of them in isolation."
msgstr "Embora o Quarkus já esteja fazendo muito trabalho durante a fase Ahead of Time para acelerar o aquecimento e o tempo de resposta, os aprimoramentos que o Leyden traz para a mesa estão mais relacionados à forma como a JVM se comporta. Complementando as duas abordagens, as vantagens que podemos esperar da combinação do Quarkus e do Leyden estão além de qualquer coisa que o senhor possa encontrar com qualquer um deles isoladamente."

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Since the potential for such technological collaboration is strong, the Quarkus and OpenJDK teams are working together on various prototypes and anyone in the community is welcome to join as well."
msgstr "Como o potencial para essa colaboração tecnológica é grande, as equipes do Quarkus e do OpenJDK estão trabalhando juntas em vários protótipos, e qualquer pessoa da comunidade também pode participar."

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Refresher on JVM's bootstrap process"
msgstr "Atualização sobre o processo de bootstrap da JVM"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid ""
"To better understand the scope of the potential improvements, we need to take a step back and discuss how the JVM works today, especially how our application is started and iteratively evolves from interpreting our bytecode to its highest performance mode: running native code which is highly optimized, adapted to the particular hardware, the configuration of the day, and the specific workloads it's been asked to perform.\n"
"No other runtime is able to match the JVM on this."
msgstr "Para entender melhor o escopo dos possíveis aprimoramentos, precisamos dar um passo atrás e discutir como a JVM funciona hoje, especialmente como nosso aplicativo é iniciado e evolui iterativamente da interpretação de nosso bytecode para seu modo de desempenho mais alto: executando código nativo altamente otimizado, adaptado ao hardware específico, à configuração do dia e às cargas de trabalho específicas que ele foi solicitado a executar. Nenhum outro tempo de execução é capaz de se igualar à JVM nesse aspecto."

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid ""
"As we all know, a Java runtime does not directly run Java source code. The content of our JAR file is not executable machine code, but Java bytecode generated from Java source code, typically using the javac compiler but in some cases Quarkus will emit directly generated bytecode.\n"
"A key feature of bytecode is portability, encoding the structure of Java classes and operation of their methods in a machine and operating-system independent format. A Java runtime obeys the type information in the bytecode when laying out Java objects. Execution of a method normally involves interpreting the operations in the method bytecode, although a runtime may also choose to compile method bytecode to equivalent, native machine code and execute the latter directly."
msgstr "Como todos sabemos, um tempo de execução Java não executa diretamente o código-fonte Java. O conteúdo do nosso arquivo JAR não é um código de máquina executável, mas um bytecode Java gerado a partir do código-fonte Java, normalmente usando o compilador javac, mas, em alguns casos, o Quarkus emitirá bytecode gerado diretamente. Um dos principais recursos do bytecode é a portabilidade, que codifica a estrutura das classes Java e a operação de seus métodos em um formato independente da máquina e do sistema operacional. O tempo de execução do Java obedece às informações de tipo no bytecode ao dispor os objetos Java. A execução de um método normalmente envolve a interpretação das operações no bytecode do método, embora o tempo de execução também possa optar por compilar o bytecode do método em um código de máquina nativo equivalente e executá-lo diretamente."

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "The unit of delivery for bytecode is a class file, which models a single class. The Java runtime itself provides a host of utility and runtime management classes, as class files embedded in either system jars or jmod files. Applications supplement this with their own class files, usually by appending jars to the classpath or module path."
msgstr "A unidade de entrega do bytecode é um arquivo de classe, que modela uma única classe. O próprio tempo de execução do Java fornece uma série de classes utilitárias e de gerenciamento de tempo de execução, como arquivos de classe incorporados em jars do sistema ou arquivos jmod. Os aplicativos complementam isso com seus próprios arquivos de classe, geralmente anexando jars ao classpath ou ao caminho do módulo."

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Bytecode is delivered class-at-a-time to allow the runtime to load classes _lazily_: i.e. the runtime will only lookup, verify and consume a class file when that class's definition is required to proceed with execution."
msgstr "O bytecode é fornecido classe por classe para permitir que o tempo de execução carregue as classes de _forma preguiçosa_ , ou seja, o tempo de execução só procurará, verificará e consumirá um arquivo de classe quando a definição dessa classe for necessária para prosseguir com a execução."

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Lazy loading is what allows Java to be a dynamic language -- i.e. one where the code that is included in the program can be decided at runtime. That might include loading classes from jars identified at runtime, possibly loaded via the network. Alternatively, it might include generating class bytecode at runtime, as is done with proxy classes or service provider auxiliary classes."
msgstr "O carregamento preguiçoso é o que permite que o Java seja uma linguagem dinâmica, ou seja, uma linguagem em que o código incluído no programa pode ser decidido no tempo de execução. Isso pode incluir o carregamento de classes de jars identificados em tempo de execução, possivelmente carregados pela rede. Como alternativa, pode incluir a geração de bytecode de classe em tempo de execução, como é feito com classes proxy ou classes auxiliares do provedor de serviços."

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Just in Time (JIT) and Ahead of Time (AOT)"
msgstr "Just in Time (JIT) e Ahead of Time (AOT)"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid ""
"Another name to describe Java's lazy loading is 'Just in Time' (JIT). JIT is a well known term used to describe the operation of Java's runtime compilers. What is less well known is that it has a much wider use.\n"
"JIT is not limited to compilation: many other operations performed by the JVM are done lazily at runtime or 'Just In Time'."
msgstr "Outro nome para descrever o carregamento preguiçoso do Java é \"Just in Time\" (JIT). JIT é um termo bem conhecido usado para descrever a operação dos compiladores de tempo de execução do Java. O que é menos conhecido é que ele tem um uso muito mais amplo. O JIT não se limita à compilação: muitas outras operações realizadas pela JVM são feitas de forma preguiçosa em tempo de execução ou \"Just In Time\"."

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid ""
"An alternative to doing things 'Just in Time' (JIT) is to do them 'Ahead Of Time' (AOT).\n"
"For example, GraalVM's Native Image runtime loads and analyses the bytecode of every single class needed by an application, including JDK runtime classes, 'Ahead Of Time' i.e. at image build time. It uses the type and method information encoded in that bytecode to 'Ahead Of Time' compile a complete program that includes code for every method that might possibly be executed by the application."
msgstr "Uma alternativa para fazer as coisas \"Just in Time\" (JIT) é fazê-las \"Ahead Of Time\" (AOT). Por exemplo, o tempo de execução da imagem nativa do GraalVM carrega e analisa o bytecode de cada classe necessária a um aplicativo, incluindo as classes de tempo de execução do JDK, \"Ahead Of Time\", ou seja, no momento da criação da imagem. Ele usa as informações de tipo e método codificadas nesse bytecode para compilar um programa completo que inclui código para cada método que possa ser executado pelo aplicativo."

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid ""
"The approach of GraalVM's native images lies at one extreme: everything is done AOT, while the traditional Java runtime model lies at the other extreme, as much as possible is done JIT.\n"
"However, it is actually possible to mix and match AOT and JIT models of execution in one runtime: re-balancing that AOT vs JIT mix is the goal of the first EA release of project Leyden."
msgstr "A abordagem das imagens nativas do GraalVM está em um extremo: tudo é feito AOT, enquanto o modelo tradicional de tempo de execução Java está no outro extremo, o máximo possível é feito JIT. No entanto, na verdade é possível misturar e combinar os modelos de execução AOT e JIT em um tempo de execução: reequilibrar essa mistura AOT vs JIT é o objetivo da primeira versão EA do projeto Leyden."

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Interestingly, this time-shifting concept is also applied by Quarkus; we called it \"augmentation\" and essentially consists in booting popular frameworks during the build time of the application, to not incur such performance penalties at runtime."
msgstr "Curiosamente, esse conceito de mudança de tempo também é aplicado pelo Quarkus; nós o chamamos de \"aumento\" e consiste essencialmente em inicializar estruturas populares durante o tempo de criação do aplicativo, para não incorrer em tais penalidades de desempenho no tempo de execução."

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid ""
"A native image build might also take advantage of Profile Guided Optimisations (PGO), which allows it to leverage some data about what's presumably happening at runtime back into the compilation process, guiding its optimisations.\n"
"It's essentially peeking into the future - another form of time-shifting.\n"
"However, it's only peeking into a simulation of runtime metrics, and ultimately, the compiler still needs to make all optimisation tradeoffs Ahead Of Time; this has pros and cons. The primary disadvantage is that any suboptimal decision is cast in stone; luckily there is a fallback mechanism to recover from outright bad decisions, but this mechanism cannot produce new optimal code. The advantage is more decisive for short-lived applications as the tradeoff of carrying all support for JIT optimisations in the runtime is less justifiable when there is barely an opportunity to take advantage of it."
msgstr "Uma compilação de imagem nativa também pode aproveitar as vantagens do Profile Guided Optimisations (PGO), que permite aproveitar alguns dados sobre o que está acontecendo em tempo de execução no processo de compilação, orientando suas otimizações. Essencialmente, isso é espiar o futuro - outra forma de deslocamento de tempo. No entanto, ele está apenas observando uma simulação de métricas de tempo de execução e, em última análise, o compilador ainda precisa fazer todas as compensações de otimização antes do tempo; isso tem prós e contras. A principal desvantagem é que qualquer decisão abaixo do ideal é gravada em pedra; felizmente, há um mecanismo de recuperação de decisões totalmente ruins, mas esse mecanismo não pode produzir um novo código ideal. A vantagem é mais decisiva para aplicativos de curta duração, já que a troca de carregar todo o suporte para otimizações JIT no tempo de execução é menos justificável quando mal há uma oportunidade de aproveitá-la."

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "On a default Java compilation and run, we have two distinct phases: First we compile the source code into bytecode. And then we use that bytecode to run the application."
msgstr "Em uma compilação e execução padrão do Java, temos duas fases distintas: Primeiro, compilamos o código-fonte em bytecode. E, em seguida, usamos esse bytecode para executar o aplicativo."

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Class Data Sharing (CDS) as a step to AOT Caching"
msgstr "Compartilhamento de dados de classe (CDS) como uma etapa para o cache de AOT"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Shifting work so it is done AOT is not a wholly new idea as far as the OpenJDK runtime is concerned. OpenJDK has supported a hybrid AOT/JIT class loading model for years with CDS. The observation that led to https://docs.oracle.com/en/java/javase/21/vm/class-data-sharing.html[Class Data Sharing (CDS)] being proposed was that most applications load the same classes every time they run, both JDK classes during JDK bootstrap and application classes during application startup and warmup."
msgstr "Mudar o trabalho para que ele seja feito em AOT não é uma ideia totalmente nova no que diz respeito ao tempo de execução do OpenJDK. O OpenJDK oferece suporte a um modelo híbrido de carregamento de classes AOT/JIT há anos com o CDS. A observação que levou à proposta do link:https://docs.oracle.com/en/java/javase/21/vm/class-data-sharing.html[Class Data Sharing (CDS)] foi que a maioria dos aplicativos carrega as mesmas classes sempre que são executados, tanto as classes do JDK durante a inicialização do JDK quanto as classes do aplicativo durante a inicialização e o aquecimento do aplicativo."

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Loading requires locating a class bytecode file, possibly calling out to a Java ClassLoader, parsing the bytecode then building a JVM-internal model of the class. This internal model unpacks the information packed into the bytecode into a format that enables fast interpreted or compiled execution. If this loading and unpacking work could be done once and the resulting class model efficiently reused on subsequent runs, then that would save time during startup and warm up."
msgstr "O carregamento requer a localização de um arquivo de bytecode de classe, possivelmente chamando um Java ClassLoader, analisando o bytecode e criando um modelo interno da classe na JVM. Esse modelo interno descompacta as informações contidas no bytecode em um formato que permite a rápida execução interpretada ou compilada. Se esse trabalho de carregamento e descompactação pudesse ser feito uma vez e o modelo de classe resultante fosse reutilizado com eficiência nas execuções subsequentes, isso economizaria tempo durante a inicialização e o aquecimento."

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Initially CDS optimized loading for a large set of core JDK classes. It worked by booting the JVM and dumping the class model for all classes loaded during startup into an archive file laid out in memory format. The resulting JDK module, class, field, and method graph can then be quickly remapped into memory next time the JVM runs. Loading a class that is present in the archive involves a simple lookup in the AOT class model. Loading a class not present in the archive requires the normal JIT steps of bytecode lookup, parsing and unpacking i.e. CDS implements a hybrid JIT/AOT execution model."
msgstr "Inicialmente, o CDS otimizava o carregamento de um grande conjunto de classes principais do JDK. Ele funcionava inicializando a JVM e despejando o modelo de classe de todas as classes carregadas durante a inicialização em um arquivo de arquivo disposto em formato de memória. O gráfico resultante do módulo, da classe, do campo e do método do JDK pode então ser rapidamente remapeado na memória na próxima vez que a JVM for executada. Carregar uma classe que está presente no arquivo envolve uma simples pesquisa no modelo de classe AOT. Carregar uma classe que não está presente no arquivo requer as etapas normais de JIT de pesquisa, análise e descompactação de bytecode, ou seja, o CDS implementa um modelo de execução JIT/AOT híbrido."

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Static CDS archives are built during the JVM installation and includes classes from the core libraries. This archive can be used to move part of the class loading to AOT when running the application."
msgstr "Os arquivos CDS estáticos são criados durante a instalação da JVM e incluem classes das bibliotecas principais. Esse arquivo pode ser usado para mover parte do carregamento da classe para o AOT ao executar o aplicativo."

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "A default CDS archive for JDK runtime classes has been shipped with every JVM release since JDK17, halving JDK startup time. Improvements were made to CDS to allow application classes to be included in a CDS archive after executing a short application training run. The resulting mixed AOT/JIT operation can provide significant improvements to application startup and warmup times, depending on how well the training run exercises application code. So, selective JIT/AOT operation is not some new thing."
msgstr "Um arquivo CDS padrão para classes de tempo de execução do JDK foi enviado com todas as versões da JVM desde o JDK17, reduzindo pela metade o tempo de inicialização do JDK. Foram feitos aprimoramentos no CDS para permitir que as classes de aplicativos sejam incluídas em um arquivo CDS após a execução de um breve treinamento de aplicativos. A operação mista AOT/JIT resultante pode proporcionar melhorias significativas nos tempos de inicialização e aquecimento do aplicativo, dependendo de quão bem a execução de treinamento exercita o código do aplicativo. Portanto, a operação seletiva JIT/AOT não é algo novo."

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "When doing training runs, we create an archive that contains information on how the application runs. This archive includes not only classes from the core libraries, but also classes from our application."
msgstr "Ao fazer execuções de treinamento, criamos um arquivo que contém informações sobre como o aplicativo é executado. Esse arquivo inclui não apenas as classes das bibliotecas principais, mas também as classes do nosso aplicativo."

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid ""
"Quarkus makes it really easy to generate CDS archives specific to your application code; this feature has been around since some years already: see the https://quarkus.io/guides/appcds[AppCDS guide in Quarkus].\n"
"As Leyden is coming, we aim to evolve this further and fully automate it for Leyden as well, so to get you even more benefits at no additional hassle."
msgstr "O Quarkus facilita muito a geração de arquivos CDS específicos para o código do seu aplicativo; esse recurso já existe há alguns anos: consulte o link:https://quarkus.io/guides/appcds[guia AppCDS no Quarkus] . Como o Leyden está chegando, pretendemos evoluir ainda mais e automatizá-lo totalmente para o Leyden também, para que o senhor obtenha ainda mais benefícios sem complicações adicionais."

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid ""
"The goal of Project Leyden is extending the AOT vs JIT trade-off from class loading (as done by CDS) to other JIT operations in the JVM; there's a number of operations which could be \"moved in time\" to AOT, such as creation of heap objects to represent constants, gathering execution profile information, and many more.\n"
"Most importantly, it's moving AOT the lazy linking that normally happens during interpreted execution and the lazy compilation and recompilation that happens when methods have been executed enough times to justify the cost of compilation."
msgstr "O objetivo do Projeto Leyden é estender a troca entre AOT e JIT do carregamento de classe (como feito pelo CDS) para outras operações JIT na JVM; há várias operações que poderiam ser \"movidas no tempo\" para a AOT, como a criação de objetos de heap para representar constantes, coleta de informações de perfil de execução e muito mais. O mais importante é que o senhor está transferindo para a AOT a vinculação preguiçosa que normalmente ocorre durante a execução interpretada e a compilação e recompilação preguiçosa que ocorre quando os métodos são executados o número suficiente de vezes para justificar o custo da compilação."

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "AOT vs JIT Linkage"
msgstr "AOT vs JIT Linkage"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Linking of classes is another operation that the JVM does lazily. When class bytecode is processed the class is directly linked to its owning module and its owned methods and fields. JIT linkage connects elements of each independent, linked class sub-graph into a fully connected graph where elements from different (class or module) files cross-reference each other."
msgstr "A vinculação de classes é outra operação que a JVM realiza de forma preguiçosa. Quando o bytecode da classe é processado, a classe é vinculada diretamente ao módulo proprietário e aos métodos e campos que lhe pertencem. A vinculação JIT conecta os elementos de cada subgráfico de classe independente e vinculado em um gráfico totalmente conectado em que os elementos de diferentes arquivos (classe ou módulo) fazem referência cruzada entre si."

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Loading and linking needs to proceed recursively. As one example, every class (except Object) needs to be linked to its super class. Super linkage cannot complete without ensuring the super class is loaded. Indeed, if the super's bytecode cannot be found or is not valid (say it identifies an interface not a class) then a linkage error may occur. Likewise, a new operation or a field get/put operation occurring in some method's bytecode can only be linked after loading the class (and field) named in the new bytecode."
msgstr "O carregamento e a vinculação precisam ser feitos de forma recursiva. Por exemplo, toda classe (exceto Object) precisa ser vinculada à sua superclasse. A supervinculação não pode ser concluída sem garantir que a superclasse seja carregada. De fato, se o bytecode da superclasse não puder ser encontrado ou não for válido (por exemplo, ele identifica uma interface e não uma classe), poderá ocorrer um erro de vinculação. Da mesma forma, uma nova operação ou uma operação de obtenção/colocação de campo que ocorra no bytecode de algum método só poderá ser vinculada após o carregamento da classe (e do campo) nomeada no novo bytecode."

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Linking is sometimes, but not always, done lazily. Indeed, it is necessary to do some linkage lazily in order to allow loading also to be lazy, otherwise the whole class graph would end up being linked and loaded as soon as the main routine was entered. Super linkage is always done eagerly at the point where the subclass has just been loaded. That is because it is not possible to use a subclass to create instances or execute methods without knowing how the superclass is defined. By contrast, field and method linkage is done lazily. In these cases linkage happens as a side-effect of execution. When a method executes a field get/put or method invoke bytecode for the first time the target field or method is looked up via its owner class, loading it if necessary. The field type or method signature is checked for consistency and details of where to find the field or how to call the method are cached, allowing the next execution of the bytecode to bypass the linkage step."
msgstr "Às vezes, mas nem sempre, a vinculação é feita de forma preguiçosa. De fato, é necessário fazer algumas vinculações de forma preguiçosa para permitir que o carregamento também seja preguiçoso, caso contrário, todo o gráfico da classe acabaria sendo vinculado e carregado assim que a rotina principal fosse inserida. A supervinculação é sempre feita de forma ansiosa no ponto em que a subclasse acaba de ser carregada. Isso ocorre porque não é possível usar uma subclasse para criar instâncias ou executar métodos sem saber como a superclasse está definida. Por outro lado, a vinculação de campos e métodos é feita de forma preguiçosa. Nesses casos, a vinculação ocorre como um efeito colateral da execução. Quando um método executa um bytecode de get/put de campo ou de invocação de método pela primeira vez, o campo ou método de destino é pesquisado por meio de sua classe proprietária, carregando-a, se necessário. O tipo de campo ou a assinatura do método é verificado quanto à consistência e os detalhes de onde encontrar o campo ou como chamar o método são armazenados em cache, permitindo que a próxima execução do bytecode ignore a etapa de vinculação."

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "As with lazy loading, this lazy approach results in almost the exact same linkage being established on every run. The time spent stopping and restarting execution to lazily connect the class graph comprises a noticeable percentage of JDK startup, application startup and application warm up (time to peak running). We could speed up startup and, more crucially, warm up time if we could pre-compute this linkage and avoid the need to establish it at runtime."
msgstr "Assim como no caso do carregamento preguiçoso, essa abordagem preguiçosa faz com que quase a mesma ligação seja estabelecida em cada execução. O tempo gasto para interromper e reiniciar a execução para conectar preguiçosamente o gráfico de classes compreende uma porcentagem notável da inicialização do JDK, da inicialização do aplicativo e do aquecimento do aplicativo (tempo para atingir o pico de execução). Poderíamos acelerar a inicialização e, o que é mais importante, o tempo de aquecimento se pudéssemos pré-computar essa ligação e evitar a necessidade de estabelecê-la no tempo de execução."

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Synergy with Quarkus"
msgstr "Sinergia com o Quarkus"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Loading and linking of classes is an important step in the warm up of the application because it involves searching through the whole classpath for all classes and objects referenced by the bytecode the JVM is going to run. By default, this is done as a lazy operation because loading and linking all existing classes in the classpath would not only require a bigger memory footprint, but also a bigger warm up time. This is why the JVM only compiles and links the bytecode that is going to be used."
msgstr "O carregamento e a vinculação de classes é uma etapa importante no aquecimento do aplicativo, pois envolve a pesquisa em todo o classpath de todas as classes e objetos referenciados pelo bytecode que a JVM executará. Por padrão, isso é feito como uma operação preguiçosa porque o carregamento e a vinculação de todas as classes existentes no classpath exigiriam não apenas um espaço maior de memória, mas também um tempo de aquecimento maior. É por isso que a JVM compila e vincula apenas o bytecode que será usado."

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "This is a process that Quarkus already speeds up by, among other strategies, aggressively reducing the set of classes included in the classpath, so the search for matches is faster. The search for classes is also accelerated by indexes which Quarkus can generate when it fully analyzes the application at build time. But it is still a heavy operation that is difficult to execute ahead of time, before we know what is going to be run and how. Quarkus might be able to provide some additional hints to the linker in the future."
msgstr "Esse é um processo que o Quarkus já acelera, entre outras estratégias, reduzindo agressivamente o conjunto de classes incluídas no classpath, para que a busca por correspondências seja mais rápida. A pesquisa de classes também é acelerada por índices que o Quarkus pode gerar quando analisa totalmente o aplicativo no momento da compilação. Mas essa ainda é uma operação pesada que é difícil de executar com antecedência, antes de sabermos o que será executado e como. Talvez o Quarkus possa fornecer algumas dicas adicionais ao vinculador no futuro."

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "The first improvement Leyden is offering to improve startup time is to upgrade the AOT model originally developed as part of the CDS project to encompass not just pre-loading of classes but also pre-linking, as described in https://openjdk.org/jeps/8315737[JEP Ahead-of-Time Class Linking]."
msgstr "O primeiro aprimoramento que a Leyden está oferecendo para melhorar o tempo de inicialização é atualizar o modelo AOT originalmente desenvolvido como parte do projeto CDS para abranger não apenas o pré-carregamento de classes, mas também a vinculação prévia, conforme descrito em link:https://openjdk.org/jeps/8315737[JEP Ahead-of-Time Class Linking] ."

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid ""
"An AOT Cache can be generated during a training run that bootstraps the JVM and, optionally, executes application-specific code.\n"
"As with a CDS archive, the AOT Cache stores a class graph for all classes loaded during the training run in a format that allows it to be quickly remapped on a subsequent run. The stored graph also includes any linkage information established by code executed during the training run. Pre-cached links avoid the need to stop and start execution to perform linkage on subsequent runs."
msgstr "Um cache AOT pode ser gerado durante uma execução de treinamento que inicializa a JVM e, opcionalmente, executa o código específico do aplicativo. Assim como em um arquivo CDS, o AOT Cache armazena um gráfico de classe para todas as classes carregadas durante a execução de treinamento em um formato que permite que ele seja rapidamente remapeado em uma execução subsequente. O gráfico armazenado também inclui todas as informações de vinculação estabelecidas pelo código executado durante a execução do treinamento. Os links pré-armazenados evitam a necessidade de parar e iniciar a execução para realizar a vinculação em execuções subsequentes."

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Leyden's AOT Cache contains a lot more pre-generated content that allows us to move part of the load, link, and compiling to AOT, allowing for faster startup and warm up of the application."
msgstr "O cache AOT do Leyden contém muito mais conteúdo pré-gerado, o que nos permite transferir parte do carregamento, do link e da compilação para o AOT, permitindo a inicialização e o aquecimento mais rápidos do aplicativo."

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid ""
"Remember that the training run enables some of the loading and linking to be done AOT but that anything not trained for will still be performed via the regular JIT process: the AOT approach is not required to be applied comprehensively, so that the JVM can fallback to the regular loading system for the use cases which can not benefit from AOT processing.\n"
"This ability to fallback to \"regular JIT processing\" is a luxury that GraalVM native images can't use."
msgstr "Lembre-se de que a execução do treinamento permite que parte do carregamento e da vinculação seja feita pelo AOT, mas que tudo o que não for treinado ainda será executado por meio do processo JIT regular: não é necessário que a abordagem AOT seja aplicada de forma abrangente, de modo que a JVM possa recorrer ao sistema de carregamento regular para os casos de uso que não podem se beneficiar do processamento AOT. Essa capacidade de recorrer ao \"processamento JIT regular\" é um luxo que as imagens nativas do GraalVM não podem usar."

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "JIT vs AOT Compilation"
msgstr "Compilação JIT vs AOT"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid ""
"Another well-known lazy operation the JVM performs is JIT (runtime) compilation. Method bytecode is normally interpreted, but the JVM will lazily translate bytecode to equivalent machine code.\n"
"Since generating optimal machine code is an expensive operation, it performs this compilation task selectively, only bothering to compile methods that have been invoked quite a few times."
msgstr "Outra operação preguiçosa bem conhecida que a JVM realiza é a compilação JIT (tempo de execução). O bytecode do método é normalmente interpretado, mas a JVM traduzirá preguiçosamente o bytecode para o código de máquina equivalente. Como a geração de código de máquina ideal é uma operação cara, ela executa essa tarefa de compilação de forma seletiva, preocupando-se apenas em compilar métodos que tenham sido invocados várias vezes."

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "JIT compilation is also 'adaptive' i.e. the JVM will lazily recompile some methods, using different 'tiers' or levels of compilation."
msgstr "A compilação JIT também é \"adaptativa\", ou seja, a JVM recompilará preguiçosamente alguns métodos, usando diferentes \"camadas\" ou níveis de compilação."

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "A tier 1 compile generates code that is only lightly optimised, based on very limited execution profile data."
msgstr "Uma compilação de nível 1 gera código que é apenas levemente otimizado, com base em dados de perfil de execução muito limitados."

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "A tier 2 compile also generates lightly optimized code but instruments it to profile control flow."
msgstr "Uma compilação de nível 2 também gera um código levemente otimizado, mas o instrumentaliza para traçar o perfil do fluxo de controle."

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Tier 3 compilation adds further instrumentation that records many more details about what gets executed, including with what type of values."
msgstr "A compilação de nível 3 adiciona mais instrumentação que registra muito mais detalhes sobre o que é executado, inclusive com que tipo de valores."

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "A tier 4 compile uses all gathered profile information and performs a great deal of optimization."
msgstr "Uma compilação de nível 4 usa todas as informações de perfil coletadas e realiza uma grande quantidade de otimização."

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Tier 1 - 3 compilations omit many possible optimizations in order to deliver compiled code quickly. A tier 4 compilation can take much longer to complete so it is only attempted for a small subset of very frequently executed methods."
msgstr "As compilações de nível 1 a 3 omitem muitas otimizações possíveis para fornecer o código compilado rapidamente. Uma compilação de nível 4 pode levar muito mais tempo para ser concluída, portanto, ela só é tentada para um pequeno subconjunto de métodos executados com muita frequência."

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid ""
"Sometimes, the code is compiled with substantial optimisations based on 'speculative' assumptions extrapolated from the profiling data.\n"
"In such cases, the compiler will make an optimistic assumption about a condition to be consistently true in the future yet include an efficient check to verify the assumption during execution so that the semantics of the program are not affected in case this educated guess eventually turns out to be false; when this is detected, the code is de-optimised, returning at a previous tier of compilation and the profiling data is adjusted, so that it will eventually be recompiled with better information.\n"
"Essentially, some parts of code might get recompiled multiple times and occasionally revert to a lower tier: it's an highly dynamic process."
msgstr "Às vezes, o código é compilado com otimizações substanciais baseadas em suposições \"especulativas\" extrapoladas dos dados de criação de perfil. Nesses casos, o compilador fará uma suposição otimista sobre uma condição que será consistentemente verdadeira no futuro, mas incluirá uma verificação eficiente para verificar a suposição durante a execução, de modo que a semântica do programa não seja afetada caso essa suposição educada acabe se revelando falsa; quando isso é detectado, o código é desotimizado, retornando a um nível anterior de compilação e os dados de criação de perfil são ajustados, de modo que ele será recompilado com informações melhores. Essencialmente, algumas partes do código podem ser recompiladas várias vezes e, ocasionalmente, revertidas para uma camada inferior: é um processo altamente dinâmico."

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Peak optimization is reached when most of the running code is compiled at the highest tier, and background compilation activities become very rare or, ideally, none at all."
msgstr "O pico de otimização é atingido quando a maior parte do código em execução é compilada na camada mais alta, e as atividades de compilação em segundo plano tornam-se muito raras ou, idealmente, nenhuma."

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Compiling code for peak performance also requires quite some resources, so performing this work ahead of time can also save precious CPU cycles during the application bootstrap, and can manifest in substantial memory savings as well: Java developers aren't used to measure the memory costs of the JIT compiler, but the fact that it's hidden doesn't imply it's non-existent; and while this might be a detail for large enterprise servers, it's quite important to be aware of such resource costs when developing microservices or simply aiming for smaller, more power efficient targets."
msgstr "A compilação de código para obter o máximo desempenho também requer alguns recursos, portanto, realizar esse trabalho com antecedência também pode economizar preciosos ciclos de CPU durante a inicialização do aplicativo e pode se manifestar em economias substanciais de memória: Os desenvolvedores de Java não estão acostumados a medir os custos de memória do compilador JIT, mas o fato de ele estar oculto não significa que seja inexistente; e, embora isso possa ser um detalhe para servidores de grandes empresas, é muito importante estar ciente desses custos de recursos ao desenvolver microsserviços ou simplesmente buscar alvos menores e mais eficientes em termos de energia."

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "But there are some limitations on what we can optimise before runtime just by examining the bytecode. For example, extensive use of reflection prevents the compiler from predicting which symbols will be loaded, linked, and most used at runtime."
msgstr "Mas há algumas limitações sobre o que podemos otimizar antes do tempo de execução apenas examinando o bytecode. Por exemplo, o uso extensivo de reflexão impede que o compilador preveja quais símbolos serão carregados, vinculados e mais usados no tempo de execução."

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "The Leyden project has already sucessfully prototyped shifting the work of method compilation from JIT to AOT. Execution and compilation of methods is tracked during the training run. At the end of the run any associated profiling information and compiled code for the method are saved to the AOT Cache, allowing them to be quickly mapped back into memory and reused when the application is next run."
msgstr "O projeto Leyden já conseguiu criar um protótipo bem-sucedido, transferindo o trabalho de compilação de métodos do JIT para o AOT. A execução e a compilação de métodos são rastreadas durante a execução do treinamento. No final da execução, todas as informações de perfil associadas e o código compilado do método são salvos no cache AOT, permitindo que sejam rapidamente mapeados de volta à memória e reutilizados na próxima execução do aplicativo."

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "As with AOT loading and linking, the training run enables some of the work of profiling and compiling to be done AOT but allows anything not trained still to be compiled via the regular JIT compilation process. Note that method code does not need to have been compiled at the highest tier in order to be saved. Also, when code compiled at a lower tier is restored it can still be recompiled at a higher level."
msgstr "Assim como no carregamento e na vinculação do AOT, a execução de treinamento permite que parte do trabalho de criação de perfil e compilação seja feito no AOT, mas permite que tudo o que não for treinado ainda seja compilado por meio do processo regular de compilação JIT. Observe que o código do método não precisa ter sido compilado no nível mais alto para ser salvo. Além disso, quando o código compilado em um nível inferior é restaurado, ele ainda pode ser recompilado em um nível superior."

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Compiled code can also be deoptimized and re-optimized to adapt to different runtime conditions, just as with code compiled in the current runtime. So, the use of AOT compilation is fully integrated into OpenJDK's adaptive, dynamic compilation and recompilation model: even if some assumptions made during AOT compilation turn out to be suboptimal, the just-in-time compiler can intervene at runtime and improve the code with the new information."
msgstr "O código compilado também pode ser desotimizado e reotimizado para se adaptar a diferentes condições de tempo de execução, assim como o código compilado no tempo de execução atual. Portanto, o uso da compilação AOT está totalmente integrado ao modelo de compilação e recompilação adaptável e dinâmica do OpenJDK: mesmo que algumas suposições feitas durante a compilação AOT se revelem abaixo do ideal, o compilador just-in-time pode intervir no tempo de execução e aprimorar o código com as novas informações."

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "How to play with it"
msgstr "Como brincar com ele"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "The first step would be to install one of the early Leyden builds that you can find at https://jdk.java.net/leyden/[jdk.java.net/leyden/]."
msgstr "A primeira etapa seria instalar uma das primeiras compilações do Leyden que o senhor pode encontrar em link:https://jdk.java.net/leyden/[jdk.java.net/leyden/] ."

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Make sure that you have installed it correctly by running the following command:"
msgstr "Certifique-se de que o instalou corretamente executando o seguinte comando:"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Go to the application you want to test Leyden with and start a first training run:"
msgstr "Acesse o aplicativo com o qual o senhor deseja testar o Leyden e inicie uma primeira execução de treinamento:"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "This will generate the archive files with all the profiling information needed to speed up the production run."
msgstr "Isso gerará os arquivos de arquivo com todas as informações de perfil necessárias para acelerar a execução da produção."

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Now that we have them, we can run our application using the Leyden enhancements:"
msgstr "Agora que os temos, podemos executar nosso aplicativo usando os aprimoramentos do Leyden:"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Potentially needed workarounds"
msgstr "Soluções alternativas potencialmente necessárias"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Since it’s early days for the Leyden project, there are some known issues. The following instructions shouldn’t be necessary for the final versions but you might need them today."
msgstr "Como o projeto Leyden ainda está no início, há alguns problemas conhecidos. As instruções a seguir não devem ser necessárias para as versões finais, mas o senhor pode precisar delas hoje."

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Force the use of G1GC"
msgstr "Forçar o uso do G1GC"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "To benefit from the natively compiled code in AOT archives, the garbage collector used at runtime needs to match the same garbage collector used when you recorded the AOT archives."
msgstr "Para se beneficiar do código compilado nativamente nos arquivos AOT, o coletor de lixo usado no tempo de execução precisa corresponder ao mesmo coletor de lixo usado quando o senhor gravou os arquivos AOT."

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Remember that the JVM’s default choice of garbage collector is based on ergonomics; normally this is nice but it can cause some confusion in this case; for example if you build on a large server it will pick G1GC by default, but then when you run the application on a server with constrained memory it would, by default, pick SerialGC."
msgstr "Lembre-se de que a escolha padrão do coletor de lixo da JVM se baseia na ergonomia; normalmente isso é bom, mas pode causar alguma confusão nesse caso; por exemplo, se o usuário construir em um servidor grande, ele escolherá o G1GC por padrão, mas quando o aplicativo for executado em um servidor com memória limitada, ele escolherá, por padrão, o SerialGC."

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "To avoid this mismatch it’s best to pick a garbage collector explicitly; and since several AOT related optimisations today only apply to G1, let’s enforce the use of G1GC."
msgstr "Para evitar essa incompatibilidade, é melhor escolher explicitamente um coletor de lixo; e como várias otimizações relacionadas ao AOT hoje só se aplicam ao G1, vamos impor o uso do G1GC."

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Force using G1GC:"
msgstr "Forçar usando G1GC:"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "N.B. you need to use this consistently on both the process generating the AOT archives and the runtime."
msgstr "Nota: o senhor precisa usar isso de forma consistente no processo que gera os arquivos AOT e no tempo de execução."

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Force the G1 Region sizes"
msgstr "Forçar os tamanhos da região G1"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid ""
"As identified and reported by the Quarkus team to our colleagues working on Project Leyden, beyond enforcing a specific garbage collector, one should also ensure that the code stored in AOT archives is being generated with the same G1 region sizes as what’s going to be used at runtime, or one risks segmentation faults caused by it wrongly identifying regions.\n"
"See https://bugs.openjdk.org/browse/JDK-8335440 for details, or simply set:"
msgstr "Conforme identificado e relatado pela equipe do Quarkus aos nossos colegas que trabalham no Projeto Leyden, além de impor um coletor de lixo específico, deve-se também garantir que o código armazenado nos arquivos AOT esteja sendo gerado com os mesmos tamanhos de região G1 que serão usados no tempo de execução, ou corre-se o risco de falhas de segmentação causadas pela identificação incorreta de regiões. link:https://bugs.openjdk.org/browse/JDK-8335440[Consulte https://bugs.openjdk.org/browse/JDK-8335440] para obter detalhes ou simplesmente defina:"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Configure G1HeapRegionSize explicitly:"
msgstr "Configure o G1HeapRegionSize explicitamente:"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Failure to terminate in containers"
msgstr "Falha ao terminar em contêineres"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "This issue has already been resolved, but in case you’re using an older version of project Leyden and it fails to exit on regular container termination, you might be affected by https://bugs.openjdk.org/browse/JDK-8333794[JDK-8333794]."
msgstr "Esse problema já foi resolvido, mas se o senhor estiver usando uma versão mais antiga do projeto Leyden e ele não conseguir sair no encerramento regular do contêiner, poderá ser afetado pelo link:https://bugs.openjdk.org/browse/JDK-8333794[JDK-8333794] ."

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Workaround for JDK-8333794:"
msgstr "Solução alternativa para o JDK-8333794:"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Current status of Project Leyden"
msgstr "Status atual do Projeto Leyden"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "There are already experimental https://jdk.java.net/leyden/[early-access builds of Leyden] that can be tested based on https://openjdk.org/jeps/8315737[this draft JEP about Ahead-of-Time Class Linking]."
msgstr "Já existem link:https://jdk.java.net/leyden/[versões] experimentais link:https://jdk.java.net/leyden/[de acesso antecipado do Leyden] que podem ser testadas com base nesse link:https://openjdk.org/jeps/8315737[rascunho de JEP sobre Ahead-of-Time Class Linking] ."

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "With the Leyden Project, the idea of leveraging a \"training run\" has been extended to a wider range of data structures embedded in the new AOT cache. Now the cache produced by the AOT process contains the following data:"
msgstr "Com o Projeto Leyden, a ideia de aproveitar uma \"execução de treinamento\" foi estendida a uma gama mais ampla de estruturas de dados incorporadas no novo cache AOT. Agora, o cache produzido pelo processo AOT contém os seguintes dados:"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Class file events with historical data (Classes loaded and linked, Compilations)"
msgstr "Eventos de arquivos de classe com dados históricos (Classes carregadas e vinculadas, Compilações)"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Resolution of API points and indy (stored in constant pool images in the AOT archive). If you have lambdas in your code, they are captured here."
msgstr "Resolução de pontos de API e indy (armazenados em imagens de pool constantes no arquivo AOT). Se o senhor tiver lambdas em seu código, eles serão capturados aqui."

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Pre-created constant objects in the Java heap (String and Class<?> constants)"
msgstr "Objetos constantes pré-criados no Java heap (constantes String e Class<?>)"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Execution profiles and some compiled native code (all tiers)"
msgstr "Perfis de execução e alguns códigos nativos compilados (todas as camadas)"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Leyden is also a hot topic at the https://openjdk.org/projects/mlvm/jvmlangsummit/agenda.html[JVM Language Summit] this year; as soon as the recordings of the talks about Leyden are publicly available we'll add the links here."
msgstr "O Leyden também é um tópico importante no link:https://openjdk.org/projects/mlvm/jvmlangsummit/agenda.html[JVM Language Summit] deste ano; assim que as gravações das palestras sobre o Leyden estiverem disponíveis publicamente, adicionaremos os links aqui."

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Some known limitations"
msgstr "Algumas limitações conhecidas"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "This is an experimental project being developed by multiple teams having different approaches and focuses. Limitations explained here are being worked on at the time of writing this blog post."
msgstr "Este é um projeto experimental que está sendo desenvolvido por várias equipes com abordagens e focos diferentes. As limitações explicadas aqui estão sendo trabalhadas no momento da redação desta postagem do blog."

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "One of the main issues is that functionality is currently only available for x86_64 and AArch64 architectures at the moment."
msgstr "Um dos principais problemas é que, no momento, a funcionalidade só está disponível para as arquiteturas x86_64 e AArch64."

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Also, current developments rely on a flat classpath. If the application is using custom classloaders, then it may not benefit as much as it could as it may miss caching many classes."
msgstr "Além disso, os desenvolvimentos atuais dependem de um classpath plano. Se o aplicativo estiver usando carregadores de classe personalizados, ele poderá não se beneficiar tanto quanto poderia, pois poderá perder o armazenamento em cache de muitas classes."

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "The same happens if the application is intensively using reflection. Quarkus avoids reflection whenever possible, preferring to resolve reflective calls at build time as well - so there’s a nice synergy at play."
msgstr "O mesmo acontece se o aplicativo estiver usando intensamente a reflexão. O Quarkus evita a reflexão sempre que possível, preferindo resolver as chamadas reflexivas também no momento da construção - portanto, há uma boa sinergia em jogo."

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid ""
"However Quarkus in “fast-jar” mode, which is the default packaging mode, will use a custom classloader which currently would get in the way of some Leyden optimisations. One could use a different packaging mode in Quarkus to get more prominent benefits from Leyden, but doing so would disable other Quarkus optimisations, so the comparison wouldn’t be entirely fair today.\n"
"We hope to work on improvements in this area to have all possible benefits, combined."
msgstr "No entanto, o Quarkus no modo \"fast-jar\", que é o modo de empacotamento padrão, usará um carregador de classe personalizado que atualmente atrapalharia algumas otimizações do Leyden. Seria possível usar um modo de empacotamento diferente no Quarkus para obter benefícios mais proeminentes do Leyden, mas isso desativaria outras otimizações do Quarkus, de modo que a comparação não seria totalmente justa hoje. Esperamos trabalhar em melhorias nessa área para que todos os benefícios possíveis sejam combinados."

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "The focus on these first early releases has been on bootstrap times. There are measurable, significant startup time improvements, due to AOT loading and linking. In some cases, these improvements on startup time have worsened the memory footprint of some applications. That’s an already known issue that is being worked on, and the expected outcome is to improve memory footprint as well, so we would suggest not worrying too much about total memory consumption at this stage."
msgstr "O foco dessas primeiras versões iniciais tem sido o tempo de inicialização. Há melhorias significativas e mensuráveis no tempo de inicialização, devido ao carregamento e à vinculação do AOT. Em alguns casos, essas melhorias no tempo de inicialização pioraram o consumo de memória de alguns aplicativos. Esse é um problema já conhecido que está sendo resolvido, e o resultado esperado é melhorar o consumo de memória também, portanto, sugerimos que o senhor não se preocupe muito com o consumo total de memória nesta fase."

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Since the AOT archives include machine specific optimisations such as the native code generated by the C2 compiler, the training run and the production run must be done on the same type of hardware and JDK versions; it also requires using the same JAR-based classpaths and the same command line options."
msgstr "Como os arquivos AOT incluem otimizações específicas da máquina, como o código nativo gerado pelo compilador C2, a execução de treinamento e a execução de produção devem ser feitas no mesmo tipo de hardware e nas mesmas versões do JDK; também é necessário usar os mesmos classpaths baseados em JAR e as mesmas opções de linha de comando."

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Although the training run can use a different Main class to the one used for running the application, for example a test class that simulates usage."
msgstr "Embora a execução do treinamento possa usar uma classe principal diferente daquela usada para executar o aplicativo, por exemplo, uma classe de teste que simula o uso."

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "What is on the roadmap for Leyden?"
msgstr "O que há no roteiro para Leyden?"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "There’s still work to be done regarding classes that can’t be loaded and linked in AOT with the current implementation. For example, classes loaded using a user-defined class loader. There’s also room to improve the way the training runs are made, maybe allowing the user to tweak the results to influence decisions."
msgstr "Ainda há trabalho a ser feito com relação às classes que não podem ser carregadas e vinculadas no AOT com a implementação atual. Por exemplo, classes carregadas usando um carregador de classes definido pelo usuário. Também há espaço para melhorar a forma como as execuções de treinamento são feitas, talvez permitindo que o usuário ajuste os resultados para influenciar as decisões."

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Currently, the https://bugs.openjdk.org/browse/JDK-8326035[Z Garbage Collector] does not support AOT object archiving. There is an active effort to make sure all Garbage Collectors are compatible with these enhancements."
msgstr "Atualmente, o link:https://bugs.openjdk.org/browse/JDK-8326035[Z Garbage Collector] não oferece suporte ao arquivamento de objetos AOT. Há um esforço ativo para garantir que todos os coletores de lixo sejam compatíveis com esses aprimoramentos."

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "There are also other things planned in the roadmap for Leyden, like adding condensers. https://openjdk.org/projects/leyden/notes/03-toward-condensers[Condensers] will be composable transformers of the source code in AOT that modify the source code optimising it. Each developer will be able to define a pipeline of condensers that improves their source code before compiling it into bytecode; this is very interesting to the Quarkus team but condensers aren’t available yet."
msgstr "Há também outras coisas planejadas no roteiro do Leyden, como a adição de condensadores. link:https://openjdk.org/projects/leyden/notes/03-toward-condensers[Os condensadores] serão transformadores compostáveis do código-fonte no AOT que modificam o código-fonte otimizando-o. Cada desenvolvedor poderá definir um pipeline de condensadores que aprimoram seu código-fonte antes de compilá-lo em bytecode; isso é muito interessante para a equipe do Quarkus, mas os condensadores ainda não estão disponíveis."

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "The OpenJDK team is actively extending the range of compiled code that can be saved to and restored from the AOT cache. Our colleagues from Red Hat’s OpenJDK team are directly involved in this effort, looking into save and restore of auxiliary code that is normally generated at runtime and used to provide optimized code for 'intrinsic' methods or to link compiled Java method code to the compiled C code that implements the JVM, the interpreter and other compiled C libraries."
msgstr "A equipe do OpenJDK está ampliando ativamente a gama de códigos compilados que podem ser salvos e restaurados a partir do cache do AOT. Nossos colegas da equipe OpenJDK da Red Hat estão diretamente envolvidos nesse esforço, procurando salvar e restaurar o código auxiliar que normalmente é gerado em tempo de execução e usado para fornecer código otimizado para métodos \"intrínsecos\" ou para vincular o código do método Java compilado ao código C compilado que implementa o JVM, o interpretador e outras bibliotecas C compiladas."

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Will Leyden replace GraalVM's native-image capabilities?"
msgstr "O Leyden substituirá os recursos de imagem nativa do GraalVM?"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "The short answer is no."
msgstr "A resposta curta é não."

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid ""
"If you want the absolute smallest footprint and ensure that absolutely no \"dynamic\" adaptations happen at runtime, GraalVM native images are the way to go. Just think about it: to support the dynamic aspects that the JVM normally provides,\n"
"even in very minimal form, you would need some code which is able to perform this work, and some memory and some computational resources to run such code and adapt your runtime safely; this is a complex feature and will never be completely free, even in the case Leyden evolved significantly beyond the current plans."
msgstr "Se o senhor quiser a menor pegada possível e garantir que absolutamente nenhuma adaptação \"dinâmica\" ocorra no tempo de execução, as imagens nativas do GraalVM são o caminho a seguir. Pense nisso: para oferecer suporte aos aspectos dinâmicos que a JVM normalmente fornece, mesmo que de forma mínima, o senhor precisaria de algum código capaz de realizar esse trabalho, além de alguma memória e alguns recursos computacionais para executar esse código e adaptar seu tempo de execução com segurança; esse é um recurso complexo e nunca será totalmente gratuito, mesmo no caso de o Leyden evoluir significativamente além dos planos atuais."

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "The architecture of Quarkus enables developers to define an application in strict \"closed world\" style, and this approach works extremely well in combination with GraalVM native images, but the Quarkus design works indeed very well on the bigger, dynamic JVMs as well."
msgstr "A arquitetura do Quarkus permite que os desenvolvedores definam um aplicativo em um estilo estrito de \"mundo fechado\", e essa abordagem funciona extremamente bem em combinação com imagens nativas do GraalVM, mas o design do Quarkus também funciona muito bem em JVMs maiores e dinâmicas."

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "The ability that Quarkus offers to create a closed world application doesn't imply that you should necessarily be doing so; in fact there are many applications which could benefit from a bit more dynamism, some more runtime configurability or auto-adaptability, and Quarkus also allows to create such applications while still benefiting from very substantial efficiency improvements over competing architectures, and even over competing runtimes and languages."
msgstr "A capacidade que o Quarkus oferece de criar um aplicativo de mundo fechado não implica que o senhor deva necessariamente fazer isso; na verdade, há muitos aplicativos que poderiam se beneficiar de um pouco mais de dinamismo, um pouco mais de configurabilidade ou adaptabilidade automática em tempo de execução, e o Quarkus também permite criar esses aplicativos e, ao mesmo tempo, beneficiar-se de melhorias de eficiência muito substanciais em relação a arquiteturas concorrentes e até mesmo em relação a tempos de execução e linguagens concorrentes."

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "We're very excited by Project Leyden as it allows to substantially improve bootstrap times, warmup times, and overall costs even for the \"regular\" JVM, so retaining all the benefits of a dynamic runtime and an adaptative JIT compiler, and this will be a fantastic option for all those applications for which a fully AOT native image might not be suitable: you'll get some of the benefits from native-image (not all of them) but essentially for free, at no drawbacks."
msgstr "Estamos muito empolgados com o Projeto Leyden, pois ele permite melhorar substancialmente os tempos de inicialização, os tempos de aquecimento e os custos gerais, mesmo para a JVM \"regular\", mantendo assim todos os benefícios de um tempo de execução dinâmico e de um compilador JIT adaptável, e essa será uma opção fantástica para todos os aplicativos para os quais uma imagem nativa totalmente AOT pode não ser adequada: o senhor obterá alguns dos benefícios da imagem nativa (não todos), mas essencialmente de graça, sem desvantagens."

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "We also hope it will bring better defined semantics in regards to running certain phases “ahead of time” (or later); there is a very interesting read on this topic by Mark Reinhold: https://openjdk.org/projects/leyden/notes/02-shift-and-constrain[Selectively Shifting and Constraining Computation] ; from a perspective of Quarkus developers, we can confirm that improvements in the language specification in this area would be very welcome, and also improve the quality and maintainability of applications compiled with GraalVM native-image(s)."
msgstr "Também esperamos que ela traga uma semântica mais bem definida em relação à execução de determinadas fases \"antes do tempo\" (ou depois); há uma leitura muito interessante sobre esse tópico feita por Mark Reinhold: link:https://openjdk.org/projects/leyden/notes/02-shift-and-constrain[Selectively Shifting and Constraining Computation] ; do ponto de vista dos desenvolvedores do Quarkus, podemos confirmar que as melhorias na especificação da linguagem nessa área seriam muito bem-vindas e também melhorariam a qualidade e a capacidade de manutenção dos aplicativos compilados com a(s) imagem(ns) nativa(s) do GraalVM."

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "For these reasons, Quarkus will definitely not deprecate support for native images; it's more plausible that, eventually, the \"full JVM\" will always be benefiting from Leyden powered improvements, and as usual we'll work to make these benefits work in synergy with our architecture, and at minimal effort for you all."
msgstr "Por esses motivos, o Quarkus definitivamente não vai descontinuar o suporte a imagens nativas; é mais plausível que, eventualmente, a \"JVM completa\" sempre se beneficie dos aprimoramentos do Leyden e, como sempre, trabalharemos para que esses benefícios funcionem em sinergia com nossa arquitetura e com o mínimo de esforço para todos os senhores."

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Essentially both the JVM and the native-image options are bound to benefit from this initiative. It's a great time to be a Java developer!"
msgstr "Essencialmente, tanto a JVM quanto as opções de imagem nativa se beneficiarão com essa iniciativa. É um ótimo momento para ser um desenvolvedor Java!"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "How can I make sure this will work for me?"
msgstr "Como posso ter certeza de que isso funcionará para mim?"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "The best way to make sure your application benefits from Leyden is to start experimenting early and participate in the development. It would be great to add real-world feedback from a perspective of Quarkus users."
msgstr "A melhor maneira de garantir que seu aplicativo se beneficie do Leyden é começar a experimentar desde cedo e participar do desenvolvimento. Seria ótimo adicionar feedback do mundo real a partir da perspectiva dos usuários do Quarkus."

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "If you spend some time testing your application with the https://jdk.java.net/leyden/[early-access builds of Leyden], and https://bugs.openjdk.org/browse/JDK-8332177?jql=issuetype%20%3D%20Bug%20AND%20status%20%3D%20Open%20AND%20labels%20%3D%20leyden[reporting any bugs] or weird behaviour the developers will take your specificities into account."
msgstr "Se o senhor passar algum tempo testando seu aplicativo com as link:https://jdk.java.net/leyden/[versões de acesso antecipado do Leyden] e link:https://bugs.openjdk.org/browse/JDK-8332177?jql=issuetype%20%3D%20Bug%20AND%20status%20%3D%20Open%20AND%20labels%20%3D%20leyden[relatando quaisquer bugs] ou comportamentos estranhos, os desenvolvedores levarão em conta suas especificidades."

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid ""
"The OpenJDK issue tracker isn’t open to everyone, but you’re also very welcome to provide feedback on our https://quarkus.io/discussion/[Quarkus channels]; we can then relay any suggestions to our colleagues who are directly working on project Leyden.\n"
"You can also use the https://mail.openjdk.org/mailman/listinfo/leyden-dev[Leyden mailing list]."
msgstr "O rastreador de problemas do OpenJDK não está aberto a todos, mas o senhor também é muito bem-vindo para fornecer feedback em nossos link:https://quarkus.io/discussion/[canais do Quarkus] ; podemos, então, transmitir todas as sugestões aos nossos colegas que estão trabalhando diretamente no projeto Leyden. O senhor também pode usar a link:https://mail.openjdk.org/mailman/listinfo/leyden-dev[lista de discussão do Leyden] ."
