# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2022-05-02 07:14+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: YAML Front Matter: author
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:1
#, no-wrap
msgid "cescoffier"
msgstr ""

#. type: YAML Front Matter: date
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:1
#, no-wrap
msgid "2020-09-15"
msgstr ""

#. type: YAML Front Matter: layout
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:1
#, no-wrap
msgid "post"
msgstr ""

#. type: YAML Front Matter: synopsis
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:1
#, no-wrap
msgid "How to use API using pagination with Mutiny"
msgstr ""

#. type: YAML Front Matter: tags
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:1
#, no-wrap
msgid "reactive rest mutiny http pagination"
msgstr ""

#. type: YAML Front Matter: title
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:1
#, no-wrap
msgid "Handling paginated APIs with Mutiny"
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:17
#, fuzzy
msgid "At the beginning of the Mutiny adventure, my friend Alex came to me with an interesting problem.  Alex wanted to retrieve data from a REST service in a reactive manner.  So far, no problem, we have everything for this in our toolbox.  But, this service, as many services, is using pagination.  Ah! That makes things a bit more spicy.  Alex wanted to retrieve all the items and consume them as a stream, but you can't retrieve the items in one batch.  You need to invoke the service for every page, extract the items and feed the stream."
msgstr "Al principio de la aventura de Mutiny, mi amigo Alex vino a mí con un problema interesante. Alex quería recuperar datos de un servicio REST de forma reactiva. Hasta aquí, ningún problema, tenemos todo para esto en nuestra caja de herramientas. Pero, este servicio, como muchos servicios, está usando paginación. Eso hace las cosas un poco más picantes. Alex quería recuperar todos los elementos y consumirlos como un flujo, pero no puedes recuperar los elementos en un lote. Tiene que invocar el servicio para cada página, extraer los elementos y alimentar el flujo."

#. type: Plain text
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:20
#, fuzzy
msgid "So, how to achieve this in a reactive manner and build a proper stream of items without loosing your sanity? Let's have a look!"
msgstr "Entonces, ¿cómo lograr esto de manera reactiva y construir un flujo adecuado de artículos sin perder la cordura? Veamos."

#. type: Plain text
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:22
#, fuzzy
msgid "## The Punk API"
msgstr "La API Punk"

#. type: Plain text
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:27
#, fuzzy
msgid "First, we need an API.  Alex introduced me to the https://punkapi.com/documentation/v2[Punk API], a REST API to retrieve beers.  That's fun, and even better, it uses pagination.  We got our API!"
msgstr "En primer lugar, necesitamos una API. Alex me presentó la API  link:https://punkapi.com/documentation/v2[Punk], una API REST para recuperar cervezas. Es divertido, y aún mejor, utiliza la paginación. ¡Tenemos nuestra API!"

#. type: Plain text
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:29
#, fuzzy
msgid "If you call `https://api.punkapi.com/v2/beers?page=1`, you get a JSON array like:"
msgstr "Si llamas a `&lt;a href=\"https://api.punkapi.com/v2/beers?page=1\" class=\"bare\"&gt;https://api.punkapi.com/v2/beers?page=1&lt;/a&gt;`se obtiene un array JSON como"

#. type: delimited block -
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:41
#, no-wrap
msgid ""
"[\n"
"    {\n"
"        first beer\n"
"    },\n"
"    {\n"
"        second beer\n"
"    }, \n"
"    // ...\n"
"]\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:48
#, fuzzy
msgid "I won't show discuss the content of each object, the documentation page does a great job about that.  Let's focus on the pagination aspect.  First, we passed the `page` query parameter, indicating which page we want.  Generally, when you retrieve a page, the API provides a way to know if there is a next page (a special field in the JSON document, or HTTP header), but the Punk API does not provide any hint.  So, to retrieve all the beers, we need to invoke the service for page 1, 2, 3... until the returned JSON array is empty."
msgstr "No mostraré el contenido de cada objeto, la página de documentación hace un gran trabajo al respecto. Vamos a centrarnos en el aspecto de la paginación. Primero, pasamos el parámetro de consulta `page`, indicando qué página queremos. Generalmente, cuando se recupera una página, la API proporciona una forma de saber si hay una página siguiente (un campo especial en el documento JSON, o una cabecera HTTP), pero la API de Punk no proporciona ninguna pista. Así que, para recuperar todas las cervezas, tenemos que invocar el servicio para la página 1, 2, 3... hasta que el array JSON devuelto esté vacío."

#. type: Plain text
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:50
#, fuzzy
msgid "In an imperative world, to retrieve all the beers, you would do something like this:"
msgstr "En un mundo imperativo, para recuperar todas las cervezas, se haría algo así"

#. type: delimited block -
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:61
#, no-wrap
msgid ""
"List<Beer> beers = ...;\n"
"int page = 1;\n"
"List<Beer> batch = ...\n"
"do {\n"
"  batch= getBeersFromPage(page);\n"
"  beers.addAll(batch);\n"
"  page = page + 1;\n"
"} while (! batch.isEmpty());\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:64
#, fuzzy
msgid "How can we achieve the same in a reactive manner and build a stream of beer?"
msgstr "¿Cómo podemos conseguir lo mismo de forma reactiva y construir un flujo de cerveza?"

#. type: Plain text
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:66
#, fuzzy
msgid "image:/assets/images/posts/mutiny-pagination/mutiny-pagination.png[]"
msgstr "image:/assets/images/posts/mutiny-pagination/mutiny-pagination.png[alt=mutiny pagination]"

#. type: Plain text
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:68
#, fuzzy
msgid "Let's proceed step by step."
msgstr "Procedamos paso a paso."

#. type: Plain text
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:70
#, fuzzy
msgid "## Retrieving a single page"
msgstr "Recuperación de una sola página"

#. type: Plain text
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:73
#, fuzzy
msgid "First, we need to see how we can retrieve a single page.  I'm going to use the Vert.x Web Client, but you can use any reactive HTTP clients providing a Mutiny API."
msgstr "Primero, necesitamos ver cómo podemos recuperar una sola página. Voy a utilizar el cliente web Vert.x, pero puedes utilizar cualquier cliente HTTP reactivo que proporcione una API Mutiny."

#. type: delimited block -
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:82
#, no-wrap
msgid ""
"// Create the client\n"
"WebClient client = WebClient.create(vertx, new WebClientOptions()\n"
"      .setDefaultHost(\"api.punkapi.com\")\n"
"      .setDefaultPort(443)\n"
"      .setSsl(true)\n"
");\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:87
#, no-wrap
msgid ""
"// Retrieve the first page\n"
"Uni<List<Beer>> uni = client.get(\"/v2/beers?page=1\")\n"
"      .send()\n"
"      .onItem().transform(Pagination::toListOfBeer);\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:91
#, fuzzy
msgid "This snippet creates the web client.  Then, we use that client and retrieve the first page."
msgstr "Este fragmento crea el cliente web. Luego, usamos ese cliente y recuperamos la primera página."

#. type: Plain text
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:93
#, fuzzy
msgid "When we receive the result (`onItem`), we transform the JSON array into a list of beers."
msgstr "Cuando recibimos el resultado ( `onItem`), transformamos la matriz JSON en una lista de cervezas."

#. type: Plain text
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:95
#, fuzzy
msgid "Let's extract this code in a method and take the page number as parameter:"
msgstr "Extraigamos este código en un método y tomemos el número de página como parámetro:"

#. type: delimited block -
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:103
#, no-wrap
msgid ""
"private static Uni<List<Beer>> getPage(WebClient client, int page) {\n"
"    return client.get(\"/v2/beers?page=\" + page)\n"
"            .send()\n"
"            .onItem().transform(Pagination::toListOfBeer);\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:106
#, fuzzy
msgid "So far, so good."
msgstr "Hasta ahora, todo va bien."

#. type: Plain text
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:108
#, fuzzy
msgid "## Retrieving multiple page"
msgstr "Recuperación de varias páginas"

#. type: Plain text
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:111
#, fuzzy
msgid "So, now, we know how to retrieve a single page and extract the items from it.  We just need to repeat this operation for every page, and provide a stream."
msgstr "Así pues, ahora sabemos cómo recuperar una sola página y extraer los elementos de la misma. Sólo tenemos que repetir esta operación para cada página, y proporcionar un flujo."

#. type: Plain text
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:116
#, fuzzy
msgid "Mutiny provides a method to create a `Multi` by repeating multiple times a `Uni`.  Under the hood, it calls a method returning a `Uni` and subscribe on it.  But we need to make _progress_, and pass the current page.  Mutiny offers the possibility to store a state in order to let the method creating the `Uni` increments the page number:"
msgstr "Mutiny proporciona un método para crear un `Multi` repitiendo varias veces un `Uni`. Bajo el capó, llama a un método que devuelve un `Uni` y se suscribe a él. Pero necesitamos _avanzar_ y pasar la página actual. Mutiny ofrece la posibilidad de almacenar un estado para que el método que crea el `Uni` incremente el número de página:"

#. type: delimited block -
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:122
#, no-wrap
msgid ""
"Multi.createBy().repeating().uni(AtomicInteger::new, page ->\n"
"\t\tgetPage(client, page.incrementAndGet())\n"
")\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:127
#, fuzzy
msgid "This code above creates a stream with the item emitted by the `Unis` returned by the `getPage` method.  We increment the page number (stored in an `AtomicInteger`) every time.  So, it retrieves the page 1, 2, 3 ... and every time emits the received `List<Beer>` downstream."
msgstr "Este código anterior crea un flujo con el elemento emitido por el `Unis` devuelto por el método `getPage`. Incrementamos el número de página (almacenado en un `AtomicInteger`) cada vez. Por lo tanto, recupera la página 1, 2, 3 ... y cada vez emite el `List&amp;lt;Beer&amp;gt;` recibido por el flujo."

#. type: Plain text
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:130
#, fuzzy
msgid "However, at some point, we must stop.  As we said earlier, we can stop when the returned list is empty:"
msgstr "Sin embargo, en algún momento debemos parar. Como hemos dicho antes, podemos parar cuando la lista devuelta esté vacía:"

#. type: delimited block -
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:137
#, no-wrap
msgid ""
"Multi<List<Beer>> multi = Multi.createBy().repeating().uni(AtomicInteger::new, page ->\n"
"     getPage(client, page.incrementAndGet())\n"
")\n"
".until(List::isEmpty);\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:142
#, fuzzy
msgid "The `until` clause indicates when the iteration must be stopped.  It receives the retrieved list (produced by `getPage`), and when this list is empty, stops the repetition.  If the list still contains beers, it retrieves the next page."
msgstr "La cláusula `until` indica cuándo debe detenerse la iteración. Recibe la lista recuperada (producida por `getPage`), y cuando esta lista está vacía, detiene la repetición. Si la lista todavía contiene cervezas, recupera la siguiente página."

#. type: Plain text
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:144
#, fuzzy
msgid "## Unpacking the beers"
msgstr "Desembalaje de las cervezas"

#. type: Plain text
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:148
#, fuzzy
msgid "We now have a stream of list, and each list contain a set of beers.  We are almost there, but Alex wants a stream of beer.  So we need to unpack the beers."
msgstr "Ahora tenemos un flujo de lista, y cada lista contiene un conjunto de cervezas. Ya casi lo tenemos, pero Alex quiere un flujo de cervezas. Así que tenemos que desempacar las cervezas."

#. type: Plain text
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:150
#, fuzzy
msgid "The first approach to achieve this uses `transformToMultiAndConcatenate`, i.e. for each list create a new `multi` with the contained beers and concatenate these `multis`:"
msgstr "El primer enfoque para conseguirlo utiliza `transformToMultiAndConcatenate`, es decir, para cada lista se crea un nuevo `multi` con las cervezas contenidas y se concatenan estos `multis`:"

#. type: delimited block -
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:158
#, no-wrap
msgid ""
"Multi<Beer> multi = Multi.createBy().repeating().uni(AtomicInteger::new, page ->\n"
"        getPage(client, page.incrementAndGet())\n"
"    )\n"
"    .until(List::isEmpty)\n"
"    .onItem().transformToMultiAndConcatenate(l -> Multi.createFrom().iterable(l));\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:161
#, fuzzy
msgid "Wondering about `concatenate`? Check out this https://quarkus.io/blog/mutiny-redis/[other blog post]"
msgstr "¿Se pregunta por `concatenate`? Consulta esta  link:https://quarkus.io/blog/mutiny-redis/[otra entrada del blog]"

#. type: Plain text
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:163
#, fuzzy
msgid "image:/assets/images/posts/mutiny-pagination/disjoint.png[]"
msgstr "image:/assets/images/posts/mutiny-pagination/disjoint.png[alt=disjoint]"

#. type: Plain text
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:165
#, fuzzy
msgid "Because this is a common operation, Mutiny provides the `disjoint` method doing exactly the same:"
msgstr "Como se trata de una operación común, Mutiny proporciona el método `disjoint` que hace exactamente lo mismo:"

#. type: delimited block -
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:173
#, no-wrap
msgid ""
"Multi<Beer> multi = Multi.createBy().repeating().uni(AtomicInteger::new, page ->\n"
"    getPage(client, page.incrementAndGet())\n"
")\n"
"  .until(List::isEmpty)\n"
"  .onItem().disjoint();\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:176
#, fuzzy
msgid "And we are done!"
msgstr "¡Y ya está!"

#. type: Plain text
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:178
#, fuzzy
msgid "## The benefits of reactive"
msgstr "Las ventajas de la reacción"

#. type: Plain text
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:181
#, fuzzy
msgid "We have our stream, it's time to use it! Let's, for example, retrieve the first 10 beers with \"IPA\" (let's be trendy) in their description:"
msgstr "Tenemos nuestro flujo, ¡es hora de utilizarlo! Recuperemos, por ejemplo, las 10 primeras cervezas con \"IPA\" (seamos modernos) en su descripción:"

#. type: delimited block -
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:187
#, no-wrap
msgid ""
"multi\n"
"    .transform().byFilteringItemsWith(beer -> beer.description.contains(\"IPA\"))\n"
"    .transform().byTakingFirstItems(10);\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:193
#, fuzzy
msgid "The advantage of our stream is that we won't retrieve every page.  As soon as we have enough beers, we stop the repetition.  How? Because it informs the upstream that it does not need more items (*cancellation*) and that stops the repetition.  So, retrieving items from paginated APIs this way can reduce the number of requests and, as a consequence the load on the remote service."
msgstr "La ventaja de nuestro flujo es que no recuperamos todas las páginas. En cuanto tengamos suficientes cervezas, detendremos la repetición. ¿Cómo? Porque se informa al flujo ascendente de que no necesita más elementos *(cancelación*) y eso detiene la repetición. Por lo tanto, recuperar elementos de APIs paginadas de esta manera puede reducir el número de peticiones y, como consecuencia, la carga en el servicio remoto."

#. type: Plain text
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:195
#, fuzzy
msgid "## Feel thirsty?"
msgstr "¿Tienes sed?"

#. type: Plain text
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:198
#, fuzzy
msgid "Wanna try this code, checkout this https://gist.github.com/cescoffier/18a326a5c057392bec54d95ec5a06ca6[gist].  You can run it immediately with jbang:"
msgstr "Si quieres probar este código, revisa este  link:https://gist.github.com/cescoffier/18a326a5c057392bec54d95ec5a06ca6[gist]. Puedes ejecutarlo inmediatamente con jbang:"

#. type: delimited block -
#: upstream/_posts/2020-09-15-mutiny-pagination.adoc:202
#, no-wrap
msgid "jbang https://gist.github.com/cescoffier/18a326a5c057392bec54d95ec5a06ca6\n"
msgstr ""

#, fuzzy
#~ msgid "---\n"
#~ msgstr "---\n"

#, fuzzy
#~ msgid ""
#~ "layout: post\n"
#~ "title: 'Handling paginated APIs with Mutiny'\n"
#~ "date: 2020-09-15\n"
#~ "tags: reactive rest mutiny http pagination\n"
#~ "synopsis: How to use API using pagination with Mutiny\n"
#~ "author: cescoffier\n"
#~ "---\n"
#~ msgstr ""
#~ "layout: post\n"
#~ "title: 'Manejo de APIs paginadas con Mutiny'\n"
#~ "date: 2020-09-15\n"
#~ "tags: reactive rest mutiny http pagination\n"
#~ "synopsis: Cómo utilizar la API mediante la paginación con Mutiny\n"
#~ "author: cescoffier\n"
#~ "---\n"
