# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2022-05-02 07:14+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: YAML Front Matter: author
#: upstream/_posts/2019-07-25-quarkus-dependency-injection.adoc:1
#, fuzzy, no-wrap
msgid "mkouba"
msgstr "mkouba"

#. type: YAML Front Matter: date
#: upstream/_posts/2019-07-25-quarkus-dependency-injection.adoc:1
#, fuzzy, no-wrap
msgid "2019-07-25 00:00 +0100"
msgstr "2019-07-25 00:00 +0100"

#. type: YAML Front Matter: layout
#: upstream/_posts/2019-07-25-quarkus-dependency-injection.adoc:1
#, fuzzy, no-wrap
msgid "post"
msgstr "Correo electrónico:"

#. type: YAML Front Matter: synopsis
#: upstream/_posts/2019-07-25-quarkus-dependency-injection.adoc:1
#, fuzzy, no-wrap
msgid "Quarkus ArC is a build-time oriented dependency injection based on CDI 2.0. But what does it actually mean and what benefits does a build-time processing DI bring?"
msgstr "layout: post date: 2019-07-25 00:00 +0100 author: mkouba tags: extension arc development-tips synopsis: Quarkus ArC es una inyección de dependencias orientada al tiempo de compilación basada en CDI 2.0. Pero, ¿qué significa realmente y qué beneficios aporta una DI de procesamiento en tiempo de compilación? ---"

#. type: YAML Front Matter: tags
#: upstream/_posts/2019-07-25-quarkus-dependency-injection.adoc:1
#, fuzzy, no-wrap
msgid "extension arc development-tips"
msgstr "desarrollo del arco de extensión - consejos"

#. type: Title =
#: upstream/_posts/2019-07-25-quarkus-dependency-injection.adoc:9
#, fuzzy, no-wrap
msgid "Quarkus Dependency Injection"
msgstr "Inyección de dependencia de Quarkus"

#. type: Plain text
#: upstream/_posts/2019-07-25-quarkus-dependency-injection.adoc:13
#, fuzzy
msgid "Quarkus ArC is a build-time oriented dependency injection based on http://cdi-spec.org/[CDI 2.0].  In this blogpost, we're going to explain the relationship to the specification and describe some of the benefits and drawbacks of the build-time processing design."
msgstr "Quarkus ArC es una inyección de dependencias orientada al tiempo de compilación basada en  link:http://cdi-spec.org/[CDI 2.0]. En este blogpost, vamos a explicar la relación con la especificación y describir algunos de los beneficios e inconvenientes del diseño de procesamiento en tiempo de compilación."

#. type: Title ==
#: upstream/_posts/2019-07-25-quarkus-dependency-injection.adoc:14
#, fuzzy, no-wrap
msgid "Compatibility"
msgstr "Compatibilidad"

#. type: Plain text
#: upstream/_posts/2019-07-25-quarkus-dependency-injection.adoc:20
#, fuzzy
msgid "It does not make sense to reinvent the wheel, especially when it comes to dependency injection.  There are many frameworks that try to solve similar problems.  A year ago, we made a design decision to build Quarkus DI on top of CDI.  We had some very good reasons to choose CDI:"
msgstr "No tiene sentido reinventar la rueda, especialmente cuando se trata de la inyección de dependencia. Hay muchos marcos que tratan de resolver problemas similares. Hace un año, tomamos la decisión de construir Quarkus DI sobre CDI. Teníamos muy buenas razones para elegir CDI:"

#. type: Plain text
#: upstream/_posts/2019-07-25-quarkus-dependency-injection.adoc:22
#, fuzzy
msgid "CDI is a mature and proven component model"
msgstr "El CDI es un modelo de componentes maduro y probado"

#. type: Plain text
#: upstream/_posts/2019-07-25-quarkus-dependency-injection.adoc:23
#, fuzzy
msgid "We at Red Hat have almost ten years of experience with developing http://weld.cdi-spec.org/[Weld - the CDI Reference Implementation]"
msgstr "En Red Hat tenemos casi diez años de experiencia en el desarrollo de  link:http://weld.cdi-spec.org/[Weld: la implementación de referencia de CDI]"

#. type: Plain text
#: upstream/_posts/2019-07-25-quarkus-dependency-injection.adoc:24
#, fuzzy
msgid "The CDI API is built on top of `javax.inject` so that it should be easy to migrate from any DI framework compatible with `@Inject`"
msgstr "La API de CDI está construida sobre `javax.inject`, por lo que debería ser fácil migrar desde cualquier marco de trabajo de DI compatible con `@Inject`"

#. type: Plain text
#: upstream/_posts/2019-07-25-quarkus-dependency-injection.adoc:28
#, fuzzy
msgid "Our primary goal was to implement a supersonic build-time oriented DI solution compatible with CDI.  This would allow users to continue using CDI in their applications but also leverage Quarkus build-time optimizations.  However, ArC is not a full CDI implementation verified by the TCK - see also the list of https://quarkus.io/guides/cdi-reference#supported_features[supported features] and the list of https://quarkus.io/guides/cdi-reference#limitations[limitations]."
msgstr "Nuestro objetivo principal era implementar una solución de DI orientada al tiempo de compilación compatible con CDI. Esto permitiría a los usuarios seguir utilizando CDI en sus aplicaciones pero también aprovechar las optimizaciones de tiempo de compilación de Quarkus. Sin embargo, ArC no es una implementación completa de CDI verificada por el TCK - ver también la lista de  link:https://quarkus.io/guides/cdi-reference#supported_features[características soportadas] y la lista de  link:https://quarkus.io/guides/cdi-reference#limitations[limitaciones]."

#. type: Title ==
#: upstream/_posts/2019-07-25-quarkus-dependency-injection.adoc:29
#, fuzzy, no-wrap
msgid "Build-time Processing Benefits and Drawbacks"
msgstr "Ventajas e inconvenientes del procesamiento en tiempo de construcción"

#. type: Title ===
#: upstream/_posts/2019-07-25-quarkus-dependency-injection.adoc:31
#, fuzzy, no-wrap
msgid "Fail Fast"
msgstr "Fallar rápido"

#. type: Plain text
#: upstream/_posts/2019-07-25-quarkus-dependency-injection.adoc:34
#, fuzzy
msgid "Beans and dependencies are validated during the build so that your application can never fail in production with common problems such as `AmbiguousResolutionException` or `UnsatisfiedResolutionException`."
msgstr "Los beans y las dependencias se validan durante la compilación para que su aplicación nunca pueda fallar en producción con problemas comunes como `AmbiguousResolutionException` o `UnsatisfiedResolutionException`."

#. type: Title ===
#: upstream/_posts/2019-07-25-quarkus-dependency-injection.adoc:35
#, fuzzy, no-wrap
msgid "Instant Startup"
msgstr "Inicio instantáneo"

#. type: Plain text
#: upstream/_posts/2019-07-25-quarkus-dependency-injection.adoc:40
#, fuzzy
msgid "When the app starts ArC just loads all the metadata and initializes some internal structures.  There is no need to analyze the application classes again.  This means negligible startup overhead."
msgstr "Cuando la aplicación se inicia, ArC sólo carga todos los metadatos e inicializa algunas estructuras internas. No es necesario volver a analizar las clases de la aplicación. Esto significa una sobrecarga de inicio insignificante."

#. type: Plain text
#: upstream/_posts/2019-07-25-quarkus-dependency-injection.adoc:42
#, fuzzy
msgid "This applies to both the GraalVM and OpenJDK HotSpot runtimes."
msgstr "Esto se aplica tanto a los tiempos de ejecución de GraalVM como de OpenJDK HotSpot."

#. type: Title ===
#: upstream/_posts/2019-07-25-quarkus-dependency-injection.adoc:43
#, fuzzy, no-wrap
msgid "Minimized Runtime"
msgstr "Tiempo de ejecución minimizado"

#. type: Plain text
#: upstream/_posts/2019-07-25-quarkus-dependency-injection.adoc:48
#, fuzzy
msgid "In Quarkus 0.19, ArC plus integration runtime consist of 72 classes and occupies ~ 140 KB in jars.  http://weld.cdi-spec.org/[Weld 3.1.1] (CDI Reference Implementation) core is roughly 1200 classes and approx. 2 MB jar.  In other words, ArC runtime takes approx. 7% of the Weld runtime in terms of number of classes and jar footprint."
msgstr "En Quarkus 0.19, ArC más el tiempo de ejecución de la integración consiste en 72 clases y ocupa ~ 140 KB en jars. El núcleo de Weld  link:http://weld.cdi-spec.org/[3.1.1] (implementación de referencia de CDI) tiene aproximadamente 1200 clases y unos 2 MB de jar. En otras palabras, el tiempo de ejecución de ArC ocupa aproximadamente el 7% del tiempo de ejecución de Weld en términos de número de clases y huella de jar."

#. type: Title ===
#: upstream/_posts/2019-07-25-quarkus-dependency-injection.adoc:49
#, fuzzy, no-wrap
msgid "Optimized Code Paths and Metadata Structures"
msgstr "Rutas de código y estructuras de metadatos optimizadas"

#. type: Plain text
#: upstream/_posts/2019-07-25-quarkus-dependency-injection.adoc:53
#, fuzzy
msgid "When generating the metadata classes ArC can sometimes produce leaner and smarter logic because it has the whole application analyzed already.  This is one of the areas where we would like to develop and improve ArC."
msgstr "Al generar las clases de metadatos, ArC puede producir a veces una lógica más ligera e inteligente porque ya tiene toda la aplicación analizada. Esta es una de las áreas en las que nos gustaría desarrollar y mejorar ArC."

#. type: Title ===
#: upstream/_posts/2019-07-25-quarkus-dependency-injection.adoc:54
#, fuzzy, no-wrap
msgid "Extension Points"
msgstr "Puntos de extensión"

#. type: Plain text
#: upstream/_posts/2019-07-25-quarkus-dependency-injection.adoc:60
#, fuzzy
msgid "Unfortunately, CDI portable extensions are inherently runtime constructs and therefore cannot be fully supported in Quarkus.  In fact, all CDI extensions are ignored at the moment.  Nevertheless, most of the functionality can be achieved using https://quarkus.io/guides/cdi-reference#build-time-extension-points[Quarkus extensions].  The CDI extensions are encouraged to generalize the code, and if possible provide a Quarkus extension to make full use of build-time metadata processing."
msgstr "Desgraciadamente, las extensiones portables CDI son construcciones inherentes al tiempo de ejecución y por lo tanto no pueden ser totalmente soportadas en Quarkus. De hecho, todas las extensiones CDI son ignoradas por el momento. Sin embargo, la mayor parte de la funcionalidad puede lograrse utilizando las  link:https://quarkus.io/guides/cdi-reference#build-time-extension-points[extensiones] de Quarkus. Se anima a las extensiones CDI a generalizar el código y, si es posible, a proporcionar una extensión de Quarkus para hacer pleno uso del procesamiento de metadatos en tiempo de compilación."

#. type: Title ==
#: upstream/_posts/2019-07-25-quarkus-dependency-injection.adoc:61
#, fuzzy, no-wrap
msgid "Non-standard Features"
msgstr "Características no estándar"

#. type: Plain text
#: upstream/_posts/2019-07-25-quarkus-dependency-injection.adoc:65
#, fuzzy
msgid "ArC is not limited to standards and we're constantly looking for ways to go beyond and extend the possibilities.  Following are some examples of non-standard features provided by Quarkus DI."
msgstr "ArC no se limita a los estándares y constantemente buscamos formas de ir más allá y ampliar las posibilidades. A continuación se presentan algunos ejemplos de características no estándar proporcionadas por Quarkus DI."

#. type: Title ===
#: upstream/_posts/2019-07-25-quarkus-dependency-injection.adoc:66
#, fuzzy, no-wrap
msgid "Qualified Injected Fields"
msgstr "Campos inyectados cualificados"

#. type: Plain text
#: upstream/_posts/2019-07-25-quarkus-dependency-injection.adoc:69
#, fuzzy
msgid "Normally, if you declare an injected field you'll always need to use `@Inject` and optionally required qualifiers:"
msgstr "Normalmente, si declaras un campo inyectado siempre tendrás que utilizar `@Inject` y los calificadores opcionales requeridos:"

#. type: delimited block -
#: upstream/_posts/2019-07-25-quarkus-dependency-injection.adoc:75
#, no-wrap
msgid ""
"  @Inject\n"
"  @ConfigProperty(name = \"cool\")\n"
"  String coolProperty;\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2019-07-25-quarkus-dependency-injection.adoc:78
#, fuzzy
msgid "In Quarkus, you can skip the `@Inject` annotation completely if an injected field declares at least one qualifier:"
msgstr "En Quarkus, se puede omitir completamente la anotación `@Inject` si un campo inyectado declara al menos un calificador:"

#. type: delimited block -
#: upstream/_posts/2019-07-25-quarkus-dependency-injection.adoc:83
#, no-wrap
msgid ""
"  @ConfigProperty(name = \"cool\")\n"
"  String coolProperty;\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2019-07-25-quarkus-dependency-injection.adoc:86
#, fuzzy
msgid "`@Inject` is still required for constructor and method injection."
msgstr "`@Inject` sigue siendo necesario para la inyección de constructores y métodos."

#. type: Title ===
#: upstream/_posts/2019-07-25-quarkus-dependency-injection.adoc:87
#, fuzzy, no-wrap
msgid "Simplified Constructor Injection"
msgstr "Inyección de constructores simplificada"

#. type: Plain text
#: upstream/_posts/2019-07-25-quarkus-dependency-injection.adoc:91
#, fuzzy
msgid "In CDI, a normal scoped bean must always declare a no-args constructor (this constructor is normally generated by the compiler unless you declare any other constructor).  However, this requirement complicates constructor injection - you would need to provide a dummy no-args constructor to make things work in CDI."
msgstr "En CDI, un bean de ámbito normal debe declarar siempre un constructor sin cargas (este constructor es normalmente generado por el compilador a menos que se declare cualquier otro constructor). Sin embargo, este requisito complica la inyección de constructores - tendrías que proporcionar un constructor ficticio sin cargas para que las cosas funcionen en CDI."

#. type: delimited block -
#: upstream/_posts/2019-07-25-quarkus-dependency-injection.adoc:96
#: upstream/_posts/2019-07-25-quarkus-dependency-injection.adoc:116
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class MyCoolService {\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2019-07-25-quarkus-dependency-injection.adoc:98
#: upstream/_posts/2019-07-25-quarkus-dependency-injection.adoc:118
#, no-wrap
msgid "  private SimpleProcessor processor;\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2019-07-25-quarkus-dependency-injection.adoc:101
#, no-wrap
msgid ""
"  MyCoolService() { // dummy constructor needed\n"
"  }\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2019-07-25-quarkus-dependency-injection.adoc:107
#, no-wrap
msgid ""
"  @Inject // constructor injection\n"
"  MyCoolService(SimpleProcessor processor) {\n"
"    this.processor = processor;\n"
"  }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2019-07-25-quarkus-dependency-injection.adoc:111
#, fuzzy
msgid "There is no need to declare dummy constructors for normal scoped bean in Quarkus - they are generated automatically.  Also if there's only one constructor there is no need for `@Inject`."
msgstr "No hay necesidad de declarar constructores ficticios para un bean de ámbito normal en Quarkus - se generan automáticamente. Además, si sólo hay un constructor no es necesario `@Inject`."

#. type: delimited block -
#: upstream/_posts/2019-07-25-quarkus-dependency-injection.adoc:123
#, no-wrap
msgid ""
"  MyCoolService(SimpleProcessor processor) {\n"
"    this.processor = processor;\n"
"  }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2019-07-25-quarkus-dependency-injection.adoc:126
#, fuzzy
msgid "We don't generate a no-args constructor automatically if a bean class extends another class that does not declare a no-args constructor."
msgstr "No generamos un constructor no-args automáticamente si una clase bean extiende otra clase que no declara un constructor no-args."

#. type: Title ===
#: upstream/_posts/2019-07-25-quarkus-dependency-injection.adoc:127
#, fuzzy, no-wrap
msgid "Default Beans"
msgstr "Frijoles por defecto"

#. type: Plain text
#: upstream/_posts/2019-07-25-quarkus-dependency-injection.adoc:131
#, fuzzy
msgid "CDI has a feature called https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#alternatives[alternatives].  Simply said a bean annotated with `@Alternative` and `@Priority` takes precedence over the non-alternative beans during type-safe resolution."
msgstr "CDI tiene una característica llamada  link:https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#alternatives[alternativas]. Simplemente se dice que un bean anotado con `@Alternative` y `@Priority` tiene prioridad sobre los beans no alternativos durante la resolución a prueba de tipos."

#. type: delimited block -
#: upstream/_posts/2019-07-25-quarkus-dependency-injection.adoc:136
#, no-wrap
msgid ""
"class MyBean {\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2019-07-25-quarkus-dependency-injection.adoc:141
#, no-wrap
msgid ""
"@Alternative\n"
"@Priority(1)\n"
"class MyAlternativeBean extends MyBean {\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2019-07-25-quarkus-dependency-injection.adoc:144
#, no-wrap
msgid ""
"@Inject // MyAlternativeBean wins and is injected!\n"
"MyBean bean;\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2019-07-25-quarkus-dependency-injection.adoc:153
#, fuzzy
msgid "So, what if a user wants to override a bean defined by a library/extension? The bean would have to be marked as a CDI `@Alternative` that is enabled using the `@Priority` annotation.  Is there a simpler approach? Yes, there is.  You can use a non-standard feature called \"default beans\".  In this case, a bean that can be overridden should be annotated with `@io.quarkus.arc.DefaultBean`.  And that's it."
msgstr "Entonces, ¿qué pasa si un usuario quiere anular un bean definido por una biblioteca/extensión? El bean tendría que ser marcado como un CDI `@Alternative` que está habilitado usando la anotación `@Priority`. ¿Existe un enfoque más sencillo? Sí, lo hay. Puedes utilizar una característica no estándar llamada \"beans por defecto\". En este caso, un bean que puede ser anulado debe ser anotado con `@io.quarkus.arc.DefaultBean`. Y eso es todo."

#. type: delimited block -
#: upstream/_posts/2019-07-25-quarkus-dependency-injection.adoc:159
#, no-wrap
msgid ""
"@DefaultBean\n"
"class MyBean {\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2019-07-25-quarkus-dependency-injection.adoc:162
#, no-wrap
msgid ""
"class MyOwnBean extends MyBean {\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2019-07-25-quarkus-dependency-injection.adoc:165
#, no-wrap
msgid ""
"@Inject // MyOwnBean wins and is injected!\n"
"MyBean bean;\n"
msgstr ""

#. type: Title ===
#: upstream/_posts/2019-07-25-quarkus-dependency-injection.adoc:167
#, fuzzy, no-wrap
msgid "Removing Unused Beans"
msgstr "Eliminación de los granos no utilizados"

#. type: Plain text
#: upstream/_posts/2019-07-25-quarkus-dependency-injection.adoc:173
#, fuzzy
msgid "GraalVM native image does a pretty good job when removing all classes that are not reachable from your application.  However, sometimes checking reachability is not enough.  Sometimes the framework itself must decide whether a component is needed or not.  In standard CDI, all beans are retained by the container no matter whether they're needed or not."
msgstr "La imagen nativa de GraalVM hace un buen trabajo al eliminar todas las clases que no son alcanzables desde su aplicación. Sin embargo, a veces comprobar la accesibilidad no es suficiente. A veces el propio framework debe decidir si un componente es necesario o no. En el CDI estándar, todos los beans son retenidos por el contenedor sin importar si son necesarios o no."

#. type: Plain text
#: upstream/_posts/2019-07-25-quarkus-dependency-injection.adoc:180
#, fuzzy
msgid "Let's suppose we have a bean class `org.acme.Foo`.  This bean class imports and uses a lot of various classes.  It's annotated with `@ApplicationScoped` and so Quarkus needs to generate a bean metadata class and a client proxy and register this metadata when the application starts.  But what if nobody ever uses this bean? We would still hold a reference on the generated metadata, and the bean class itself, and its dependencies.  In other words, all these classes would be reachable."
msgstr "Supongamos que tenemos una clase bean `org.acme.Foo`. Esta clase bean importa y utiliza un montón de clases diversas. Está anotada con `@ApplicationScoped` y, por tanto, Quarkus necesita generar una clase de metadatos del bean y un proxy del cliente y registrar estos metadatos cuando se inicia la aplicación. ¿Pero qué pasa si nadie utiliza nunca este bean? Seguiríamos manteniendo una referencia sobre los metadatos generados, y la propia clase bean, y sus dependencias. En otras palabras, todas estas clases serían accesibles."

#. type: Plain text
#: upstream/_posts/2019-07-25-quarkus-dependency-injection.adoc:187
#, fuzzy
msgid "Quarkus attempts to remove all *unused beans* during build by default.  This helps to reduce the number of generated classes and also the amount of memory needed at runtime.  But how do we actually detect an unused bean? The rules are described in the https://quarkus.io/guides/cdi-reference#remove_unused_beans[reference guide] but simply said: if a bean is not injected anywhere and cannot be reached in any other standard way (e.g. observer notification) it is removed.  Moreover, users can instruct the container to not remove a bean by annotating the bean class with `@io.quarkus.arc.Unremovable`.  Finally, this optimization can be disabled and fine tuned by using the `quarkus.arc.remove-unused-beans` property."
msgstr "Quarkus intenta eliminar todos los *beans no utilizados* durante la construcción por defecto. Esto ayuda a reducir el número de clases generadas y también la cantidad de memoria necesaria en tiempo de ejecución. ¿Pero cómo detectamos realmente un bean no utilizado? Las reglas se describen en la  link:https://quarkus.io/guides/cdi-reference#remove_unused_beans[guía de referencia], pero se dice simplemente: si un bean no se inyecta en ningún sitio y no se puede acceder a él de ninguna otra forma estándar (por ejemplo, mediante una notificación de observador), se elimina. Además, los usuarios pueden ordenar al contenedor que no elimine un bean anotando la clase bean con `@io.quarkus.arc.Unremovable`. Por último, esta optimización puede desactivarse y ajustarse mediante la propiedad `quarkus.arc.remove-unused-beans`."

#. type: Plain text
#: upstream/_posts/2019-07-25-quarkus-dependency-injection.adoc:188
#, fuzzy
msgid "This feature applies to the JVM mode as well."
msgstr "Esta característica se aplica también al modo JVM."

#, fuzzy
#~ msgid "---\n"
#~ msgstr "---\n"
