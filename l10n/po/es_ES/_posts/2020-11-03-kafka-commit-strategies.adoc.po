# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2022-05-02 07:14+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: YAML Front Matter: author
#: upstream/_posts/2020-11-03-kafka-commit-strategies.adoc:1
#, no-wrap
msgid "cescoffier"
msgstr ""

#. type: YAML Front Matter: date
#: upstream/_posts/2020-11-03-kafka-commit-strategies.adoc:1
#, no-wrap
msgid "2020-11-03"
msgstr ""

#. type: YAML Front Matter: layout
#: upstream/_posts/2020-11-03-kafka-commit-strategies.adoc:1
#, no-wrap
msgid "post"
msgstr ""

#. type: YAML Front Matter: synopsis
#: upstream/_posts/2020-11-03-kafka-commit-strategies.adoc:1
#, no-wrap
msgid "Offset commiting strategies in the Kafka connector"
msgstr ""

#. type: YAML Front Matter: tags
#: upstream/_posts/2020-11-03-kafka-commit-strategies.adoc:1
#, no-wrap
msgid "reactive kafka"
msgstr ""

#. type: YAML Front Matter: title
#: upstream/_posts/2020-11-03-kafka-commit-strategies.adoc:1
#, no-wrap
msgid "Kafka - When to commit?"
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-11-03-kafka-commit-strategies.adoc:15
#, fuzzy
msgid "In a https://quarkus.io/blog/kafka-failure-strategy/[previous blog post], we have looked at failure strategies provided by the Reactive Messaging Kafka connector.  But, imagine it's our lucky day, and for once it worked.  We should inform Kafka that the processing succeeded.  In Kafka terminology, we call this: _offset commit_.  This post covers the different strategies to commit offsets with the Reactive Messaging Kafka connector."
msgstr "En una  link:https://quarkus.io/blog/kafka-failure-strategy/[entrada anterior del blog], hemos analizado las estrategias de fallo proporcionadas por el conector Kafka de Reactive Messaging. Pero, imagina que es nuestro día de suerte, y por una vez ha funcionado. Debemos informar a Kafka de que el procesamiento ha tenido éxito. En la terminología de Kafka, llamamos a esto: _offset commit_. Este post cubre las diferentes estrategias para cometer offsets con el conector Kafka de Mensajería Reactiva."

#. type: Plain text
#: upstream/_posts/2020-11-03-kafka-commit-strategies.adoc:17
#, fuzzy
msgid "## Kafka Consumer Group and Offsets"
msgstr "Grupo de consumidores Kafka y compensaciones"

#. type: Plain text
#: upstream/_posts/2020-11-03-kafka-commit-strategies.adoc:21
#, fuzzy
msgid "Kafka organizes records (_i.e._ messages) around _topics_.  Each topic has a name, and applications send records to topics and poll records from topics.  So far, nothing out of the ordinary."
msgstr "Kafka organiza los registros _(_ es decir, los mensajes) en torno a _temas_. Cada tema tiene un nombre, y las aplicaciones envían registros a los temas y consultan los registros de los temas. Hasta aquí, nada fuera de lo común."

#. type: Plain text
#: upstream/_posts/2020-11-03-kafka-commit-strategies.adoc:28
#, fuzzy
msgid "Topics are divided into partitions.  Each partition is an ordered, immutable sequence of records.  Sending a message to a topic appends it to the selected partition.  Each message from a partition gets a sequential id number called _offset_.  It uniquely identifies each message within the partition.  So, with Kafka, you can identify an individual record using a `<topic, partition, offset>` tuple."
msgstr "Los temas se dividen en particiones. Cada partición es una secuencia ordenada e inmutable de registros. El envío de un mensaje a un tema lo añade a la partición seleccionada. Cada mensaje de una partición recibe un número de identificación secuencial llamado _offset_. Éste identifica de forma única cada mensaje dentro de la partición. Así, con Kafka, se puede identificar un registro individual utilizando una tupla `&amp;lt;topic, partition, offset&amp;gt;`."

#. type: Plain text
#: upstream/_posts/2020-11-03-kafka-commit-strategies.adoc:30
#, fuzzy
msgid "image:/assets/images/posts/kafka-commit-strategies/topics-partitions.png[]"
msgstr "image:/assets/images/posts/kafka-commit-strategies/topics-partitions.png[alt=topics partitions]"

#. type: Plain text
#: upstream/_posts/2020-11-03-kafka-commit-strategies.adoc:35
#, fuzzy
msgid "When an application consumes messages from Kafka, it uses a Kafka consumer.  With this consumer, it polls batches of messages from a specific topic, for example, `movies` or `actors`.  Retrieved messages belong to partitions assigned to this consumer.  And that aspect is essential."
msgstr "Cuando una aplicación consume mensajes de Kafka, utiliza un consumidor de Kafka. Con este consumidor, sondea lotes de mensajes de un tema específico, por ejemplo, `movies` o `actors`. Los mensajes recuperados pertenecen a particiones asignadas a este consumidor. Y este aspecto es esencial."

#. type: Plain text
#: upstream/_posts/2020-11-03-kafka-commit-strategies.adoc:39
#, fuzzy
msgid "Consumers belong to a consumer group, identified with a name (`A` and `B` in the picture above).  A group contains one or more consumers.  In general, when you scale up your application, it creates a consumer joining the same group."
msgstr "Los consumidores pertenecen a un grupo de consumidores, identificado con un nombre ( `A` y `B` en la imagen de arriba). Un grupo contiene uno o más consumidores. En general, cuando escalas tu aplicación, ésta crea un consumidor que se une al mismo grupo."

#. type: Plain text
#: upstream/_posts/2020-11-03-kafka-commit-strategies.adoc:41
#, fuzzy
msgid "image:/assets/images/posts/kafka-commit-strategies/consumer-groups.png[]"
msgstr "image:/assets/images/posts/kafka-commit-strategies/consumer-groups.png[alt=consumer groups]"

#. type: Plain text
#: upstream/_posts/2020-11-03-kafka-commit-strategies.adoc:49
#, fuzzy
msgid "Each consumer group receives each record from a topic once.  To achieve this, it assigns each consumer from a group to a set of partitions.  For example, in the above picture, the consumer from the application A1 receives the records from the partitions 0 and 1.  A2 receives the records from the partition 2.  App B is the only consumer from its consumer group.  So, it gets the records from all three partitions.  Consequently (ignore rebalance or other subtilities for now), each record from a topic is only received once per consumer group, by a specific consumer from that group."
msgstr "Cada grupo de consumidores recibe cada registro de un tema una vez. Para ello, asigna cada consumidor de un grupo a un conjunto de particiones. Por ejemplo, en la imagen anterior, el consumidor de la aplicación A1 recibe los registros de las particiones 0 y 1. A2 recibe los registros de la partición 2. La aplicación B es el único consumidor de su grupo de consumidores. Por lo tanto, recibe los registros de las tres particiones. En consecuencia (ignorando por ahora el rebalanceo u otras subtilidades), cada registro de un tema sólo se recibe una vez por grupo de consumidores, por un consumidor específico de ese grupo."

#. type: Plain text
#: upstream/_posts/2020-11-03-kafka-commit-strategies.adoc:54
#, fuzzy
msgid "To orchestrate each consumer group's progress, each consumer periodically informs the broker of its current position - the last processed offset.  It commits the offset, indicating that all the previous records from that partition have been processed.  So, if a consumer stops and comes back later, it restarts from the last committed position (if assigned to that partition again).  Note that this behavior is configurable."
msgstr "Para orquestar el progreso de cada grupo de consumidores, cada consumidor informa periódicamente al agente de su posición actual: el último desplazamiento procesado. El consumidor confirma el desplazamiento, indicando que todos los registros anteriores de esa partición han sido procesados. Así, si un consumidor se detiene y vuelve más tarde, vuelve a empezar desde la última posición comprometida (si se asigna a esa partición de nuevo). Tenga en cuenta que este comportamiento es configurable."

#. type: Plain text
#: upstream/_posts/2020-11-03-kafka-commit-strategies.adoc:61
#, fuzzy
msgid "What's important to notice is the periodic aspect of the commit.  Offset commit is expensive, and to enhance performance, we should not commit the offset after each processed record.  In this regard, Kafka behaves differently from traditional messaging solutions, such as JMS, which acknowledges each message individually.  Another important characteristic is the positional aspect of the commit.  You commit the position indicating that all the records located before that position are processed.  But is it really the case?"
msgstr "Lo que es importante notar es el aspecto periódico del commit. El commit del offset es caro, y para mejorar el rendimiento, no deberíamos hacer el commit del offset después de cada registro procesado. En este sentido, Kafka se comporta de forma diferente a las soluciones de mensajería tradicionales, como JMS, que reconoce cada mensaje individualmente. Otra característica importante es el aspecto posicional del commit. El commit de la posición indica que todos los registros situados antes de esa posición son procesados. Pero, ¿es realmente así?"

#. type: Plain text
#: upstream/_posts/2020-11-03-kafka-commit-strategies.adoc:63
#, fuzzy
msgid "### The Kafka default behavior"
msgstr "El comportamiento por defecto de Kafka"

#. type: Plain text
#: upstream/_posts/2020-11-03-kafka-commit-strategies.adoc:66
#, fuzzy
msgid "The Apache Kafka consumer uses an auto-commit approach by default.  Applications using such a consumer are structured around a polling loop:"
msgstr "El consumidor de Apache Kafka utiliza un enfoque de autocompromiso por defecto. Las aplicaciones que utilizan dicho consumidor se estructuran en torno a un bucle de sondeo:"

#. type: delimited block -
#: upstream/_posts/2020-11-03-kafka-commit-strategies.adoc:73
#, no-wrap
msgid ""
"while(true) {\n"
"    ConsumerRecords records = consumer.poll(Duration.ofMillis(10000));\n"
"    processRetrievedRecords(records);\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-11-03-kafka-commit-strategies.adoc:77
#, fuzzy
msgid "Such a program polls a batch of records, processes them, and then polls the next set.  While calling the `poll` method, the consumer periodically commits the last offset of the previous batches transparently."
msgstr "Un programa de este tipo sondea un lote de registros, los procesa y luego sondea el siguiente conjunto. Mientras llama al método `poll`, el consumidor consigna periódicamente el último desplazamiento de los lotes anteriores de forma transparente."

#. type: Plain text
#: upstream/_posts/2020-11-03-kafka-commit-strategies.adoc:83
#, fuzzy
msgid "Quite nice, right? If the application fails to process a message, it throws an exception, which either interrupts the while loop or is handled gracefully (within the `processRetrievedRecords` method).  In the first case, it means that it won't commit anymore (as it happens in the `poll` method, not called anymore).  If the application restarts, it resumes from the last committed offset (or apply the `auto.offset.reset` strategy, defaulting to `latest`, if there are no offsets for this group yet).  It may re-process a set of messages (it's the application's responsibility to handle duplicates), but at least nothing is lost."
msgstr "Muy bonito, ¿verdad? Si la aplicación falla al procesar un mensaje, lanza una excepción, que o bien interrumpe el bucle while o bien se maneja con gracia (dentro del método `processRetrievedRecords` ). En el primer caso, significa que no se comprometerá más (como sucede en el método `poll`, que ya no se llama). Si la aplicación se reinicia, se reanuda desde el último desplazamiento comprometido (o aplica la estrategia `auto.offset.reset`, por defecto `latest`, si aún no hay desplazamientos para este grupo). Puede volver a procesar un conjunto de mensajes (es responsabilidad de la aplicación manejar los duplicados), pero al menos no se pierde nada."

#. type: Plain text
#: upstream/_posts/2020-11-03-kafka-commit-strategies.adoc:86
#, fuzzy
msgid "So, is there anything wrong with this? Looks wonderful... until you add a pinch of asynchrony."
msgstr "Entonces, ¿hay algo malo en esto? Parece maravilloso... hasta que añades una pizca de asincronía."

#. type: Plain text
#: upstream/_posts/2020-11-03-kafka-commit-strategies.adoc:88
#, fuzzy
msgid "## What if the message's processing is asynchronous"
msgstr "¿Y si el procesamiento del mensaje es asíncrono?"

#. type: Plain text
#: upstream/_posts/2020-11-03-kafka-commit-strategies.adoc:93
#, fuzzy
msgid "If the message processing is asynchronous (offloaded to another thread, use non-blocking I/O...), failures may not interrupt the while loop from above.  Failure happens asynchronously, outside the polling thread.  If the `poll` method gets called again despite a failed processing, and _auto-commit_ is still enabled, we may commit offsets while something wrong happened.  If some processing of previously retrieved records is not completed yet, while this auto commit happens, it may consider the record as processed correctly, but the outcome is unknown at that point."
msgstr "Si el procesamiento de los mensajes es asíncrono (se descarga a otro hilo, se utiliza E/S sin bloqueo...), los fallos no pueden interrumpir el bucle while de arriba. El fallo se produce de forma asíncrona, fuera del hilo de sondeo. Si el método `poll` es llamado de nuevo a pesar de un procesamiento fallido, y _el auto-commit_ está todavía habilitado, podemos comprometer los offsets mientras que algo incorrecto ocurrió. Si algún procesamiento de los registros previamente recuperados no se ha completado aún, mientras este auto-commit ocurre, puede considerar el registro como procesado correctamente, pero el resultado es desconocido en ese punto."

#. type: Plain text
#: upstream/_posts/2020-11-03-kafka-commit-strategies.adoc:102
#, fuzzy
msgid "So to handle these case, we can disable the auto-commit and switch to manual commit.  In this case, it's the application's responsibility to commit the offsets regularly.  So, the application needs to track the polled records, their processing, failures, and periodically commits the offsets.  It might not look too tricky, but actually, it can become quite challenging.  Again, in asynchronous scenarios, you may complete the processing of messages in various orders.  For example, if you call a remote service for each record, the responses may not come in the same orders as the records.  You need to track messages individually and only commit the offsets if all the previous messages are processed successfully.  Without this, you may commit offsets while there is processing from previous records still in progress or even failed processing."
msgstr "Así que para manejar este caso, podemos desactivar el auto-commit y cambiar a commit manual. En este caso, es responsabilidad de la aplicación confirmar los desplazamientos regularmente. Así, la aplicación necesita hacer un seguimiento de los registros encuestados, su procesamiento, los fallos, y periódicamente confirma las compensaciones. Puede que no parezca demasiado complicado, pero en realidad, puede convertirse en todo un reto. De nuevo, en escenarios asíncronos, puedes completar el procesamiento de los mensajes en varios órdenes. Por ejemplo, si llamas a un servicio remoto para cada registro, las respuestas pueden no venir en el mismo orden que los registros. Es necesario realizar un seguimiento de los mensajes de forma individual y sólo consignar los desplazamientos si todos los mensajes anteriores se procesan con éxito. Si no lo hace, puede consignar los desplazamientos mientras el procesamiento de los registros anteriores aún está en curso o incluso el procesamiento ha fracasado."

#. type: Plain text
#: upstream/_posts/2020-11-03-kafka-commit-strategies.adoc:104
#, fuzzy
msgid "What can we do about this?"
msgstr "¿Qué podemos hacer al respecto?"

#. type: Plain text
#: upstream/_posts/2020-11-03-kafka-commit-strategies.adoc:106
#, fuzzy
msgid "## Kafka connector commit strategies"
msgstr "Estrategias de confirmación del conector Kafka"

#. type: Plain text
#: upstream/_posts/2020-11-03-kafka-commit-strategies.adoc:108
#, fuzzy
msgid "When using Reactive Messaging and the Kafka connector, you entered an asynchronous world."
msgstr "Cuando se utiliza la mensajería reactiva y el conector Kafka, se entra en un mundo asíncrono."

#. type: Plain text
#: upstream/_posts/2020-11-03-kafka-commit-strategies.adoc:113
#, fuzzy
msgid "Message processing may not happen synchronously and sequentially.  When a Reactive Messaging `Message` processing completes, it acknowledges the message.  In the case of processing failures, it sends a negative acknowledgment.  The Kafka connector receives these acknowledgments and can decide what needs to be done, basically: to commit or not to commit."
msgstr "El procesamiento de los mensajes puede no ocurrir de forma sincrónica y secuencial. Cuando el procesamiento de la Mensajería Reactiva `Message` finaliza, acusa recibo del mensaje. En el caso de fallos en el procesamiento, envía un acuse de recibo negativo. El conector Kafka recibe estos acuses de recibo y puede decidir lo que debe hacerse, básicamente: comprometer o no comprometer."

#. type: Plain text
#: upstream/_posts/2020-11-03-kafka-commit-strategies.adoc:115
#, fuzzy
msgid "You can choose among three strategies:"
msgstr "Puedes elegir entre tres estrategias:"

#. type: Plain text
#: upstream/_posts/2020-11-03-kafka-commit-strategies.adoc:117
#, fuzzy
msgid "throttled (default starting Quarkus 1.10)"
msgstr "estrangulado (por defecto a partir de Quarkus 1.10)"

#. type: Plain text
#: upstream/_posts/2020-11-03-kafka-commit-strategies.adoc:118
#, fuzzy
msgid "latest (default before Quarkus 1.10)"
msgstr "último (por defecto antes de Quarkus 1.10)"

#. type: Plain text
#: upstream/_posts/2020-11-03-kafka-commit-strategies.adoc:119
#, fuzzy
msgid "ignore (default if `enabled.auto.commit=true` is set)"
msgstr "ignorar (por defecto si `enabled.auto.commit=true` está configurado)"

#. type: Plain text
#: upstream/_posts/2020-11-03-kafka-commit-strategies.adoc:121
#, fuzzy
msgid "This is configured using the `commit-strategy` attribute:"
msgstr "Esto se configura mediante el atributo `commit-strategy`:"

#. type: delimited block -
#: upstream/_posts/2020-11-03-kafka-commit-strategies.adoc:126
#: upstream/_posts/2020-11-03-kafka-commit-strategies.adoc:142
#, no-wrap
msgid ""
"mp.messaging.incoming.my-channel.connector=smallrye-kafka\n"
"mp.messaging.incoming.my-channel.commit-strategy=throttled\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-11-03-kafka-commit-strategies.adoc:129
#, fuzzy
msgid "## The throttled strategy"
msgstr "La estrategia de estrangulamiento"

#. type: Plain text
#: upstream/_posts/2020-11-03-kafka-commit-strategies.adoc:134
#, fuzzy
msgid "The throttled strategy can be seen as an asynchronous variant of the default \"auto-commit\" behavior described above.  When enabled, the connector tracks each received message and monitors their acknowledgment.  When the connector finds out that all messages before a position are processed successfully, it commits that position.  This commit happens periodically to avoid committing too often."
msgstr "La estrategia de aceleración puede verse como una variante asíncrona del comportamiento por defecto \"auto-commit\" descrito anteriormente. Cuando está activada, el conector hace un seguimiento de cada mensaje recibido y supervisa su acuse de recibo. Cuando el conector descubre que todos los mensajes anteriores a una posición se han procesado con éxito, consigna esa posición. Esta consignación se realiza periódicamente para evitar que se realice con demasiada frecuencia."

#. type: Plain text
#: upstream/_posts/2020-11-03-kafka-commit-strategies.adoc:137
#, fuzzy
msgid "This strategy provides very good throughput and can handle asynchronous processing.  To enable this strategy configures the channel with:"
msgstr "Esta estrategia proporciona un muy buen rendimiento y puede manejar el procesamiento asíncrono. Para habilitar esta estrategia configura el canal con:"

#. type: Plain text
#: upstream/_posts/2020-11-03-kafka-commit-strategies.adoc:150
#, fuzzy
msgid "There is one detail to mention.  If an old message is neither acked nor nacked, the strategy cannot commit the position anymore.  It will enqueue messages forever, waiting for that missing ack to happen.  It can lead to out of memory, as the connector would never be able to commit a position and to clear the queue.  Fortunately, the strategy detects this situation and reports a failure to the connector, marking the application unhealthy.  The `throttled.unprocessed-record-max-age.ms` attribute configures the deadline for each message to be acked or nacked before being considered as a poison pill (Default is 1 minute)."
msgstr "Hay un detalle que mencionar. Si un mensaje antiguo no es ack ni nacked, la estrategia no puede comprometer más la posición. Pondrá en cola los mensajes para siempre, esperando que se produzca ese ack que falta. Esto puede llevar a que se agote la memoria, ya que el conector nunca podría comprometer una posición y despejar la cola. Afortunadamente, la estrategia detecta esta situación e informa de un fallo al conector, marcando la aplicación como no saludable. El atributo `throttled.unprocessed-record-max-age.ms` configura el plazo para que cada mensaje sea ackeado o nacked antes de ser considerado como una píldora venenosa (El valor predeterminado es 1 minuto)."

#. type: Plain text
#: upstream/_posts/2020-11-03-kafka-commit-strategies.adoc:152
#, fuzzy
msgid "## The Ignore strategy"
msgstr "La estrategia de ignorar"

#. type: Plain text
#: upstream/_posts/2020-11-03-kafka-commit-strategies.adoc:157
#, fuzzy
msgid "The connector uses this strategy by default if you explicitly enabled Kafka's auto-commit (with the `enable.auto.commit` attribute set to `true`).  In this case, the connector ignores acknowledgment and won't commit the offsets.  The Kafka consumer commits the offset periodically when polling batches, as described above.  This strategy works well if the message processing is synchronous and failures handled gracefully."
msgstr "El conector utiliza esta estrategia por defecto si se habilita explícitamente el autocommit de Kafka (con el atributo `enable.auto.commit` establecido en `true`). En este caso, el conector ignora el acuse de recibo y no consigna los desplazamientos. El consumidor de Kafka consigna el desplazamiento periódicamente al sondear los lotes, como se ha descrito anteriormente. Esta estrategia funciona bien si el procesamiento de mensajes es sincrónico y los fallos se manejan con elegancia."

#. type: Plain text
#: upstream/_posts/2020-11-03-kafka-commit-strategies.adoc:159
#, fuzzy
msgid "You can enable this strategy by configured enabled-auto-commit to true:"
msgstr "Puedes activar esta estrategia configurando enabled-auto-commit a true:"

#. type: delimited block -
#: upstream/_posts/2020-11-03-kafka-commit-strategies.adoc:164
#, no-wrap
msgid ""
"mp.messaging.incoming.my-channel.connector=smallrye-kafka\n"
"mp.messaging.incoming.my-channel.enable.auto.commit=true\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-11-03-kafka-commit-strategies.adoc:167
#, fuzzy
msgid "Be aware that starting Quarkus 1.9, auto commit is disabled by default. So you need to explicitly enable it."
msgstr "Ten en cuenta que a partir de Quarkus 1.9, el autocompromiso está desactivado por defecto. Por lo tanto, es necesario habilitarlo explícitamente."

#. type: Plain text
#: upstream/_posts/2020-11-03-kafka-commit-strategies.adoc:171
#, fuzzy
msgid "If you don't enable auto-commit, using this strategy is still possible but will never commit the offsets.  In other words, you would restart from the oldest stored records every time.  While there are use cases for this, double-check that's what you want. In this case, enable this strategy with:"
msgstr "Si no se habilita el autocommit, todavía es posible utilizar esta estrategia, pero nunca se comprometerán los offsets. En otras palabras, se reiniciaría desde los registros almacenados más antiguos cada vez. Aunque hay casos de uso para esto, compruebe que es lo que quiere. En este caso, habilite esta estrategia con:"

#. type: delimited block -
#: upstream/_posts/2020-11-03-kafka-commit-strategies.adoc:176
#, no-wrap
msgid ""
"mp.messaging.incoming.my-channel.connector=smallrye-kafka\n"
"mp.messaging.incoming.my-channel.commit-strategy=ignore\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-11-03-kafka-commit-strategies.adoc:179
#, fuzzy
msgid "## The latest strategy"
msgstr "La última estrategia"

#. type: Plain text
#: upstream/_posts/2020-11-03-kafka-commit-strategies.adoc:183
#, fuzzy, no-wrap
msgid ""
"This strategy commits the offset every time a message is acknowledged.\n"
"This strategy tends to commit often, and so decrease the throughput.   \n"
"However, it also reduces the risk of duplicates if the messages are processed synchronously. \n"
msgstr "Esta estrategia consigna el desplazamiento cada vez que se acusa recibo de un mensaje. Esta estrategia tiende a comprometer a menudo, y por lo tanto disminuir el rendimiento. Sin embargo, también reduce el riesgo de duplicados si los mensajes se procesan de forma sincrónica."

#. type: Plain text
#: upstream/_posts/2020-11-03-kafka-commit-strategies.adoc:185
#, fuzzy
msgid "Enable this strategy with:"
msgstr "Habilita esta estrategia con:"

#. type: delimited block -
#: upstream/_posts/2020-11-03-kafka-commit-strategies.adoc:190
#, no-wrap
msgid ""
"mp.messaging.incoming.my-channel.connector=smallrye-kafka\n"
"mp.messaging.incoming.my-channel.commit-strategy=latest\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2020-11-03-kafka-commit-strategies.adoc:193
#, fuzzy
msgid "## Conclusion"
msgstr "Conclusión"

#. type: Plain text
#: upstream/_posts/2020-11-03-kafka-commit-strategies.adoc:198
#, fuzzy
msgid "In general, use the `throttled` strategy.  It provides high-throughput and handles the asynchronous use cases.  This strategy is becoming the default strategy in Quarkus 1.10.  You can also switch to the `ignore` strategy if the Kafka auto-commit is acceptable for you, or if you want to skip offset commit altogether."
msgstr "En general, utilice la estrategia `throttled`. Proporciona un alto rendimiento y maneja los casos de uso asíncronos. Esta estrategia se está convirtiendo en la estrategia por defecto en Quarkus 1.10. También puede cambiar a la estrategia `ignore` si el autocommit de Kafka es aceptable para usted, o si desea omitir el commit de compensación por completo."

#. type: Plain text
#: upstream/_posts/2020-11-03-kafka-commit-strategies.adoc:200
#, fuzzy
msgid "That concludes this blog post.  The next one will discuss how to receive and produce Cloud Events using the Kafka connector."
msgstr "Con esto concluye esta entrada del blog. En la próxima se hablará de cómo recibir y producir Cloud Events utilizando el conector Kafka."

#, fuzzy
#~ msgid "---\n"
#~ msgstr "---\n"

#, fuzzy
#~ msgid ""
#~ "layout: post\n"
#~ "title: Kafka - When to commit?\n"
#~ "date: 2020-11-03\n"
#~ "tags: reactive kafka\n"
#~ "synopsis: Offset commiting strategies in the Kafka connector\n"
#~ "author: cescoffier\n"
#~ "---\n"
#~ msgstr ""
#~ "layout: post\n"
#~ "title: Kafka - ¿Cuándo comprometerse?\n"
#~ "date: 2020-11-03\n"
#~ "tags: reactive kafka\n"
#~ "synopsis: Estrategias de consignación en el conector Kafka\n"
#~ "author: cescoffier\n"
#~ "---\n"
