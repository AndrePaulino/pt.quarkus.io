# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2022-09-12 12:19+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: YAML Front Matter: author
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:1
#, fuzzy, no-wrap
msgid "cescoffier"
msgstr "cescoffier"

#. type: YAML Front Matter: date
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:1
#, fuzzy, no-wrap
msgid "2022-09-15"
msgstr "2022-09-15"

#. type: YAML Front Matter: layout
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:1
#, no-wrap
msgid "post"
msgstr "post"

#. type: YAML Front Matter: synopsis
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:1
#, fuzzy, no-wrap
msgid "Implementing a job queue using Redis list and the Quarkus Redis extension"
msgstr "Implementación de una cola de trabajo utilizando Redis list y la extensión de Quarkus Redis"

#. type: YAML Front Matter: tags
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:1
#, fuzzy, no-wrap
msgid "redis"
msgstr "redis"

#. type: YAML Front Matter: title
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:1
#, fuzzy, no-wrap
msgid "How to implement a job queue with Redis"
msgstr "Cómo implementar una cola de trabajo con Redis"

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:14
#, fuzzy
msgid "In https://quarkus.io/blog/redis-api-intro/[how to cache with Redis], we implemented a simple cache backed by Redis. + That's just one use case of Redis.  Redis is also used as a messaging server to implement the processing of background jobs or other kinds of messaging tasks.  This post explores implementing this pattern with Quarkus and the new Redis data source API."
msgstr "En  link:https://quarkus.io/blog/redis-api-intro/[cómo almacenar en caché con Redis], implementamos una caché simple respaldada por Redis. + Ese es sólo un caso de uso de Redis. Redis también se utiliza como servidor de mensajería para implementar el procesamiento de trabajos en segundo plano u otros tipos de tareas de mensajería. Este post explora la implementación de este patrón con Quarkus y la nueva API de origen de datos de Redis."

#. type: Title ==
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:15
#, fuzzy, no-wrap
msgid "Job Queues and Supes!"
msgstr "¡Colas de trabajo y Supes!"

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:20
#, fuzzy
msgid "A job queue is a data structure storing _execution_ requests.  Job dispatchers submit the tasks they want to execute in that data structure.  On the other side, job consumers poll the requests and execute them."
msgstr "Una cola de trabajos es una estructura de datos que almacena solicitudes de _ejecución_. Los despachadores de trabajos envían las tareas que quieren ejecutar en esa estructura de datos. Por otro lado, los consumidores de trabajos sondean las solicitudes y las ejecutan."

#. type: Target for macro image
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:21
#, no-wrap
msgid "/assets/images/posts/redis-job-queue/pattern.png"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:27
#, fuzzy
msgid "There are plenty of variants of that pattern, so let's focus on the following application.  We have an application managing heroes and villains.  The application offers the possibility to simulate a fight between a random hero and a random villain.  The fight simulation is delegated to _fight simulators_, applications dedicated to that task."
msgstr "Hay muchas variantes de ese patrón, así que vamos a centrarnos en la siguiente aplicación. Tenemos una aplicación que gestiona héroes y villanos. La aplicación ofrece la posibilidad de simular una pelea entre un héroe y un villano al azar. La simulación de la pelea se delega en _los simuladores de pelea_, aplicaciones dedicadas a esa tarea."

#. type: Target for macro image
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:28
#, no-wrap
msgid "/assets/images/posts/redis-job-queue/application.png"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:32
#, fuzzy
msgid "In this context, the main application submits the fight request to the job queue.  Then, the fight simulators poll the submitted fight request and execute them."
msgstr "En este contexto, la aplicación principal envía la solicitud de lucha a la cola de trabajos. A continuación, los simuladores de lucha sondean las solicitudes de lucha enviadas y las ejecutan."

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:36
#, fuzzy
msgid "The fight outcomes are communicated using another Redis feature: pub/sub communication.  The simulators send the outcome to a _channel_ consumed by the application.  The application then broadcasts these outcomes to a web page."
msgstr "Los resultados de la lucha se comunican utilizando otra característica de Redis: la comunicación pub/sub. Los simuladores envían el resultado a un _canal_ consumido por la aplicación. A continuación, la aplicación transmite estos resultados a una página web."

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:40
#, fuzzy
msgid "This post only discusses the interaction with Redis.  The rest of the application is straightforward and just uses RESTEasy Reactive and Hibernate ORM with Panache.  You can find the full code of the application on https://github.com/cescoffier/quarkus-redis-job-queue-demo."
msgstr "Este post sólo habla de la interacción con Redis. El resto de la aplicación es sencilla y sólo utiliza RESTEasy Reactive y Hibernate ORM con Panache. Puedes encontrar el código completo de la aplicación en  https://github.com/cescoffier/quarkus-redis-job-queue-demo"

#. type: Title ==
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:41
#, fuzzy, no-wrap
msgid "Submitting jobs"
msgstr "Envío de trabajos"

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:45
#, fuzzy
msgid "The first task is to model the job queue.  We are using a https://redis.io/docs/data-types/#lists[Redis list] to store the https://github.com/cescoffier/quarkus-redis-job-queue-demo/blob/main/fight-simulator/src/main/java/me/escoffier/quarkus/redis/fight/FightRequest.java[FightRequest]."
msgstr "La primera tarea es modelar la cola de trabajo. Estamos utilizando una  link:https://redis.io/docs/data-types/#lists[lista de Redis] para almacenar el  link:https://github.com/cescoffier/quarkus-redis-job-queue-demo/blob/main/fight-simulator/src/main/java/me/escoffier/quarkus/redis/fight/FightRequest.java[FightRequest]."

#. type: delimited block -
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:49
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:153
#, no-wrap
msgid "package me.escoffier.quarkus.redis.fight;\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:51
#, no-wrap
msgid "public record FightRequest(String id, Hero hero, Villain villain) {\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:53
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:157
#, no-wrap
msgid "}\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:57
#, fuzzy
msgid "Redis lists distinguish the left side of the list from the right side of the list.  This distinction allows implementing a FIFO queue where we write on the left side and consume from the right side."
msgstr "Las listas Redis distinguen el lado izquierdo de la lista del lado derecho de la lista. Esta distinción permite implementar una cola FIFO en la que escribimos en el lado izquierdo y consumimos desde el lado derecho."

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:60
#, fuzzy
msgid "To manipulate a Redis list, we need the _group of commands_ associated with this data structure.  In the https://github.com/cescoffier/quarkus-redis-job-queue-demo/blob/main/supes-application/src/main/java/me/escoffier/quarkus/redis/supes/SupesService.java[SupesService class], we inject the `RedisDataSource` and retrieve the group of commands:"
msgstr "Para manipular una lista de Redis, necesitamos el grupo de _comandos_ asociado a esta estructura de datos. En la  link:https://github.com/cescoffier/quarkus-redis-job-queue-demo/blob/main/supes-application/src/main/java/me/escoffier/quarkus/redis/supes/SupesService.java[clase SupesService], inyectamos el `RedisDataSource` y recuperamos el grupo de comandos:"

#. type: delimited block -
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:67
#, no-wrap
msgid ""
"public SupesService(RedisDataSource dataSource, ...) {\n"
"    commands = dataSource.list(FightRequest.class);\n"
"  // ...\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:70
#, fuzzy
msgid "Let's now look at the `submitAFight` method:"
msgstr "Veamos ahora el método `submitAFight`:"

#. type: delimited block -
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:81
#, no-wrap
msgid ""
"public FightRequest submitAFight() {\n"
"    var hero = Hero.getRandomHero();\n"
"    var villain = Villain.getRandomVillain();\n"
"    var id = UUID.randomUUID().toString();\n"
"    var request = new FightRequest(id, hero, villain);\n"
"    commands.lpush(\"fight-requests\", request);\n"
"    return request;\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:85
#, fuzzy
msgid "The `submitAFight` method retrieves the random fighters, computes an id, builds the `FightRequest` instance, and executes the `LPUSH` command.  The `LPUSH` command writes the given item to the left side of the list stored at the given key (`fight-requests`)."
msgstr "El método `submitAFight` recupera los luchadores aleatorios, calcula un id, construye la instancia `FightRequest` y ejecuta el comando `LPUSH`. El comando `LPUSH` escribe el elemento dado a la izquierda de la lista almacenada en la clave dada ( `fight-requests`)."

#. type: Title ==
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:86
#, fuzzy, no-wrap
msgid "Receiving the job requests"
msgstr "Recepción de las solicitudes de trabajo"

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:90
#, fuzzy
msgid "Let's now look at the other side: the fight simulators.  The simulators poll the `FightRequests` from the Redis list representing our job queue and simulate the fight."
msgstr "Veamos ahora el otro lado: los simuladores de lucha. Los simuladores sondean la `FightRequests` de la lista de Redis que representa nuestra cola de trabajos y simulan el combate."

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:94
#, fuzzy
msgid "The simulator is implemented in https://github.com/cescoffier/quarkus-redis-job-queue-demo/blob/main/fight-simulator/src/main/java/me/escoffier/quarkus/redis/fight/FightSimulator.java[`me.escoffier.quarkus.redis.fight.FightSimulator`].  The constructor receives a configured name (to distinguish multiple simulators) and the Redis data source.  It creates the objects to emit the Redis commands to read from a Redis list:"
msgstr "El simulador se implementa en  link:https://github.com/cescoffier/quarkus-redis-job-queue-demo/blob/main/fight-simulator/src/main/java/me/escoffier/quarkus/redis/fight/FightSimulator.java[`me.escoffier.quarkus.redis.fight.FightSimulator`]. El constructor recibe un nombre configurado (para distinguir varios simuladores) y la fuente de datos Redis. Crea los objetos para emitir los comandos Redis para leer de una lista Redis:"

#. type: delimited block -
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:102
#, no-wrap
msgid ""
"public FightSimulator(@ConfigProperty(name = \"simulator-name\") String name, RedisDataSource ds) {\n"
"    this.name = name;\n"
"    this.queue = ds.list(FightRequest.class);\n"
"    // ...\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:109
#, fuzzy
msgid "The simulator polls the fight requests and for each of them simulate the fight.  The implementation is an _infinite_ loop (it only stops when the application is shut down).  In each iteration, it reads the pending `FightRequest` from the right side of the queue with the `BRPOP` command.  If there is no pending request, it restarts from the beginning of the loop.  If it has a request, it simulates the fight:"
msgstr "El simulador sondea las solicitudes de lucha y para cada una de ellas simula la lucha. La implementación es un bucle _infinito_ (sólo se detiene cuando se cierra la aplicación). En cada iteración, lee las `FightRequest` pendientes de la parte derecha de la cola con el comando `BRPOP`. Si no hay ninguna petición pendiente, se reinicia desde el principio del bucle. Si tiene una solicitud, simula la lucha:"

#. type: delimited block -
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:125
#, no-wrap
msgid ""
"@Override\n"
"public void run() {\n"
"    logger.infof(\"Simulator %s starting\", name);\n"
"    while ((!stopped)) {\n"
"        KeyValue<String, FightRequest> item =\n"
"            queue.brpop(Duration.ofSeconds(1), \"fight-requests\");\n"
"        if (item != null) {\n"
"            var request = item.value();\n"
"            var result = simulate(request);\n"
"            //...\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:134
#, fuzzy
msgid "The `BRPOP` command retrieves and removes the last (right) element of the list.  Unlike the `RPOP`, it waits for a given amount of time (1 second in the code above) if there are no elements in the list.  So, if the list contains an element, it gets it.  Otherwise, it waits up to one second before giving up.  It returns `null` in this case.  The `BRPOP` command returns a `KeyValue` composed of the key of the list and the `FightRequest`.  It uses that structure because you can pass multiple keys, which is convenient when you have lists with priorities."
msgstr "El comando `BRPOP` recupera y elimina el último elemento (derecho) de la lista. A diferencia de `RPOP`, espera un tiempo determinado (1 segundo en el código anterior) si no hay elementos en la lista. Entonces, si la lista contiene un elemento, lo obtiene. En caso contrario, espera hasta un segundo antes de rendirse. En este caso devuelve `null`. El comando `BRPOP` devuelve un `KeyValue` compuesto por la clave de la lista y el `FightRequest`. Utiliza esa estructura porque se pueden pasar varias claves, lo cual es conveniente cuando se tienen listas con prioridades."

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:139
#, fuzzy
msgid "The `BRPOP` command also avoids spinning indefinitely if the list is empty, as it waits for 1 second during each iteration.  Finally, the `BRPOP` command is _atomic_.  It means that if you have multiple simulators, they cannot retrieve the same item.  It dispatches each item once."
msgstr "El comando `BRPOP` también evita girar indefinidamente si la lista está vacía, ya que espera 1 segundo en cada iteración. Por último, el comando `BRPOP` es _atómico_. Esto significa que si tienes varios simuladores, no pueden recuperar el mismo elemento. Envía cada elemento una vez."

#. type: Title ==
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:140
#, fuzzy, no-wrap
msgid "Sending the fight outcome"
msgstr "Envío del resultado de la lucha"

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:144
#, fuzzy
msgid "The pool loop retrieves the `FightRequests` from the queue and simulates the fights, but how to communicate the results? For this, we use another Redis feature: pub/sub communication."
msgstr "El bucle pool recupera la `FightRequests` de la cola y simula las peleas, pero ¿cómo comunicar los resultados? Para ello, utilizamos otra característica de Redis: la comunicación pub/sub."

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:147
#, fuzzy
msgid "In simple words, we are going to send the `FightResult` to a _channel_.  Applications subscribing to that channel will receive the emitted `FightResult`."
msgstr "En palabras sencillas, vamos a enviar el `FightResult` a un _canal_. Las aplicaciones suscritas a ese canal recibirán el `FightResult` emitido."

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:149
#, fuzzy
msgid "A `FightResult` contains the request id, the two fighters, and the name of the winner:"
msgstr "Un `FightResult` contiene el identificador de la solicitud, los dos luchadores y el nombre del ganador:"

#. type: delimited block -
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:155
#, no-wrap
msgid "public record FightResult(String id, Hero hero, Villain villain, String winner) {\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:161
#, fuzzy
msgid "To use Redis _pub/sub_ commands, we need the object associated with this group.  In the `FightSimulator`, we also uses the `pubsub` method to get that object:"
msgstr "Para utilizar los comandos _pub/sub_ de Redis, necesitamos el objeto asociado a este grupo. En el `FightSimulator`, también utilizamos el método `pubsub` para obtener ese objeto:"

#. type: delimited block -
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:170
#, no-wrap
msgid ""
"public FightSimulator(@ConfigProperty(name = \"simulator-name\") String name, Logger logger, RedisDataSource ds) {\n"
"    this.name = name;\n"
"    this.logger = logger;\n"
"    this.queue = ds.list(FightRequest.class);\n"
"    this.publisher = ds.pubsub(FightResult.class);  // <--- this is it!\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:174
#, fuzzy
msgid "Now, we can use this `publisher` to send the `FightResults`.  After each fight, we call `publisher.publish` to send the `FightResult` instance to the `fight-results` channel:"
msgstr "Ahora, podemos utilizar este `publisher` para enviar el `FightResults`. Después de cada pelea, llamamos a `publisher.publish` para enviar la instancia `FightResult` al canal `fight-results`:"

#. type: delimited block -
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:189
#, no-wrap
msgid ""
"@Override\n"
"public void run() {\n"
"    logger.infof(\"Simulator %s starting\", name);\n"
"    while ((!stopped)) {\n"
"        KeyValue<String, FightRequest> item = queue.brpop(Duration.ofSeconds(1), \"fight-requests\");\n"
"        if (item != null) {\n"
"            var request = item.value();\n"
"            var result = simulate(request);\n"
"            publisher.publish(\"fight-results\", result);  // Send the outcome\n"
"           }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Title ==
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:191
#, fuzzy, no-wrap
msgid "Receiving the fight outcome"
msgstr "Recibir el resultado del combate"

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:194
#, fuzzy
msgid "At that point:"
msgstr "En ese momento:"

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:196
#, fuzzy
msgid "we submit the fight request into the job queue,"
msgstr "enviamos la solicitud de lucha a la cola de trabajos,"

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:197
#, fuzzy
msgid "we consume that queue and simulate the fight,"
msgstr "consumimos esa cola y simulamos el combate,"

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:198
#, fuzzy
msgid "we send the outcome to the `fight-results` channel."
msgstr "enviamos el resultado al canal `fight-results`."

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:203
#, fuzzy
msgid "So, the only missing piece is the consumption of that channel.  Let's return to the https://github.com/cescoffier/quarkus-redis-job-queue-demo/blob/main/supes-application/src/main/java/me/escoffier/quarkus/redis/supes/SupesService.java[`me.escoffier.quarkus.redis.supes.SupesService`] class.  In the constructor, we also inject the `ReactiveRedisDataSource`, the reactive variant of the Redis data source.  Then, in the constructor code, we subscribe to the `fight-results`."
msgstr "Por tanto, la única pieza que falta es el consumo de ese canal. Volvamos a la  link:https://github.com/cescoffier/quarkus-redis-job-queue-demo/blob/main/supes-application/src/main/java/me/escoffier/quarkus/redis/supes/SupesService.java[`me.escoffier.quarkus.redis.supes.SupesService`] clase. En el constructor, también inyectamos el `ReactiveRedisDataSource`, la variante reactiva de la fuente de datos Redis. Luego, en el código del constructor, nos suscribimos al `fight-results`."

#. type: delimited block -
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:211
#, no-wrap
msgid ""
"public SupesService(RedisDataSource dataSource, ReactiveRedisDataSource reactiveRedisDataSource) {\n"
"    commands = dataSource.list(FightRequest.class);\n"
"    stream = reactiveRedisDataSource.pubsub(FightResult.class).subscribe(\"fight-results\")\n"
"            .broadcast().toAllSubscribers();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:214
#, fuzzy
msgid "Because we use the reactive data source, this subscription returns a `Multi<FightResult>`, ready to be served by Quarkus and an SSE (see https://github.com/cescoffier/quarkus-redis-job-queue-demo/blob/main/supes-application/src/main/java/me/escoffier/quarkus/redis/supes/SupesResource.java[SupesResource.java]):"
msgstr "Como utilizamos la fuente de datos reactiva, esta suscripción devuelve un `Multi&amp;lt;FightResult&amp;gt;`, listo para ser servido por Quarkus y un SSE (véase  link:https://github.com/cescoffier/quarkus-redis-job-queue-demo/blob/main/supes-application/src/main/java/me/escoffier/quarkus/redis/supes/SupesResource.java[SupesResource.java]):"

#. type: delimited block -
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:223
#, no-wrap
msgid ""
"@GET\n"
"@Produces(MediaType.SERVER_SENT_EVENTS)\n"
"@RestStreamElementType(MediaType.APPLICATION_JSON)\n"
"public Multi<FightResult> fights() {\n"
"    return supes.getFightResults();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:227
#, fuzzy
msgid "`.broadcast().toAllSubscribers()` instructs Quarkus to broadcast all the received `FightResult` to all the connected SSE.  So, the browser filters out unrequested results."
msgstr "`.broadcast().toAllSubscribers()` indica a Quarkus que difunda todos los `FightResult` recibidos a todos los SSE conectados. Así, el navegador filtra los resultados no solicitados."

#. type: Title ==
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:228
#, fuzzy, no-wrap
msgid "Running the system"
msgstr "Funcionamiento del sistema"

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:233
#, fuzzy
msgid "The circle is complete! The full code source is available from https://github.com/cescoffier/quarkus-redis-job-queue-demo.  To run the system, open three terminals."
msgstr "El círculo se ha completado. El código fuente completo está disponible en  https://github.com/cescoffier/quarkus-redis-job-queue-demo  Para ejecutar el sistema, abra tres terminales."

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:240
#, fuzzy
msgid "First, we start the `supes-application`.  In the first terminal, navigate to the `supes-application` and run `mvn quarkus:dev` Quarkus automatically starts the PostgreSQL and Redis instances (if your machine can run containers).  In the console, hit `h` and then `c`.  It displays the running dev services.  Look for the redis one, and copy the `quarkus.redis.hosts` injected configuration:"
msgstr "En primer lugar, iniciamos el `supes-application`. En el primer terminal, navega hasta el `supes-application` y ejecuta `mvn quarkus:dev`. Quarkus inicia automáticamente las instancias de PostgreSQL y Redis (si tu máquina puede ejecutar contenedores). En la consola, pulsa `h` y luego `c`. Muestra los servicios de desarrollo en ejecución. Busca el de Redis y copia la configuración inyectada en `quarkus.redis.hosts`:"

#. type: delimited block -
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:248
#, no-wrap
msgid ""
"redis-client - Up About a minute\n"
"  Container:        348edec50f80/trusting_jennings  docker.io/redis:7-alpine\n"
"  Network:          bridge - 0.0.0.0:53853->6379/tcp\n"
"  Exec command:     docker exec -it 348edec50f80 /bin/bash\n"
"  Injected Config:  quarkus.redis.hosts=redis://localhost:53853\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:253
#, fuzzy
msgid "In the previous snippet, copy: `quarkus.redis.hosts=redis://localhost:53853`.  This is the address of the redis server.  We need to configure to the simulators with that address."
msgstr "En el fragmento anterior, copia: `quarkus.redis.hosts=redis://localhost:53853`. Esta es la dirección del servidor de redis. Necesitamos configurar a los simuladores con esa dirección."

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:256
#, fuzzy
msgid "If you go to http://localhost:8080, the web page is served.  You can hit the `fights!` button a few times."
msgstr "Si vas a  http://localhost:8080  la página web está servida. Puede pulsar el botón `fights!` varias veces."

#. type: Target for macro image
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:257
#, no-wrap
msgid "/assets/images/posts/redis-job-queue/screenshot.png"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:262
#, fuzzy
msgid "The fight won't happen as we have no simulator.  However, the fight requests have been submitted and stored in the list.  So they are not lost."
msgstr "El combate no se llevará a cabo porque no tenemos simulador. Sin embargo, las solicitudes de lucha han sido enviadas y almacenadas en la lista. Así que no se han perdido."

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:264
#, fuzzy
msgid "Now, in the second terminal, navigate to the `fight-simulator` directory, and run:"
msgstr "Ahora, en el segundo terminal, navega al directorio `fight-simulator`, y ejecuta:"

#. type: delimited block -
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:269
#, no-wrap
msgid ""
"mvn package\n"
"java -Dsimulator-name=A -Dquarkus.redis.hosts=redis://localhost:53853 -jar target/quarkus-app/quarkus-run.jar\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:272
#, fuzzy, no-wrap
msgid "*IMPORTANT*: update the `quarkus.redis-hosts` with the one copied above.\n"
msgstr "*IMPORTANTE*: actualice el `quarkus.redis-hosts` con el copiado arriba."

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:274
#, fuzzy
msgid "As soon as you start it, it processes the pending fight requests:"
msgstr "En cuanto se inicia, procesa las solicitudes de lucha pendientes:"

#. type: delimited block -
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:280
#, no-wrap
msgid ""
"2022-09-11 15:31:58,914 INFO  [me.esc.qua.red.fig.FightSimulator] (Thread-3) Simulator A is going to simulate a fight between Pakku and Tulon Voidgazer\n"
"2022-09-11 15:31:59,786 INFO  [me.esc.qua.red.fig.FightSimulator] (Thread-3) Simulator A is going to simulate a fight between Comet Zuko and Arishem The Judge (Knullified)\n"
"2022-09-11 15:32:01,809 INFO  [me.esc.qua.red.fig.FightSimulator] (Thread-3) Simulator A is going to simulate a fight between Ms. America and Kazumi (Devil Form)\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:283
#, fuzzy
msgid "If you go back to the web page, the winners get a _halo_:"
msgstr "Si vuelves a la página web, los ganadores reciben un _halo_:"

#. type: Target for macro image
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:284
#, no-wrap
msgid "/assets/images/posts/redis-job-queue/screenshot-winner.png"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:287
#, fuzzy
msgid "Now, in the third terminal, navigate to the `fight-simulator` directory, and run:"
msgstr "Ahora, en la tercera terminal, navega al directorio `fight-simulator`, y ejecuta:"

#. type: delimited block -
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:291
#, no-wrap
msgid "java -Dsimulator-name=B -Dquarkus.redis.hosts=redis://localhost:53853 -jar target/quarkus-app/quarkus-run.jar\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:294
#, fuzzy, no-wrap
msgid "*IMPORTANT*: as in the previous command, update the `quarkus.redis-hosts` with the one copied above.\n"
msgstr "*IMPORTANTE*: al igual que en el comando anterior, actualice el `quarkus.redis-hosts` con el copiado anteriormente."

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:297
#, fuzzy
msgid "Go back to the web page and click on the `fight!` button a few times.  Check the logs of both simulators to see that the fight requests are now dispatched beween the two simulators."
msgstr "Vuelve a la página web y haz clic en el botón `fight!` varias veces. Compruebe los registros de ambos simuladores para ver que las solicitudes de lucha se envían ahora entre los dos simuladores."

#. type: Title ==
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:298
#, fuzzy, no-wrap
msgid "Summary"
msgstr "Resumen"

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:301
#, fuzzy
msgid "This posts explains how you can implement a job queue with Redis and the Quarkus Redis datasource API."
msgstr "Este post explica cómo se puede implementar una cola de trabajo con Redis y la API de fuente de datos Redis de Quarkus."

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:303
#, fuzzy
msgid "Learn more about the Redis data source API from the https://quarkus.io/guides/redis[Quarkus documentation].  We will publish more content about Redis patterns, so stay tuned!"
msgstr "Aprende más sobre la API de la fuente de datos Redis en la  link:https://quarkus.io/guides/redis[documentación de Quarkus]. Publicaremos más contenido sobre los patrones de Redis, ¡así que estate atento!"
