# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2023-01-25 13:21+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: YAML Front Matter: author
#: upstream/_posts/2023-01-16-native-adopts-adaptive-gc-policy.adoc:1
#, fuzzy, no-wrap
msgid "galderz"
msgstr "galderz"

#. type: YAML Front Matter: date
#: upstream/_posts/2023-01-16-native-adopts-adaptive-gc-policy.adoc:1
#, fuzzy, no-wrap
msgid "2023-01-25"
msgstr "2023-01-25"

#. type: YAML Front Matter: layout
#: upstream/_posts/2023-01-16-native-adopts-adaptive-gc-policy.adoc:1
#, no-wrap
msgid "post"
msgstr "post"

#. type: YAML Front Matter: synopsis
#: upstream/_posts/2023-01-16-native-adopts-adaptive-gc-policy.adoc:1
#, fuzzy, no-wrap
msgid "Native runtime GC policy switches to adaptive to more consistency and predictability"
msgstr "La política nativa de GC en tiempo de ejecución cambia a adaptativa para mayor coherencia y previsibilidad."

#. type: YAML Front Matter: tags
#: upstream/_posts/2023-01-16-native-adopts-adaptive-gc-policy.adoc:1
#, fuzzy, no-wrap
msgid "native gc"
msgstr "gc nativo"

#. type: YAML Front Matter: title
#: upstream/_posts/2023-01-16-native-adopts-adaptive-gc-policy.adoc:1
#, fuzzy, no-wrap
msgid "Quarkus Native adopts Adaptive GC policy"
msgstr "Quarkus Native adopta una política de GC adaptable"

#. type: Plain text
#: upstream/_posts/2023-01-16-native-adopts-adaptive-gc-policy.adoc:13
#, fuzzy
msgid "Starting with Quarkus 2.13.6.Final, the native runtime garbage collection policy switched in order to provide more consistent and predictable runtime performance.  This blog post tells the story of this switch."
msgstr "A partir de Quarkus 2.13.6.Final, la política nativa de recolección de basura en tiempo de ejecución cambió con el fin de proporcionar un rendimiento en tiempo de ejecución más consistente y predecible. Esta entrada de blog cuenta la historia de este cambio."

#. type: Plain text
#: upstream/_posts/2023-01-16-native-adopts-adaptive-gc-policy.adoc:17
#, fuzzy
msgid "Sometime in 2022 while carrying out some native runtime performance benchmarking we observed that, in constant load plain text benchmarks, memory consumption would grow continuously until it reached around 500MB and then it would drop.  The memory consumption graph would look something like this:"
msgstr "En algún momento de 2022, mientras realizábamos algunas pruebas de rendimiento en tiempo de ejecución nativo, observamos que, en pruebas de texto plano de carga constante, el consumo de memoria crecía continuamente hasta que alcanzaba unos 500 MB y, a continuación, descendía. El gráfico de consumo de memoria se vería más o menos así:"

#. type: Target for macro image
#: upstream/_posts/2023-01-16-native-adopts-adaptive-gc-policy.adoc:18
#, no-wrap
msgid "space-time-memory-consumption.png"
msgstr ""

#. type: Plain text
#: upstream/_posts/2023-01-16-native-adopts-adaptive-gc-policy.adoc:25
#, fuzzy
msgid "The graph above was obtained with VisualVM.  This feature has only been available in the GraalVM Community Edition starting with version 22.3.0.  See https://www.graalvm.org/latest/tools/visualvm[here] for more details."
msgstr "El gráfico anterior se ha obtenido con VisualVM. Esta característica sólo ha estado disponible en la GraalVM Community Edition a partir de la versión 22.3.0. Ver  link:https://www.graalvm.org/latest/tools/visualvm[aquí] para más detalles."

#. type: Plain text
#: upstream/_posts/2023-01-16-native-adopts-adaptive-gc-policy.adoc:29
#, fuzzy
msgid "The graph looked suspicious.  At a first glance, small garbage collections were happening regularly but those collections were not able to fully collect all the garbage.  This uncollected garbage would continue to grow until around the 500MB mark, at which point a full garbage collection would happen and it would clear the growing leak."
msgstr "El gráfico parecía sospechoso. A primera vista, se estaban produciendo pequeñas recolecciones de basura con regularidad, pero esas recolecciones no eran capaces de recoger toda la basura. Esta basura no recolectada continuaba creciendo hasta alrededor de los 500 MB, momento en el que se producía una recolección de basura completa que eliminaba la creciente fuga."

#. type: Plain text
#: upstream/_posts/2023-01-16-native-adopts-adaptive-gc-policy.adoc:34
#, fuzzy
msgid "The first thing we wondered was, what this ~500MB limit was and where it was coming from.  To do that, we enabled GC logging to see if we could get some clues:"
msgstr "Lo primero que nos preguntamos fue qué era ese límite de ~500 MB y de dónde procedía. Para ello, activamos el registro de GC para ver si podíamos obtener alguna pista:"

#. type: delimited block -
#: upstream/_posts/2023-01-16-native-adopts-adaptive-gc-policy.adoc:46
#, no-wrap
msgid ""
"$ quarkus-project/target/quarkus-project-1.0.0-SNAPSHOT-runner -XX:+PrintGC -XX:+VerboseGC\n"
"2023-01-09 13:29:32,155 INFO  [io.quarkus] (main) quarkus-project 1.0.0-SNAPSHOT native (powered by Quarkus 2.15.2.Final) started in 0.017s. Listening on: http://0.0.0.0:8080\n"
"...\n"
"[Heap policy parameters:\n"
"  YoungGenerationSize: 268435456\n"
"      MaximumHeapSize: 27487790640\n"
"      MinimumHeapSize: 536870912 <--\n"
"     AlignedChunkSize: 1048576\n"
"  LargeArrayThreshold: 131072]\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2023-01-16-native-adopts-adaptive-gc-policy.adoc:50
#, fuzzy
msgid "We realized that this number is actually 512MB, which is the default minimum heap size GraalVM configures when the maximum heap size is anything above ~3GB of physical memory."
msgstr "Nos dimos cuenta de que este número es en realidad 512MB, que es el tamaño mínimo de heap por defecto que GraalVM configura cuando el tamaño máximo de heap es cualquier cosa por encima de ~3GB de memoria física."

#. type: Plain text
#: upstream/_posts/2023-01-16-native-adopts-adaptive-gc-policy.adoc:59
#, fuzzy
msgid "The next question was, why is there a relationship between the minimum heap size and the memory consumption at which a full GC appears to happen? Looking at the output above, on our system the default maximum heap size is 25.6GB.  GraalVM defaults the maximum heap size to 80% of the physical memory if no specific configuration is passed, and indeed 25.6GB is 80% of 32GB.  It would seem odd to do a full GC when 512MB have been consumed, given that our system has given it a maximum heap size that is far bigger.  The answer was found in the GC policy Quarkus was explicitly configuring."
msgstr "La siguiente pregunta era, ¿por qué existe una relación entre el tamaño mínimo de la pila y el consumo de memoria en el que una GC completa parece ocurrir? Mirando la salida de arriba, en nuestro sistema el tamaño máximo de heap por defecto es de 25.6GB. GraalVM por defecto el tamaño máximo de la pila al 80% de la memoria física si no se pasa ninguna configuración específica, y de hecho 25,6 GB es el 80% de 32 GB. Parecería extraño hacer una GC completa cuando se han consumido 512MB, dado que nuestro sistema le ha dado un tamaño máximo de heap que es mucho mayor. La respuesta la encontramos en la política de GC que Quarkus estaba configurando explícitamente."

#. type: Plain text
#: upstream/_posts/2023-01-16-native-adopts-adaptive-gc-policy.adoc:66
#, fuzzy
msgid "By default GraalVM uses a GC policy called \"adaptive\", but Quarkus was instead instructing GraalVM to use another GC policy called \"by space and time\".  The full story on why Quarkus was using a different GC policy can be found https://github.com/quarkusio/quarkus/issues/28267[here], but to summarize, the decision was made in 2018, when \"by space and time\" appeared to generate less full GCs and offered considerably better throughput."
msgstr "Por defecto, GraalVM utiliza una política de GC llamada \"adaptativa\", pero Quarkus, en cambio, estaba instruyendo a GraalVM para que utilizara otra política de GC llamada \"por espacio y tiempo\". La historia completa de por qué Quarkus estaba usando una política de GC diferente se puede encontrar  link:https://github.com/quarkusio/quarkus/issues/28267[aquí], pero para resumir, la decisión fue tomada en 2018, cuando \"por espacio y tiempo\" parecía generar menos GCs completas y ofrecía un rendimiento considerablemente mejor."

#. type: Plain text
#: upstream/_posts/2023-01-16-native-adopts-adaptive-gc-policy.adoc:69
#, fuzzy
msgid "The \"by space and time\" GC policy implemented a `shouldCollectCompletely` method that decided whether to do a complete (full) or incremental (minimal) collection.  The relevant code of the \"by space and time\" GC policy is the following:"
msgstr "La política de GC \"por espacio y tiempo\" implementaba un método `shouldCollectCompletely` que decidía si hacer una recolección completa (full) o incremental (minimal). El código relevante de la política GC \"por espacio y tiempo\" es el siguiente:"

#. type: delimited block -
#: upstream/_posts/2023-01-16-native-adopts-adaptive-gc-policy.adoc:74
#, no-wrap
msgid ""
"return estimateUsedHeapAtNextIncrementalCollection().aboveThan(getMaximumHeapSize()) // (1)\n"
"  || GCImpl.getChunkBytes().aboveThan(getMinimumHeapSize()) && enoughTimeSpentOnIncrementalGCs(); // (2)\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2023-01-16-native-adopts-adaptive-gc-policy.adoc:80
#, fuzzy
msgid "One option `(1)` for doing a full GC would be when it estimates that the used heap will exceed maximum heap size, but that wasn’t our case.  The other `(2)` would be if enough minimal collections had happened and the used heap was above the minimum heap size.  This latter option was what was happening here."
msgstr "Una opción `(1)` para hacer una GC completa sería cuando se estima que el heap usado excederá el tamaño máximo del heap, pero ese no fue nuestro caso. La otra `(2)` sería si se hubieran producido suficientes recolecciones mínimas y el heap utilizado estuviera por encima del tamaño mínimo del heap. Esta última opción era lo que estaba ocurriendo aquí."

#. type: Plain text
#: upstream/_posts/2023-01-16-native-adopts-adaptive-gc-policy.adoc:85
#, fuzzy
msgid "At this point we thought, do the assumptions made about the default GC policy still apply in 2022? So, we removed the GC policy configuration tweak, repeated the test and we observed the following memory consumption:"
msgstr "Llegados a este punto pensamos, ¿siguen siendo válidas en 2022 las suposiciones realizadas sobre la política GC por defecto? Así que eliminamos el ajuste de configuración de la política de GC, repetimos la prueba y observamos el siguiente consumo de memoria:"

#. type: Target for macro image
#: upstream/_posts/2023-01-16-native-adopts-adaptive-gc-policy.adoc:86
#, no-wrap
msgid "adaptive-memory-consumption.png"
msgstr ""

#. type: Plain text
#: upstream/_posts/2023-01-16-native-adopts-adaptive-gc-policy.adoc:94
#, fuzzy
msgid "For the same workload the default GC policy, called \"adaptive\", consumed close to 50% less heap compared to the \"by space and time\" one.  Note, however, that these graphs alone are not enough to make the switch since we could have a situation where \"adaptive\" is using less memory because the overall throughput is less.  So, let’s look at the benchmark that generated the graphs above and see what throughput numbers we obtain.  Using https://github.com/Hyperfoil/Hyperfoil[Hyperfoil], the \"by space and time\" policy reported these numbers on our environment:"
msgstr "Para la misma carga de trabajo, la política de GC por defecto, denominada \"adaptativa\", consumió cerca de un 50% menos de heap en comparación con la \"por espacio y tiempo\". Tenga en cuenta, sin embargo, que estos gráficos por sí solos no son suficientes para hacer el cambio, ya que podríamos tener una situación en la que \"adaptable\" está utilizando menos memoria porque el rendimiento global es menor. Así que veamos el benchmark que generó los gráficos anteriores y veamos qué cifras de rendimiento obtenemos. Usando  link:https://github.com/Hyperfoil/Hyperfoil[Hyperfoil], la política \"por espacio y tiempo\" reportó estos números en nuestro entorno:"

#. type: delimited block -
#: upstream/_posts/2023-01-16-native-adopts-adaptive-gc-policy.adoc:100
#, no-wrap
msgid ""
"[hyperfoil@in-vm]$ wrk -t 128 -c 512 -H 'accept: text/plain' -d 16m http://<host>:8080/hello\n"
"PHASE        METRIC   THROUGHPUT    REQUESTS  ... TIMEOUTS  ERRORS  BLOCKED   2xx\n"
"test         request  93.79k req/s  90036541  ...        0       0      0 ns  90036094\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2023-01-16-native-adopts-adaptive-gc-policy.adoc:103
#, fuzzy
msgid "And here are the numbers for the \"adaptive\" policy:"
msgstr "Y aquí están las cifras de la política \"adaptativa\":"

#. type: delimited block -
#: upstream/_posts/2023-01-16-native-adopts-adaptive-gc-policy.adoc:109
#, no-wrap
msgid ""
"[hyperfoil@in-vm]$ wrk -t 128 -c 512 -H 'accept: text/plain' -d 16m http://<host>:8080/hello\n"
"PHASE        METRIC   THROUGHPUT    REQUESTS  ... TIMEOUTS  ERRORS  BLOCKED   2xx\n"
"test         request  93.05k req/s  89329151  ...         0       0     0 ns  89328711\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2023-01-16-native-adopts-adaptive-gc-policy.adoc:115
#, fuzzy
msgid "The results were obtained with `wrk`, which is known to have issues with latency numbers (see https://redhatperf.github.io/post/coordinated-omission[this blog post] for more details), so we can ignore those in the context of this blog post and focus on throughput numbers."
msgstr "Los resultados se obtuvieron con `wrk`, que se sabe que tiene problemas con las cifras de latencia (para más detalles, véase  link:https://redhatperf.github.io/post/coordinated-omission[esta] entrada de blog), por lo que podemos ignorarlas en el contexto de esta entrada de blog y centrarnos en las cifras de rendimiento."

#. type: Plain text
#: upstream/_posts/2023-01-16-native-adopts-adaptive-gc-policy.adoc:121
#, fuzzy
msgid "For the same workload, the throughput obtained with the \"adaptive\" policy is within 1% of the one obtained with the \"by space and time\" policy.  So getting pretty much the same throughput with \"adaptive\" as with \"by space and time\" and close to 50% less memory consumption, made it a pretty convincing argument to switch to the \"adaptive\" GC policy as the default for Quarkus, as it was already the case for other GraalVM."
msgstr "Para la misma carga de trabajo, el rendimiento obtenido con la política \"adaptativa\" está dentro del 1% del obtenido con la política \"por espacio y tiempo\". Así que obtener prácticamente el mismo rendimiento con \"adaptable\" que con \"por espacio y tiempo\" y cerca de un 50% menos de consumo de memoria, lo convirtió en un argumento bastante convincente para cambiar a la política de GC \"adaptable\" como predeterminada para Quarkus, como ya era el caso para otros GraalVM."

#. type: Plain text
#: upstream/_posts/2023-01-16-native-adopts-adaptive-gc-policy.adoc:126
#, fuzzy
msgid "The memory consumption benefits do not apply evenly across all heap sizes.  Numbers like the ones published in this blog post would apply for maximum heap sizes that are equal or above 3GB, at which stage the default minimum heap size is set to ~512MB unless configured otherwise.  For smaller maximum heap sizes, the memory consumption improvements might be smaller or non-existent."
msgstr "Las ventajas de consumo de memoria no se aplican uniformemente a todos los tamaños de montón. Números como los publicados en esta entrada del blog se aplicarían para tamaños máximos de heap iguales o superiores a 3 GB, momento en el que el tamaño mínimo de heap por defecto se establece en ~512 MB a menos que se configure de otro modo. Para tamaños máximos de heap más pequeños, las mejoras en el consumo de memoria pueden ser menores o inexistentes."

#. type: Plain text
#: upstream/_posts/2023-01-16-native-adopts-adaptive-gc-policy.adoc:131
#, fuzzy
msgid "We often see tests or benchmarks run with no `-Xmx` configured, in which case as stated above, the maximum heap size is set to 80% of the available physical memory and this heap size can easily exceed 3GB on modern hardware.  These users would see better out of the box experience with the \"adaptive\" GC policy."
msgstr "A menudo vemos pruebas o puntos de referencia ejecutados sin `-Xmx` configurado, en cuyo caso, como se ha indicado anteriormente, el tamaño máximo del montón se establece en el 80% de la memoria física disponible y este tamaño del montón puede superar fácilmente los 3 GB en el hardware moderno. Estos usuarios tendrían una mejor experiencia con la política de GC \"adaptativa\"."

#. type: Plain text
#: upstream/_posts/2023-01-16-native-adopts-adaptive-gc-policy.adoc:136
#, fuzzy
msgid "So, starting with Quarkus 2.13.6.Final, the GC policy for Quarkus native applications was aligned with GraalVM's default, called \"adaptive\".  It is still possible to set the GC policy back to \"by space and time\", should that work better in a specific case.  This can be useful to do if you observe a regression with this GC policy change in your own Quarkus application.  To do so, pass in:"
msgstr "Así, a partir de Quarkus 2.13.6.Final, la política de GC para las aplicaciones nativas de Quarkus se alineó con la predeterminada de GraalVM, llamada \"adaptativa\". Todavía es posible establecer la política de GC de nuevo a \"por espacio y tiempo\", si eso funciona mejor en un caso específico. Esto puede ser útil hacerlo si observas una regresión con este cambio de política GC en tu propia aplicación Quarkus. Para ello, pasa:"

#. type: delimited block -
#: upstream/_posts/2023-01-16-native-adopts-adaptive-gc-policy.adoc:140
#, no-wrap
msgid "-Dquarkus.native.additional-build-args=-H:InitialCollectionPolicy=com.oracle.svm.core.genscavenge.CollectionPolicy\\$BySpaceAndTime\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2023-01-16-native-adopts-adaptive-gc-policy.adoc:143
#, fuzzy
msgid "It is necessary to escape `$` sign if passing in via command line."
msgstr "Es necesario escapar `$` signo si se pasa a través de línea de comandos."

#. type: Plain text
#: upstream/_posts/2023-01-16-native-adopts-adaptive-gc-policy.adoc:149
#, fuzzy
msgid "More details on the investigation carried out can be found in https://github.com/quarkusio/quarkus/issues/28267[the original GitHub issue].  As a result of this work, we have also enhanced the Quarkus Native Reference Guide to add a https://quarkus.io/guides/native-reference#native-memory-management[Native Memory Management section].  This new section should help Quarkus Native users understand how memory management works and how to get the most out of it."
msgstr "Se pueden encontrar más detalles sobre la investigación llevada a cabo en la  link:https://github.com/quarkusio/quarkus/issues/28267[incidencia original de GitHub]. Como resultado de este trabajo, también hemos mejorado la Guía de Referencia de Quarkus Native para añadir una  link:https://quarkus.io/guides/native-reference#native-memory-management[sección de Gestión de Memoria Nativa]. Esta nueva sección debería ayudar a los usuarios de Quarkus Native a entender cómo funciona la gestión de memoria y cómo sacarle el máximo partido."
